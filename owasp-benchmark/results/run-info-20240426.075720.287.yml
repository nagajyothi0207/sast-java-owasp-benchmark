---
queries:
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Declarations/MissingOverrideAnnotation.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Declarations/MissingOverrideAnnotation.bqrs
  metadata:
    name: Missing Override annotation
    description: |-
      A method that overrides a method in a superclass but does not have an 'Override'
                    annotation cannot take advantage of compiler checks, and makes code less readable.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/missing-override-annotation
    tags: maintainability
  queryHelp: "# Missing Override annotation\nJava enables you to annotate methods\
    \ that are intended to override a method in a superclass. Compilers are required\
    \ to generate an error if such an annotated method does not override a method\
    \ in a superclass, which provides increased protection from potential defects.\
    \ An annotated method also improves code readability.\n\n\n## Recommendation\n\
    Add an `@Override` annotation to a method that is intended to override a method\
    \ in a superclass.\n\n\n## Example\nIn the following example, `Triangle.getArea`\
    \ overrides `Rectangle.getArea`, so it is annotated with `@Override`.\n\n\n```java\n\
    class Rectangle\n{\n    private int w = 10, h = 10;\n    public int getArea()\
    \ { \n        return w * h; \n    }\n}\n \nclass Triangle extends Rectangle\n\
    {\n    @Override  // Annotation of an overriding method \n    public int getArea()\
    \ { \n        return super.getArea() / 2; \n    }\n}\n```\n\n## References\n*\
    \ J. Bloch, *Effective Java (second edition)*, Item 36. Addison-Wesley, 2008.\n\
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n\
    * The Java Tutorials: [Predefined Annotation Types](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Deprecated Code/AvoidDeprecatedCallableAccess.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Deprecated Code/AvoidDeprecatedCallableAccess.bqrs
  metadata:
    name: Deprecated method or constructor invocation
    description: |-
      Using a method or constructor that has been marked as deprecated may be dangerous or
                    fail to take advantage of a better method or constructor.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/deprecated-call
    tags: |-
      maintainability
             non-attributable
             external/cwe/cwe-477
  queryHelp: |
    # Deprecated method or constructor invocation
    A method (or constructor) can be marked as deprecated using either the `@Deprecated` annotation or the `@deprecated` Javadoc tag. Using a method that has been marked as deprecated is bad practice, typically for one or more of the following reasons:

    * The method is dangerous.
    * There is a better alternative method.
    * Methods that are marked as deprecated are often removed from future versions of an API. So using a deprecated method may cause extra maintenance effort when the API is upgraded.

    ## Recommendation
    Avoid using a method that has been marked as deprecated. Follow any guidance that is provided with the `@deprecated` Javadoc tag, which should explain how to replace the call to the deprecated method.


    ## References
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * Java API Specification: [Annotation Type Deprecated](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Deprecated.html).
    * Java SE Documentation: [How and When To Deprecate APIs](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html).
    * Common Weakness Enumeration: [CWE-477](https://cwe.mitre.org/data/definitions/477.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Documentation/ImpossibleJavadocThrows.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Documentation/ImpossibleJavadocThrows.bqrs
  metadata:
    name: Javadoc has impossible 'throws' tag
    description: |-
      Javadoc that incorrectly claims a method or constructor can throw an exception
                    is misleading.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/inconsistent-javadoc-throws
    tags: maintainability
  queryHelp: "# Javadoc has impossible 'throws' tag\nA Javadoc `@throws` or `@exception`\
    \ tag that references an exception that cannot be thrown is misleading.\n\n\n\
    ## Recommendation\nEnsure that you only include the `@throws` or `@exception`\
    \ tags in Javadoc when an exception can be thrown.\n\n\n## Example\nThe following\
    \ example shows a method with Javadoc that claims it can throw `Exception`. Since\
    \ `Exception` is a checked exception and the method does not declare that it may\
    \ throw an exception, the Javadoc is wrong and should be updated.\n\n\n```java\n\
    /**\n * Javadoc for method.\n *\n * @throws Exception if a problem occurs.\n */\n\
    public void noThrow() {\n\tSystem.out.println(\"This method does not throw.\"\
    );\n}\n```\nIn the following example the Javadoc has been corrected by removing\
    \ the `@throws` tag.\n\n\n```java\n/**\n * Javadoc for method.\n */\npublic void\
    \ noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\n\
    \n## References\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc\
    \ Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#throwstag),\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Advisory/Documentation/SpuriousJavadocParam.ql
  relativeBqrsPath: codeql/java-queries/Advisory/Documentation/SpuriousJavadocParam.bqrs
  metadata:
    name: Spurious Javadoc @param tags
    description: |-
      Javadoc @param tags that do not match any parameters in the method or constructor or
                    any type parameters of the annotated class are confusing.
    kind: problem
    problem.severity: recommendation
    precision: very-high
    id: java/unknown-javadoc-parameter
    tags: maintainability
  queryHelp: "# Spurious Javadoc @param tags\nJavadoc comments for public methods,\
    \ constructors and generic classes should use the `@param` tag to describe the\
    \ available parameters and type parameters. If the comment includes any empty,\
    \ incorrect or outdated parameter names then this will make the documentation\
    \ more difficult to read.\n\n\n## Recommendation\nThe Javadoc comment for a method,\
    \ constructor or generic class should always use non-empty `@param` values that\
    \ match actual parameter or type parameter names.\n\n\n## Example\nThe following\
    \ example shows good and bad Javadoc comments that use the `@param` tag.\n\n\n\
    ```java\n/**\n * BAD: The following param tag is empty.\n *\n * @param   \n */\
    \ \npublic void emptyParamTag(int p){ ... }\n\n\n/**\n * BAD: The following param\
    \ tag has a misspelled value.\n *\n * @param prameter The parameter's value.\n\
    \ */ \npublic void typo(int parameter){ ... }\n\n\n/**\n * BAD: The following\
    \ param tag appears to be outdated\n * since the method does not take any parameters.\n\
    \ *\n * @param sign The number's sign.\n */ \npublic void outdated(){ ... }\n\n\
    \n/**\n * BAD: The following param tag uses html within the tag value.\n *\n *\
    \ @param <code>ordinate</code> The value of the y coordinate.\n */ \npublic void\
    \ html(int ordinate){ ... }\n\n\n/**\n * BAD: Invalid syntax for type parameter.\n\
    \ *\n * @param T The type of the parameter.\n * @param parameter The parameter\
    \ value.\n */ \npublic <T> void parameterized(T parameter){ ... }\n\n/**\n * BAD:\
    \ The following param tag refers to a non-existent type parameter.\n * \n * @param\
    \ <X> The type of the elements.\n */\nclass Generic<T> { ... }\n\n/**\n * GOOD:\
    \ A proper Javadoc comment.\n *\n * This method calculates the absolute value\
    \ of a given number.\n *\n * @param <T> The number's type.\n * @param x The number\
    \ to calculate the absolute value of.\n * @return The absolute value of <code>x</code>.\n\
    \ */ \npublic <T extends Number> T abs(T x){ ... }\n\n```\n\n## References\n*\
    \ Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n\
    * Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#@param),\
    \ [Documentation Comment Specification for the Standard Doclet](https://docs.oracle.com/en/java/javase/11/docs/specs/doc-comment-spec.html#param)\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Compatibility/JDK9/JdkInternalAccess.ql
  relativeBqrsPath: codeql/java-queries/Compatibility/JDK9/JdkInternalAccess.bqrs
  metadata:
    name: Access to unsupported JDK-internal API
    description: |-
      Use of unsupported JDK-internal APIs may cause compatibility issues
                    when upgrading to newer versions of Java, in particular Java 9.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/jdk-internal-api-access
    tags: maintainability
  queryHelp: |
    # Access to unsupported JDK-internal API
    Java 9 removes access to various unsupported JDK-internal APIs by default.


    ## Recommendation
    Examine the use of unsupported JDK-internal APIs and consider replacing them with supported APIs as recommended in the references.


    ## References
    * Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).
    * OpenJDK Documentation: [Java Dependency Analysis Tool](https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool), [JEP 260: Encapsulate Most Internal APIs](https://openjdk.java.net/jeps/260), [JEP 261: Module System](https://openjdk.java.net/jeps/261).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Compatibility/JDK9/UnderscoreIdentifier.ql
  relativeBqrsPath: codeql/java-queries/Compatibility/JDK9/UnderscoreIdentifier.bqrs
  metadata:
    name: Underscore used as identifier
    description: |-
      Use of a single underscore character as an identifier
                    results in a compiler error with Java source level 9 or later.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/underscore-identifier
    tags: maintainability
  queryHelp: |
    # Underscore used as identifier
    The underscore character is a reserved keyword in Java 9 and therefore disallowed as a one-character identifier.


    ## Recommendation
    Rename any identifiers that consist of a one-character underscore.


    ## References
    * Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).
    * JDK Bug System: [Disallow _ as a one-character identifier](https://bugs.openjdk.java.net/browse/JDK-8061549).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: DeadCode/UselessParameter.ql
  relativeBqrsPath: codeql/java-queries/DeadCode/UselessParameter.bqrs
  metadata:
    name: Useless parameter
    description: Parameters that are not used add unnecessary complexity to an interface.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/unused-parameter
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Useless parameter\nParameters that are never read in the body of the\
    \ method, and are not required due to overriding, are useless and can be removed.\
    \ Useless parameters unnecessarily complicate the interface for that method, and\
    \ cause a maintenance and development burden.\n\nMethods with useless parameters\
    \ indicate that either the method can be simplified by removing the parameter,\
    \ or that the method is not using a value it should be using. Parameters of methods\
    \ that override other methods will not be marked as useless, because they are\
    \ required. Similarly, parameters of methods that are overridden by other methods\
    \ are not marked as useless if they are used by one of the overriding methods.\n\
    \n\n## Recommendation\nThe method should be inspected to determine whether the\
    \ parameter should be used within the body. If the method is overridden, also\
    \ consider whether any override methods should be using the parameter. If the\
    \ parameter is not required, it should be removed.\n\n\n## Example\nIn the following\
    \ example, we have a method for determining whether a `String` path is an absolute\
    \ path:\n\n\n```java\npublic void isAbsolutePath(String path, String name) {\n\
    \treturn path.startsWith(\"/\") || path.startsWith(\"\\\\\");\n}\n```\nThe method\
    \ uses the parameter `path` to determine the return value. However, the parameter\
    \ `name` is not used within the body of the method. The parameter will be marked\
    \ as useless, and can be removed from the program.\n\n\n## References\n* Wikipedia:\
    \ [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java\
    \ Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Diagnostics/ExtractionErrors.ql
  relativeBqrsPath: codeql/java-queries/Diagnostics/ExtractionErrors.bqrs
  metadata:
    name: Extraction errors
    description: A list of extraction errors for files in the source code directory.
    kind: diagnostic
    id: java/diagnostics/extraction-errors
  queryHelp: null
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Diagnostics/ExtractionWarnings.ql
  relativeBqrsPath: codeql/java-queries/Diagnostics/ExtractionWarnings.bqrs
  metadata:
    name: Extraction warnings
    description: A list of extraction warnings for files in the source code directory.
    kind: diagnostic
    id: java/diagnostics/extraction-warnings
  queryHelp: null
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Diagnostics/SuccessfullyExtractedFiles.ql
  relativeBqrsPath: codeql/java-queries/Diagnostics/SuccessfullyExtractedFiles.bqrs
  metadata:
    name: Extracted files
    description: |-
      A list of all files in the source code directory that
                    were extracted.
    kind: diagnostic
    id: java/diagnostics/successfully-extracted-files
    tags: successfully-extracted-files
  queryHelp: null
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/ChainedInstanceof.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/ChainedInstanceof.bqrs
  metadata:
    name: Chain of 'instanceof' tests
    description: Long sequences of type tests on a variable are difficult to maintain.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/chained-type-tests
    tags: |-
      maintainability
             language-features
  queryHelp: "# Chain of 'instanceof' tests\nLong sequences of type tests are often\
    \ used to dispatch control to different branches of the code based on the type\
    \ of a variable, as shown in the example below. They are often used to simulate\
    \ pattern-matching in languages that do not support it. Whilst this works as a\
    \ dispatch method, there are a number of problems:\n\n* They are difficult to\
    \ maintain. It is easy to add a new subtype and forget to modify all of the type\
    \ test sequences throughout your code.\n* They introduce unwanted dependencies\
    \ on concrete classes. Code cannot be written only in terms of an interface but\
    \ must instead be written considering all of the different special cases.\n* They\
    \ can be error-prone - it is easy to test for a base type before a derived type,\
    \ resulting in a failure to execute the code handling the derived type.\n\n##\
    \ Recommendation\nThere are a number of different possible solutions to this problem:\n\
    \n* **Polymorphism**. You can add a virtual method to the type hierarchy and put\
    \ the segments of code to be called in the relevant override for each concrete\
    \ class. This is a good solution when: (a) you can change the type hierarchy and\
    \ (b) the operation being implemented is core functionality that the types should\
    \ implement. If you implement this solution then you must be careful not to introduce\
    \ unwanted dependencies. If the operation depends on entities that themselves\
    \ depend on the type hierarchy, then you cannot move the operation to the type\
    \ hierarchy without creating a dependency cycle.\n* **The visitor pattern**. You\
    \ can introduce a visitor interface containing a visit method for each type in\
    \ the type hierarchy, and add an `accept` method to each type in the hierarchy\
    \ that takes a visitor as its parameter. The `accept` method calls the visit method\
    \ of the visitor on `this`. Concrete visitors then implement the interface and\
    \ process each specific type as necessary. This is a good solution when: (a) you\
    \ can change the type hierarchy and (b) the type hierarchy should not know about\
    \ the operation being implemented (either to avoid dependency or because it is\
    \ not core functionality for the types in the hierarchy). It is also useful when\
    \ you want to provide multiple operations with the same structure, on the same\
    \ set of types, and you want the types themselves to control the way that the\
    \ operation is structured. For example, \"visit this tree using an in-order walk\
    \ and apply the operation to each node\". The basic visitor pattern is not suitable\
    \ for all situations because it is cyclically-dependent, and the infrastructure\
    \ involved is comparatively heavyweight.\n* **Reflection**. You can look up one\
    \ of a set of overloaded methods based on the type of one of the method parameters\
    \ and invoke the method manually. This results in a loss of type safety and is\
    \ rather untidy, but there are times when it is the best solution. In particular,\
    \ reflection is useful when you cannot change the type hierarchy, for example,\
    \ because it is third-party code.\n\n## Example\nThe following example demonstrates\
    \ the use \"Polymorphism\" and \"The visitor pattern\". More details on reflection\
    \ can be found in \\[Flanagan\\].\n\n\n```java\nimport java.util.*;\n\npublic\
    \ class ChainedInstanceof {\n\tpublic static void main(String[] args) {\n\t\t\
    // BAD: example of a sequence of type tests\n\t\tList<BadAnimal> badAnimals =\
    \ new ArrayList<BadAnimal>();\n\t\tbadAnimals.add(new BadCat());\n\t\tbadAnimals.add(new\
    \ BadDog());\n\t\tfor(BadAnimal a: badAnimals) {\n\t\t\tif(a instanceof BadCat)\
    \      System.out.println(\"Miaow!\");\n\t\t\telse if(a instanceof BadDog) System.out.println(\"\
    Woof!\");\n\t\t\telse                         throw new RuntimeException(\"Oops!\"\
    );\n\t\t}\n\n\t\t// GOOD: solution using polymorphism\n\t\tList<PolymorphicAnimal>\
    \ polymorphicAnimals = new ArrayList<PolymorphicAnimal>();\n\t\tpolymorphicAnimals.add(new\
    \ PolymorphicCat());\n\t\tpolymorphicAnimals.add(new PolymorphicDog());\n\t\t\
    for(PolymorphicAnimal a: polymorphicAnimals) a.speak();\n\n\t\t// GOOD: solution\
    \ using the visitor pattern\n\t\tList<VisitableAnimal> visitableAnimals = new\
    \ ArrayList<VisitableAnimal>();\n\t\tvisitableAnimals.add(new VisitableCat());\n\
    \t\tvisitableAnimals.add(new VisitableDog());\n\t\tfor(VisitableAnimal a: visitableAnimals)\
    \ a.accept(new SpeakVisitor());\n\t}\n\n\t//#################### TYPES FOR BAD\
    \ EXAMPLE ####################\n\n\tprivate interface BadAnimal {}\n\tprivate\
    \ static class BadCat implements BadAnimal {}\n\tprivate static class BadDog implements\
    \ BadAnimal {}\n\n\t//#################### TYPES FOR POLYMORPHIC EXAMPLE ####################\n\
    \n\tprivate interface PolymorphicAnimal {\n\t\tvoid speak();\n\t}\n\tprivate static\
    \ class PolymorphicCat implements PolymorphicAnimal {\n\t\tpublic void speak()\
    \ { System.out.println(\"Miaow!\"); }\n\t}\n\tprivate static class PolymorphicDog\
    \ implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"\
    Woof!\"); }\n\t}\n\n\t//#################### TYPES FOR VISITOR EXAMPLE ####################\n\
    \n\tprivate interface Visitor {\n\t\tvoid visit(VisitableCat c);\n\t\tvoid visit(VisitableDog\
    \ d);\n\t}\n\tprivate static class SpeakVisitor implements Visitor {\n\t\tpublic\
    \ void visit(VisitableCat c) { System.out.println(\"Miaow!\"); }\n\t\tpublic void\
    \ visit(VisitableDog d) { System.out.println(\"Woof!\"); }\n\t}\n\tprivate interface\
    \ VisitableAnimal {\n\t\tvoid accept(Visitor v);\n\t}\n\tprivate static class\
    \ VisitableCat implements VisitableAnimal {\n\t\tpublic void accept(Visitor v)\
    \ { v.visit(this); }\n\t}\n\tprivate static class VisitableDog implements VisitableAnimal\
    \ {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n}\n\n```\n\n##\
    \ References\n* D. Flanagan, *Java in a Nutshell: A Desktop Quick Reference*.\
    \ O'Reilly Media, 1997.\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design\
    \ patterns: elements of reusable object-oriented software*. Addison-Wesley Longman\
    \ Publishing Co., Inc. Boston, MA, 1995.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/IterableIterator.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/IterableIterator.bqrs
  metadata:
    name: Iterator implementing Iterable
    description: |-
      An 'Iterator' that also implements 'Iterable' by returning itself as its 'Iterator'
                    does not support multiple traversals. This can lead to unexpected behavior when
                    it is viewed as an 'Iterable'.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/iterator-implements-iterable
    tags: |-
      correctness
             reliability
  queryHelp: |
    # Iterator implementing Iterable
    Java has two interfaces for dealing with iteration, `Iterable<T>` and `Iterator<T>`. An `Iterable<T>` represents a sequence of elements that can be traversed, and an `Iterator<T>` represents the **state** of an ongoing traversal. As an example, all the `Collection<T>` classes in the Java standard library implement `Iterable<T>`. Comparing this to a traditional `for` loop that increments an integer index and iterates over the elements of an array, then the `Iterable<T>` object corresponds to the array, whereas the `Iterator<T>` object corresponds to the index variable.

    Implementations of `Iterable<T>` are generally expected to support multiple traversals of the element sequence they represent, although there can be exceptions if the underlying data somehow makes this undesirable, see for example `DirectoryStream<T>`. If an implementation of `Iterable<T>` does not support multiple iterations, then its `iterator()` method should throw an exception on its second and subsequent calls. This makes bugs easier to find if such an `Iterable<T>` is used more than once, for example in two different for-each loops.


    ## Recommendation
    When working with custom implementations of `Iterator<T>` it is easy to add `implements Iterable<T>` and a simple `return this;` implementation of `iterator()` to support the for-each syntax. This can, however, hide subtle bugs and is therefore not recommended. It is better to separate the two and use a main representation that only implements `Iterable<T>` without containing any iteration state. This object can then return a short-lived `Iterator<T>` each time it needs to be traversed.

    If this refactoring is undesirable for some reason, then the `iterator()` method should at the very least throw an exception if called more than once.


    ## Example
    The following example does not distinguish the iterable from its iterator, and therefore causes the second loop to terminate immediately without any effect.


    ```java
    class ElemIterator implements Iterator<MyElem>, Iterable<MyElem> {
      private MyElem[] data;
      private idx = 0;

      public boolean hasNext() {
        return idx < data.length;
      }
      public MyElem next() {
        return data[idx++];
      }
      public Iterator<MyElem> iterator() {
        return this;
      }
      // ...
    }

    void useMySequence(Iterable<MyElem> s) {
      // do some work by traversing the sequence
      for (MyElem e : s) {
        // ...
      }
      // do some more work by traversing it again
      for (MyElem e : s) {
        // ...
      }
    }

    ```
    The best solution is a refactoring along the following lines where `Iterable` classes are used to pass around references to data. This allows the `Iterator` instances to be short-lived and avoids the sharing of iteration state.


    ```java
    class ElemSequence implements Iterable<MyElem> {
      private MyElem[] data;

      public Iterator<MyElem> iterator() {
        return new Iterator<MyElem>() {
          private idx = 0;
          public boolean hasNext() {
            return idx < data.length;
          }
          public MyElem next() {
            return data[idx++];
          }
        };
      }
      // ...
    }

    ```
    If a refactoring, as described above, is too cumbersome or is otherwise undesirable, then a guard can be inserted, as shown below. Using a guard ensures that multiple iteration fails early, making it easier to find any related bugs. This solution is less ideal than the refactoring above, but nevertheless an improvement over the original.


    ```java
    class ElemIterator implements Iterator<MyElem>, Iterable<MyElem> {
      private MyElem[] data;
      private idx = 0;
      private boolean usedAsIterable = false;

      public boolean hasNext() {
        return idx < data.length;
      }
      public MyElem next() {
        return data[idx++];
      }
      public Iterator<MyElem> iterator() {
        if (usedAsIterable || idx > 0)
          throw new IllegalStateException();
        usedAsIterable = true;
        return this;
      }
      // ...
    }

    ```

    ## References
    * Java Language Specification: [The enhanced for statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.2).
    * Java API Specification: [Interface Iterable&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Iterable.html), [Interface Iterator&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html), [Interface DirectoryStream&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/DirectoryStream.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/OverridePackagePrivate.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/OverridePackagePrivate.bqrs
  metadata:
    name: Confusing non-overriding of package-private method
    description: |-
      A method that appears to override another method but does not, because the
                    declaring classes are in different packages, is potentially confusing.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/non-overriding-package-private
    tags: |-
      maintainability
             readability
  queryHelp: "# Confusing non-overriding of package-private method\nIf a method is\
    \ declared with default access (that is, not private, protected, nor public),\
    \ it can only be overridden by methods in the same package. If a method of the\
    \ same signature is defined in a subclass in a different package, it is a completely\
    \ separate method and no overriding occurs.\n\nCode like this can be confusing\
    \ for other programmers, who have to understand that there is no overriding relation,\
    \ check that the original programmer did not intend one method to override the\
    \ other, and avoid mixing up the two methods by accident.\n\n\n## Recommendation\n\
    In cases where there is intentionally no overriding, the best solution is to rename\
    \ one or both of the methods to clarify their different purposes.\n\nIf one method\
    \ is supposed to override another method that is declared with default access\
    \ in another package, the access of the method must be changed to `public` or\
    \ `protected`. Alternatively, the classes must be moved to the same package.\n\
    \n\n## Example\nIn the following example, `PhotoResizerWidget.width` does not\
    \ override `Widget.width` because one method is in package `gui` and one method\
    \ is in package `gui.extras`.\n\n\n```java\n// File 1\npackage gui;\n\nabstract\
    \ class Widget\n{\n    // ...\n\n    // Return the width (in pixels) of this widget\n\
    \    int width() {\n        // ...\n    }\n\n    // ...\n}\n\n// File 2\npackage\
    \ gui.extras;\n\nclass PhotoResizerWidget extends Widget\n{\n    // ...\n \n \
    \   // Return the new width (of the photo when resized)\n    public int width()\
    \ {\n        // ...\n    }\n   \n    // ...\n}\n```\nAssuming that no overriding\
    \ is intentional, one or both of the methods should be renamed. For example, `PhotoResizerWidget.width`\
    \ would be better named `PhotoResizerWidget.newPhotoWidth`.\n\n\n## References\n\
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [8.4.8.1 Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/TypeVarExtendsFinalType.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/TypeVarExtendsFinalType.bqrs
  metadata:
    name: Type bound extends a final class
    description: |-
      If 'C' is a final class, a type bound such as '? extends C'
                    is confusing because it implies that 'C' has subclasses, but
                    a final class has no subclasses.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/type-bound-extends-final
    tags: |-
      maintainability
             readability
             types
  queryHelp: "# Type bound extends a final class\nA type wildcard with an `extends`\
    \ clause (for example `?&nbsp;extends&nbsp;String`) implicitly suggests that a\
    \ type (in this case `String`) has subclasses. If the type in the `extends` clause\
    \ is final, the code is confusing because a final class cannot have any subclasses.\
    \ The only type that satisfies `?&nbsp;extends&nbsp;String` is `String`.\n\n\n\
    ## Recommendation\nTo make the code more readable, omit the wildcard to leave\
    \ just the final type.\n\n\n## Example\nIn the following example, a wildcard is\
    \ used to refer to any type that is a subclass of `String`.\n\n\n```java\nclass\
    \ Printer\n{\n\tvoid print(List<? extends String> strings) {  // Unnecessary wildcard\n\
    \t\tfor (String s : strings)\n\t\t\tSystem.out.println(s);\n\t}\n}\n```\nHowever,\
    \ because `String` is declared `final`, it does not have any subclasses. Therefore,\
    \ it is clearer to replace `?&nbsp;extends&nbsp;String` with `String`.\n\n\n##\
    \ References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [4.5.1 Type Arguments of Parameterized Types ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1),\
    \ [8.1.1.2 final Classes](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.1.2).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/TypeVariableHidesType.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/TypeVariableHidesType.bqrs
  metadata:
    name: Type variable hides another type
    description: |-
      A type variable with the same name as another type that is in scope can cause
                    the two types to be confused.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/type-variable-hides-type
    tags: |-
      reliability
             readability
             types
  queryHelp: "# Type variable hides another type\nType shadowing occurs if two types\
    \ have the same name but one is defined within the scope of the other. This can\
    \ arise if you introduce a type variable with the same name as an imported class.\n\
    \nType shadowing may cause the two types to be confused, which can lead to various\
    \ problems.\n\n\n## Recommendation\nName the type variable so that its name does\
    \ not clash with the imported class.\n\n\n## Example\nIn the following example,\
    \ the type `java.util.Map.Entry` is imported at the top of the file, but the class\
    \ `Mapping` is defined with two type variables, `Key` and `Entry`. Uses of `Entry`\
    \ within the `Mapping` class refer to the type variable, and not the imported\
    \ interface. The type variable therefore shadows `Map.Entry`.\n\n\n```java\nimport\
    \ java.util.Map;\nimport java.util.Map.Entry;\n\nclass Mapping<Key, Entry>  //\
    \ The type variable 'Entry' shadows the imported interface 'Entry'.\n{\n\t// ...\n\
    }\n```\nTo fix the code, the type variable `Entry` on line 4 should be renamed.\n\
    \n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [6.4 Shadowing and Obscuring](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/UselessNullCheck.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/UselessNullCheck.bqrs
  metadata:
    name: Useless null check
    description: |-
      Checking whether an expression is null when that expression cannot
                    possibly be null is useless.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/useless-null-check
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: |
    # Useless null check
    Sometimes you can guarantee that a particular variable will never be null. For example when that variable has just been assigned a newly created object or is the exception caught by a `catch` clause. A null check on such a variable is misleading, and can potentially indicate a logic error.


    ## Recommendation
    Do not check a variable for null if a null value is clearly impossible.


    ## Example
    The following example shows a null check on a newly created object. An object returned by `new` can never be null, so this check is superfluous.


    ```java
    Object o = new Object();
    if (o == null) {
      // this cannot happen!
    }

    ```

    ## References
    * Java Language Specification: [Creation of New Class Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.5), [Execution of try-catch](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.20.1).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/UselessTypeTest.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/UselessTypeTest.bqrs
  metadata:
    name: Useless type test
    description: Testing whether a derived type is an instance of its base type is
      unnecessary.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/useless-type-test
    tags: |-
      maintainability
             language-features
             external/cwe/cwe-561
  queryHelp: "# Useless type test\nIt is always the case that, for any type `B`, an\
    \ instance of a type derived from `B` is also an instance of `B`. There is no\
    \ need to explicitly test that this relationship exists.\n\n\n## Recommendation\n\
    Remove the unnecessary type test to simplify the code.\n\n\n## Example\nThe following\
    \ example shows an unnecessary type test.\n\n\n```java\npublic class UselessTypeTest\
    \ {\n\tprivate static class B {}\n\tprivate static class D extends B {}\n\n\t\
    public static void main(String[] args) {\n\t\tD d = new D();\n\t\tif(d instanceof\
    \ B) {\t// violation\n\t\t\tSystem.out.println(\"Mon dieu, d is a B!\");\n\t\t\
    }\n\t}\n}\n```\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Language Abuse/WrappedIterator.ql
  relativeBqrsPath: codeql/java-queries/Language Abuse/WrappedIterator.bqrs
  metadata:
    name: Iterable wrapping an iterator
    description: |-
      An 'Iterable' that reuses an 'Iterator' instance does not support multiple traversals
                    and can lead to unexpected behavior.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/iterable-wraps-iterator
    tags: |-
      correctness
             reliability
  queryHelp: |
    # Iterable wrapping an iterator
    Java has two interfaces for dealing with iteration, `Iterable<T>` and `Iterator<T>`. An `Iterable<T>` represents a sequence of elements that can be traversed, and an `Iterator<T>` represents the **state** of an ongoing traversal. As an example, all the `Collection<T>` classes in the Java standard library implement `Iterable<T>`. Comparing this to a traditional `for` loop that increments an integer index and iterates over the elements of an array, then the `Iterable<T>` object corresponds to the array, whereas the `Iterator<T>` object corresponds to the index variable.

    Implementations of `Iterable<T>` are generally expected to support multiple traversals of the element sequence they represent, although there can be exceptions if the underlying data somehow makes this undesirable, see for example `DirectoryStream<T>`. If an implementation of `Iterable<T>` does not support multiple iterations, then its `iterator()` method should throw an exception on its second and subsequent calls. This makes bugs easier to find if such an `Iterable<T>` is used more than once, for example in two different for-each loops.


    ## Recommendation
    When writing the `iterator()` method in an `Iterable<T>` then it is important to make sure that each call will result in a fresh `Iterator<T>` instance containing all the necessary state for keeping track of the iteration. If the iterator is stored in the `Iterable<T>`, or somehow refers to iteration state stored in the `Iterable<T>`, then subsequent calls to `iterator()` can result in loops that only traverse a subset of the elements or have no effect at all.


    ## Example
    The following example returns the same iterator on every call, and therefore causes the second loop to terminate immediately without any effect.


    ```java
    class MySequence implements Iterable<MyElem> {
      // ... some reference to data
      final Iterator<MyElem> it = data.iterator();
      // Wrong: reused iterator
      public Iterator<MyElem> iterator() {
        return it;
      }
    }

    void useMySequence(MySequence s) {
      // do some work by traversing the sequence
      for (MyElem e : s) {
        // ...
      }
      // do some more work by traversing it again
      for (MyElem e : s) {
        // ...
      }
    }

    ```
    This second example returns a newly created iterator each time, but still relies on iteration state stored in the surrounding class, and therefore also causes the second loop to terminate immediately.


    ```java
    class MySequence implements Iterable<MyElem> {
      // ... some reference to data
      final Iterator<MyElem> it = data.iterator();
      // Wrong: iteration state outside returned iterator
      public Iterator<MyElem> iterator() {
        return new Iterator<MyElem>() {
          public boolean hasNext() {
            return it.hasNext();
          }
          public MyElem next() {
            return transformElem(it.next());
          }
          public void remove() {
            // ...
          }
        };
      }
    }

    ```
    The code should instead be written like this, such that each call to `iterator()` correctly gives a fresh iterator that starts at the beginning.


    ```java
    class MySequence implements Iterable<MyElem> {
      // ... some reference to data
      public Iterator<MyElem> iterator() {
        return new Iterator<MyElem>() {
          // Correct: iteration state inside returned iterator
          final Iterator<MyElem> it = data.iterator();
          public boolean hasNext() {
            return it.hasNext();
          }
          public MyElem next() {
            return transformElem(it.next());
          }
          public void remove() {
            // ...
          }
        };
      }
    }

    ```

    ## References
    * Java Language Specification: [The enhanced for statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.2).
    * Java API Specification: [Interface Iterable&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Iterable.html), [Interface Iterator&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html), [Interface DirectoryStream&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/DirectoryStream.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/BadAbsOfRandom.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/BadAbsOfRandom.bqrs
  metadata:
    name: Incorrect absolute value of random number
    description: |-
      Calling 'Math.abs' to find the absolute value of a randomly generated integer is not
                    guaranteed to return a non-negative integer.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/abs-of-random
    tags: |-
      reliability
             maintainability
  queryHelp: |
    # Incorrect absolute value of random number
    Using `Math.abs` on the result of a call to `Random.nextInt()` (or `Random.nextLong()`) is not guaranteed to return a non-negative number. `Random.nextInt()` can return `Integer.MIN_VALUE`, which when passed to `Math.abs` results in the same value, `Integer.MIN_VALUE`. (Because of the two's-complement representation of integers in Java, the positive equivalent of `Integer.MIN_VALUE` cannot be represented in the same number of bits.) The case for `Random.nextLong()` is similar.


    ## Recommendation
    If a non-negative random integer is required, use `Random.nextInt(int)` instead, and use `Integer.MAX_VALUE` as its parameter. The values that might be returned do not include `Integer.MAX_VALUE` itself, but this solution is likely to be sufficient for most purposes.

    Another solution is to increment the value of `Random.nextInt()` by one, if it is negative, before passing the result to `Math.abs`. This solution has the advantage that `0` has the same probability as other numbers.


    ## Example
    In the following example, `mayBeNegativeInt` is negative if `nextInt` returns `Integer.MIN_VALUE`. The example shows how using the two solutions described above means that `positiveInt` is always assigned a positive number.


    ```java
    public static void main(String args[]) {
        Random r = new Random();

        // BAD: 'mayBeNegativeInt' is negative if
        // 'nextInt()' returns 'Integer.MIN_VALUE'.
        int mayBeNegativeInt = Math.abs(r.nextInt());

        // GOOD: 'nonNegativeInt' is always a value between 0 (inclusive)
        // and Integer.MAX_VALUE (exclusive).
        int nonNegativeInt = r.nextInt(Integer.MAX_VALUE);

        // GOOD: When 'nextInt' returns a negative number increment the returned value.
        int nextInt = r.nextInt();
        if(nextInt < 0)
            nextInt++;
        int nonNegativeInt = Math.abs(nextInt);
    }

    ```

    ## References
    * Java API Specification: [Math.abs(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(int)), [Math.abs(long)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(long)), [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).
    * Java Language Specification: [4.2.1 Integral Types and Values](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.2.1).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/ConstantExpAppearsNonConstant.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/ConstantExpAppearsNonConstant.bqrs
  metadata:
    name: Expression always evaluates to the same value
    description: "An expression that always evaluates to the same value, but which\
      \ has a non-constant subexpression, indicates a mistake."
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/evaluation-to-constant
    tags: |-
      maintainability
             useless-code
  queryHelp: "# Expression always evaluates to the same value\nSome expressions always\
    \ evaluate to the same result, no matter what their subexpressions are:\n\n* `x\
    \ * 0` always evaluates to `0`.\n* `x % 1` always evaluates to `0`.\n* `x & 0`\
    \ always evaluates to `0`.\n* `x || true` always evaluates to `true`.\n* `x &&\
    \ false` always evaluates to `false`.\nWhenever `x` is not constant, such an expression\
    \ is often a mistake.\n\n\n## Recommendation\nIf the expression is supposed to\
    \ evaluate to the same result every time it is executed, consider replacing the\
    \ entire expression with its result.\n\n\n## Example\nThe following method tries\
    \ to determine whether `x` is even by checking whether `x % 1 == 0`.\n\n\n```java\n\
    public boolean isEven(int x) {\n\treturn x % 1 == 0; //Does not work\n}\n\n```\n\
    However, `x % 1 == 0` is always true when `x` is an integer. The correct check\
    \ is `x % 2 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n    return x\
    \ % 2 == 0; //Does work\n}\n\n```\n\n## References\n* Java Language Specification:\
    \ [Multiplication Operator \\*](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.1),\
    \ [Remainder Operator %](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.3),\
    \ [Integer Bitwise Operators &amp;, ^, and |](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.1),\
    \ [Conditional-And Operator &amp;&amp;](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.23)\
    \ and [Conditional-Or Operator ||](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.24).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/InformationLoss.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/InformationLoss.bqrs
  metadata:
    name: Implicit narrowing conversion in compound assignment
    description: |-
      Compound assignment statements (for example 'intvar += longvar') that implicitly
                    cast a value of a wider type to a narrower type may result in information loss and
                    numeric errors such as overflows.
    kind: problem
    problem.severity: warning
    security-severity: 8.1
    precision: very-high
    id: java/implicit-cast-in-compound-assignment
    tags: |-
      reliability
             security
             external/cwe/cwe-190
             external/cwe/cwe-192
             external/cwe/cwe-197
             external/cwe/cwe-681
  queryHelp: |
    # Implicit narrowing conversion in compound assignment
    Compound assignment statements of the form `x += y` or `x *= y` perform an implicit narrowing conversion if the type of `x` is narrower than the type of `y`. For example, `x += y` is equivalent to `x = (T)(x + y)`, where `T` is the type of `x`. This can result in information loss and numeric errors such as overflows.


    ## Recommendation
    Ensure that the type of the left-hand side of the compound assignment statement is at least as wide as the type of the right-hand side.


    ## Example
    If `x` is of type `short` and `y` is of type `int`, the expression `x + y` is of type `int`. However, the expression `x += y` is equivalent to `x = (short) (x + y)`. The expression `x + y` is cast to the type of the left-hand side of the assignment: `short`, possibly leading to information loss.

    To avoid implicitly narrowing the type of `x + y`, change the type of `x` to `int`. Then the types of `x` and `x + y` are both `int` and there is no need for an implicit cast.


    ## References
    * J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 9. Addison-Wesley, 2005.
    * Java Language Specification: [Compound Assignment Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.26.2), [Narrowing Primitive Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.3).
    * SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).
    * Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).
    * Common Weakness Enumeration: [CWE-192](https://cwe.mitre.org/data/definitions/192.html).
    * Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).
    * Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/IntMultToLong.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/IntMultToLong.bqrs
  metadata:
    name: Result of multiplication cast to wider type
    description: |-
      Casting the result of a multiplication to a wider type instead of casting
                    before the multiplication may cause overflow.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/integer-multiplication-cast-to-long
    tags: |-
      reliability
             correctness
             types
             external/cwe/cwe-190
             external/cwe/cwe-192
             external/cwe/cwe-197
             external/cwe/cwe-681
  queryHelp: |
    # Result of multiplication cast to wider type
    An integer multiplication that is assigned to a variable of type `long` or returned from a method with return type `long` may cause unexpected arithmetic overflow.


    ## Recommendation
    Casting to type `long` before multiplying reduces the risk of arithmetic overflow.


    ## Example
    In the following example, the multiplication expression assigned to `j` causes overflow and results in the value `-1651507200` instead of `4000000000000000000`.


    ```java
    int i = 2000000000;
    long j = i*i; // causes overflow
    ```
    In the following example, the assignment to `k` correctly avoids overflow by casting one of the operands to type `long`.


    ```java
    int i = 2000000000;
    long k = i*(long)i; // avoids overflow
    ```

    ## References
    * J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 3. Addison-Wesley, 2005.
    * Java Language Specification: [Multiplication Operator](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.1).
    * SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).
    * Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).
    * Common Weakness Enumeration: [CWE-192](https://cwe.mitre.org/data/definitions/192.html).
    * Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).
    * Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/LShiftLargerThanTypeWidth.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/LShiftLargerThanTypeWidth.bqrs
  metadata:
    name: Left shift by more than the type width
    description: Left-shifting an integer by more than its type width indicates a
      mistake.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/lshift-larger-than-type-width
    tags: correctness
  queryHelp: |
    # Left shift by more than the type width
    The maximum shift distance used for left-shift operations is determined by the promoted type of its left-hand side. When the promoted type is `int` only the lowest 5 bits of the right-hand side are used as the shift distance. When the promoted type is `long` the lowest 6 bits of the right-hand side are used.


    ## Recommendation
    Restrict the amount that you shift any `int` to the range 0-31, or cast it to `long` before applying the left shift.


    ## Example
    The following line tries to left-shift an `int` by 32 bits.


    ```java
    long longVal = intVal << 32; // BAD
    ```
    However, left-shifting an `int` by 32 bits is equivalent to left-shifting it by 0 bits, that is, no shift is applied. Instead the value should be cast to `long` before the shift is applied. Then the left-shift of 32 bits will work.


    ```java
    long longVal = ((long)intVal) << 32; // GOOD
    ```

    ## References
    * Java Language Specification: [Shift Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.19).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/MultiplyRemainder.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/MultiplyRemainder.bqrs
  metadata:
    name: Multiplication of remainder
    description: |-
      Using the remainder operator with the multiplication operator without adding
                    parentheses to clarify precedence may cause confusion.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/multiplication-of-remainder
    tags: |-
      maintainability
             correctness
  queryHelp: |
    # Multiplication of remainder
    Using the remainder operator `%` with the multiplication operator may not give you the result that you expect unless you use parentheses. This is because the remainder operator has the same precedence as the multiplication operator, and the operators are left-associative.


    ## Recommendation
    When you use the remainder operator with the multiplication operator, ensure that the expression is evaluated as you expect. If necessary, add parentheses.


    ## Example
    Consider a time in milliseconds, represented by `t`. To calculate the number of milliseconds remaining after the time has been converted to whole minutes, you might write `t % 60 * 1000`. However, this is equal to `(t % 60) * 1000`, which gives the wrong result. Instead, the expression should be `t % (60 * 1000)`.


    ## References
    * J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.
    * The Java Tutorials: [Operators](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/RandomUsedOnce.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/RandomUsedOnce.bqrs
  metadata:
    name: Random used only once
    description: |-
      Creating an instance of 'Random' for each pseudo-random number required does not
                    guarantee an evenly distributed sequence of random numbers.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/random-used-once
    tags: |-
      reliability
             maintainability
             external/cwe/cwe-335
  queryHelp: "# Random used only once\nA program that uses `java.util.Random` to generate\
    \ a sequence of pseudo-random numbers *should not* create a new instance of `Random`\
    \ every time a new pseudo-random number is required (for example, `new Random().nextInt()`).\n\
    \nAccording to the Java API Specification:\n\n> If two instances of `Random` are\
    \ created with the same seed, and the same sequence of method calls is made for\
    \ each, they will generate and return identical sequences of numbers.\n\nThe sequence\
    \ of pseudo-random numbers returned by these calls depends only on the value of\
    \ the seed. If you construct a new `Random` object each time a pseudo-random number\
    \ is needed, this does not generate a good distribution of pseudo-random numbers,\
    \ even though the parameterless `Random()` constructor tries to initialize itself\
    \ with a unique seed.\n\n\n## Recommendation\nCreate a `Random` object once and\
    \ use the same instance when generating sequences of pseudo-random numbers (by\
    \ calling `nextInt`, `nextLong`, and so on).\n\n\n## Example\nIn the following\
    \ example, generating a series of pseudo-random numbers, such as `notReallyRandom`\
    \ and `notReallyRandom2`, by creating a new instance of `Random` each time is\
    \ unlikely to result in a good distribution of pseudo-random numbers. In contrast,\
    \ generating a series of pseudo-random numbers, such as `random1` and `random2`,\
    \ by calling `nextInt` each time *is* likely to result in a good distribution.\
    \ This is because the numbers are based on only one `Random` object.\n\n\n```java\n\
    public static void main(String args[]) {\n\t// BAD: A new 'Random' object is created\
    \ every time\n\t// a pseudo-random integer is required.\n\tint notReallyRandom\
    \ = new Random().nextInt();\n\tint notReallyRandom2 = new Random().nextInt();\n\
    \t\n\t// GOOD: The same 'Random' object is used to generate \n\t// two pseudo-random\
    \ integers.\n\tRandom r = new Random();\n\tint random1 = r.nextInt();\n\tint random2\
    \ = r.nextInt();\n}\n```\n\n## References\n* Java API Specification: [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n\
    * Common Weakness Enumeration: [CWE-335](https://cwe.mitre.org/data/definitions/335.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Arithmetic/WhitespaceContradictsPrecedence.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Arithmetic/WhitespaceContradictsPrecedence.bqrs
  metadata:
    name: Whitespace contradicts operator precedence
    description: |-
      Nested expressions where the formatting contradicts the grouping enforced by operator precedence
                    are difficult to read and may even indicate a bug.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/whitespace-contradicts-precedence
    tags: |-
      maintainability
             readability
             external/cwe/cwe-783
  queryHelp: |
    # Whitespace contradicts operator precedence
    Nested expressions where the spacing around operators suggests a different grouping than that imposed by the Java operator precedence rules are problematic: they could indicate a bug where the author of the code misunderstood the precedence rules. Even if there is no a bug, the spacing could be confusing to people who read the code.


    ## Recommendation
    Make sure that the spacing around operators reflects operator precedence, or use parentheses to clarify grouping.


    ## Example
    Consider the following piece of code for allocating an array:

    ```

        int[] buf = new int[capacity + capacity>>1];

    ```
    Here, the spacing around `+` and `>>` suggests the grouping `capacity + (capacity>>1)`, that is, the allocated array should be 50% larger than the given capacity.

    In fact, however, `+` has higher precedence than `>>`, so this code allocates an array of size `(capacity + capacity) >> 1`, which is the same as `capacity`.


    ## References
    * J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.
    * Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Cloning/MissingCallToSuperClone.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Cloning/MissingCallToSuperClone.bqrs
  metadata:
    name: Missing super clone
    description: |-
      A 'clone' method that is overridden in a subclass, and that does not itself call
                    'super.clone', causes calls to the subclass's 'clone' method to return an object of
                    the wrong type.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/missing-call-to-super-clone
    tags: |-
      reliability
             maintainability
             external/cwe/cwe-580
  queryHelp: "# Missing super clone\nA `clone` method that is overridden in a subclass\
    \ should call `super.clone`. Not doing so causes the subclass `clone` to return\
    \ an object of the wrong type, which violates the contract for `Cloneable`.\n\n\
    The Java API Specification states that, for an object `x`, the general intent\
    \ of the `clone` method is for it to satisfy the following three properties:\n\
    \n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass()\
    \ == x.getClass()` (the cloned object is the same type as the source object)\n\
    * `x.clone().equals(x)` (the cloned object has the same 'contents' as the source\
    \ object)\nFor the cloned object to be of the same type as the source object,\
    \ non-final classes must call `super.clone` and that call must eventually reach\
    \ `Object.clone`, which creates an instance of the right type. If it were to create\
    \ a new object using a constructor, a subclass that does not implement the `clone`\
    \ method returns an object of the wrong type. In addition, all of the class's\
    \ supertypes that also override `clone` must call `super.clone`. Otherwise, it\
    \ never reaches `Object.clone` and creates an object of the incorrect type.\n\n\
    However, as `Object.clone` only does a shallow copy of the fields of an object,\
    \ any `Cloneable` objects that have a \"deep structure\" (for example, objects\
    \ that use an array or `Collection`) must take the clone that results from the\
    \ call to `super.clone` and assign explicitly created copies of the structure\
    \ to the clone's fields. This means that the cloned instance does not share its\
    \ internal state with the source object. If it *did* share its internal state,\
    \ any changes made in the cloned object would also affect the internal state of\
    \ the source object, probably causing unintended behavior.\n\nOne added complication\
    \ is that `clone` cannot modify values in final fields, which would be already\
    \ set by the call to `super.clone`. Some fields must be made non-final to correctly\
    \ implement the `clone` method.\n\n\n## Recommendation\nEvery clone method should\
    \ always use `super.clone` to construct the cloned object. This ensures that the\
    \ cloned object is ultimately constructed by `Object.clone`, which uses reflection\
    \ to ensure that an object of the correct runtime type is created.\n\n\n## Example\n\
    In the following example, the attempt to clone `WrongEmployee` fails because `super.clone`\
    \ is implemented incorrectly in its superclass `WrongPerson`.\n\n\n```java\nclass\
    \ WrongPerson implements Cloneable {\n    private String name;\n    public WrongPerson(String\
    \ name) { this.name = name; }\n    // BAD: 'clone' does not call 'super.clone'.\n\
    \    public WrongPerson clone() {\n        return new WrongPerson(this.name);\n\
    \    }\n}\n\nclass WrongEmployee extends WrongPerson {\n    public WrongEmployee(String\
    \ name) {\n        super(name);\n    }\n    // ALMOST RIGHT: 'clone' correctly\
    \ calls 'super.clone',\n    // but 'super.clone' is implemented incorrectly.\n\
    \    public WrongEmployee clone() {\n    \treturn (WrongEmployee)super.clone();\n\
    \    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[]\
    \ args) {\n        WrongEmployee e = new WrongEmployee(\"John Doe\");\n      \
    \  WrongEmployee eclone = e.clone(); // Causes a ClassCastException\n    }\n}\n\
    \n```\nHowever, in the following modified example, the attempt to clone `Employee`\
    \ succeeds because `super.clone` is implemented correctly in its superclass `Person`.\n\
    \n\n```java\nclass Person implements Cloneable {\n    private String name;\n \
    \   public Person(String name) { this.name = name; }\n    // GOOD: 'clone' correctly\
    \ calls 'super.clone'\n    public Person clone() {\n        try {\n          \
    \  return (Person)super.clone();\n        } catch (CloneNotSupportedException\
    \ e) {\n            throw new AssertionError(\"Should never happen\");\n     \
    \   }\n    }\n}\n\nclass Employee extends Person {\n    public Employee(String\
    \ name) {\n        super(name);\n    }\n    // GOOD: 'clone' correctly calls 'super.clone'\n\
    \    public Employee clone() {\n    \treturn (Employee)super.clone();\n    }\n\
    }\n\npublic class MissingCallToSuperClone {\n    public static void main(String[]\
    \ args) {\n        Employee e2 = new Employee(\"Jane Doe\");\n        Employee\
    \ e2clone = e2.clone(); // 'clone' correctly returns an object of type 'Employee'\n\
    \    }\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*,\
    \ Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n\
    * Common Weakness Enumeration: [CWE-580](https://cwe.mitre.org/data/definitions/580.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Cloning/MissingMethodClone.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Cloning/MissingMethodClone.bqrs
  metadata:
    name: No clone method
    description: |-
      A class that implements 'Cloneable' but does not override the 'clone' method will
                    have undesired behavior.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/missing-clone-method
    tags: |-
      reliability
             maintainability
  queryHelp: |
    # No clone method
    A class that implements `Cloneable` should override `Object.clone`. For non-trivial objects, the `Cloneable` contract requires a deep copy of the object's internal state. A class that does not have a `clone` method indicates that the class is breaking the contract and will have undesired behavior.

    The Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:

    * `x.clone() != x` (the cloned object is a different object instance)
    * `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)
    * `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)
    For the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.

    However, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a "deep structure" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.

    One added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.


    ## Recommendation
    The necessity of creating a deep copy of an object's internal state means that, for most objects, `clone` must be overridden to satisfy the `Cloneable` contract. Implement a `clone` method that properly creates the internal state of the cloned object.

    Notable exceptions to this recommendation are:

    * Classes that contain only primitive types (which will be properly cloned by `Object.clone` as long as its `Cloneable` supertypes all call `super.clone`).
    * Subclasses of `Cloneable` classes that do not introduce new state.

    ## Example
    In the following example, `WrongStack` does not implement `clone`. This means that when `ws1clone` is cloned from `ws1`, the default `clone` implementation is used. This results in operations on the `ws1clone` stack affecting the `ws1` stack.


    ```java
    abstract class AbstractStack implements Cloneable {
        public AbstractStack clone() {
            try {
                return (AbstractStack) super.clone();
            } catch (CloneNotSupportedException e) {
                throw new AssertionError("Should not happen");
            }
        }
    }

    class WrongStack extends AbstractStack {
        private static final int MAX_STACK = 10;
        int[] elements = new int[MAX_STACK];
        int top = -1;

        void push(int newInt) {
            elements[++top] = newInt;
        }
        int pop() {
            return elements[top--];
        }
        // BAD: No 'clone' method to create a copy of the elements.
        // Therefore, the default 'clone' implementation (shallow copy) is used, which
        // is equivalent to:
        //
        //  public WrongStack clone() {
        //      WrongStack cloned = (WrongStack) super.clone();
        //      cloned.elements = elements;  // Both 'this' and 'cloned' now use the same elements.
        //      return cloned;
        //  }
    }

    public class MissingMethodClone {
        public static void main(String[] args) {
            WrongStack ws1 = new WrongStack();              // ws1: {}
            ws1.push(1);                                    // ws1: {1}
            ws1.push(2);                                    // ws1: {1,2}
            WrongStack ws1clone = (WrongStack) ws1.clone(); // ws1clone: {1,2}
            ws1clone.pop();                                 // ws1clone: {1}
            ws1clone.push(3);                               // ws1clone: {1,3}
            System.out.println(ws1.pop());                  // Because ws1 and ws1clone have the same
                                                            // elements, this prints 3 instead of 2
        }
    }



    ```
    In the following modified example, `RightStack` *does* implement `clone`. This means that when `rs1clone` is cloned from `rs1`, operations on the `rs1clone` stack do not affect the `rs1` stack.


    ```java
    abstract class AbstractStack implements Cloneable {
        public AbstractStack clone() {
            try {
                return (AbstractStack) super.clone();
            } catch (CloneNotSupportedException e) {
                throw new AssertionError("Should not happen");
            }
        }
    }

    class RightStack extends AbstractStack {
        private static final int MAX_STACK = 10;
        int[] elements = new int[MAX_STACK];
        int top = -1;

        void push(int newInt) {
            elements[++top] = newInt;
        }
        int pop() {
            return elements[top--];
        }

        // GOOD: 'clone' method to create a copy of the elements.
        public RightStack clone() {
            RightStack cloned = (RightStack) super.clone();
            cloned.elements = elements.clone();  // 'cloned' has its own elements.
            return cloned;
        }
    }

    public class MissingMethodClone {
        public static void main(String[] args) {
            RightStack rs1 = new RightStack();              // rs1: {}
            rs1.push(1);                                    // rs1: {1}
            rs1.push(2);                                    // rs1: {1,2}
            RightStack rs1clone = rs1.clone();              // rs1clone: {1,2}
            rs1clone.pop();                                 // rs1clone: {1}
            rs1clone.push(3);                               // rs1clone: {1,3}
            System.out.println(rs1.pop());                  // Correctly prints 2
        }
    }



    ```

    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.
    * Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Collections/ArrayIndexOutOfBounds.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Collections/ArrayIndexOutOfBounds.bqrs
  metadata:
    name: Array index out of bounds
    description: |-
      Accessing an array with an index that is greater than or equal to the
                    length of the array causes an 'ArrayIndexOutOfBoundsException'.
    kind: problem
    problem.severity: error
    precision: high
    id: java/index-out-of-bounds
    tags: |-
      reliability
             correctness
             exceptions
             external/cwe/cwe-193
  queryHelp: |
    # Array index out of bounds
    When accessing an array element, one must ensure that the index is less than the length of the array. Using an index that is greater than or equal to the array length causes an `ArrayIndexOutOfBoundsException`.


    ## Recommendation
    Ensure that the index is less than the array length.


    ## Example
    The following example causes an `ArrayIndexOutOfBoundsException` in the final loop iteration.


    ```java
    for (int i = 0; i <= a.length; i++) { // BAD
      sum += a[i];
    }

    ```
    The condition should be changed as follows to correctly guard the array access.


    ```java
    for (int i = 0; i < a.length; i++) { // GOOD
      sum += a[i];
    }

    ```

    ## References
    * Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).
    * Common Weakness Enumeration: [CWE-193](https://cwe.mitre.org/data/definitions/193.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Collections/ContainsTypeMismatch.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Collections/ContainsTypeMismatch.bqrs
  metadata:
    name: Type mismatch on container access
    description: |-
      Calling container access methods such as 'Collection.contains'
                    or 'Map.get' with an object of a type that is incompatible with
                    the corresponding container element type is unlikely to return 'true'.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/type-mismatch-access
    tags: |-
      reliability
             correctness
             logic
  queryHelp: "# Type mismatch on container access\nThe `contains` method of the `Collection`\
    \ interface has an argument of type `Object`. Therefore, you can try to check\
    \ if an object of any type is a member of a collection, regardless of the collection's\
    \ element type. However, although you can call `contains` with an argument of\
    \ a different type than that of the collection, it is unlikely that the collection\
    \ actually contains an object of this type.\n\nSimilar considerations apply to\
    \ other container access methods, such as `Map.get`, where the argument may also\
    \ have type `Object`.\n\n\n## Recommendation\nEnsure that you use the correct\
    \ argument with a call to `contains`.\n\n\n## Example\nIn the following example,\
    \ although the argument to `contains` is an integer, the code does not result\
    \ in a type error because the argument does not have to match the type of the\
    \ elements of `list`. However, the argument is unlikely to be found (and the body\
    \ of the `if` statement is therefore not executed), so it is probably a typographical\
    \ error: the argument should be enclosed in quotation marks.\n\n\n```java\nvoid\
    \ m(List<String> list) {\n\tif (list.contains(123)) {  // Call 'contains' with\
    \ non-string argument (without quotation marks)\n\t\t// ...\n\t}\n}\n```\nNote\
    \ that you must take particular care when working with collections over boxed\
    \ types, as illustrated in the following example. The first call to `contains`\
    \ returns `false` because you cannot compare two boxed numeric primitives of different\
    \ types, in this case `Short(1)` (in `set`) and `Integer(1)` (the argument). The\
    \ second call to `contains` returns `true` because you can compare `Short(1)`\
    \ and `Short(1)`.\n\n\n```java\nHashSet<Short> set = new HashSet<Short>();\nshort\
    \ s = 1;\nset.add(s);\n// Following statement prints 'false', because the argument\
    \ is a literal int, which is auto-boxed\n// to an Integer\nSystem.out.println(set.contains(1));\n\
    // Following statement prints 'true', because the argument is a literal int that\
    \ is cast to a short, \n// which is auto-boxed to a Short\nSystem.out.println(set.contains((short)1));\n\
    \n```\n\n## References\n* Java API Specification: [Collection.contains](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html#contains(java.lang.Object)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Collections/IteratorRemoveMayFail.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Collections/IteratorRemoveMayFail.bqrs
  metadata:
    name: Call to Iterator.remove may fail
    description: |-
      Attempting to invoke 'Iterator.remove' on an iterator over a collection that does not
                    support element removal causes a runtime exception.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/iterator-remove-failure
    tags: |-
      reliability
             correctness
             logic
  queryHelp: "# Call to Iterator.remove may fail\nThe `remove` method of the `Iterator`\
    \ interface is an optional operation. It is not supported by iterators on unmodifiable\
    \ collections, or iterators on lists constructed by the `Arrays.asList` method.\
    \ Invoking `remove` on such an iterator will lead to an `UnsupportedOperationException`.\n\
    \n\n## Recommendation\nIf a collection is meant to be modified after construction,\
    \ use a modifiable collection type such as `ArrayList` or `HashSet`.\n\n\n## Example\n\
    In the following example, the constructor `A(Integer...)` initializes the field\
    \ `A.l` to `Arrays.asList(is)`. While the type of lists returned by `Arrays.asList`\
    \ supports element updates through the `set` method, it does not support element\
    \ removal. Hence the call to `iter.remove` on line 20 must fail at runtime.\n\n\
    \n```java\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\
    \npublic class A {\n\tprivate List<Integer> l;\n\t\n\tpublic A(Integer... is)\
    \ {\n\t\tthis.l = Arrays.asList(is);\n\t}\n\t\n\tpublic List<Integer> getList()\
    \ {\n\t\treturn l;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tA a\
    \ = new A(23, 42);\n\t\tfor (Iterator<Integer> iter = a.getList().iterator();\
    \ iter.hasNext();)\n\t\t\tif (iter.next()%2 != 0)\n\t\t\t\titer.remove();\n\t\
    }\n}\n\n```\nTo avoid this failure, copy the list returned by `Arrays.asList`\
    \ into a newly created `ArrayList` like this:\n\n\n```java\nimport java.util.Arrays;\n\
    import java.util.Iterator;\nimport java.util.List;\nimport java.util.ArrayList;\n\
    \npublic class A {\n\tprivate List<Integer> l;\n\t\n\tpublic A(Integer... is)\
    \ {\n\t\tthis.l = new ArrayList<Integer>(Arrays.asList(is));\n\t}\n\t\n\tpublic\
    \ List<Integer> getList() {\n\t\treturn l;\n\t}\n\n\tpublic static void main(String[]\
    \ args) {\n\t\tA a = new A(23, 42);\n\t\tfor (Iterator<Integer> iter = a.getList().iterator();\
    \ iter.hasNext();)\n\t\t\tif (iter.next()%2 != 0)\n\t\t\t\titer.remove();\n\t\
    }\n}\n\n```\n\n## References\n* Mark Needham: [Java: Fooled by java.util.Arrays.asList](https://dzone.com/articles/java-fooled).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Collections/ReadOnlyContainer.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Collections/ReadOnlyContainer.bqrs
  metadata:
    name: Container contents are never initialized
    description: Querying the contents of a collection or map that is never initialized
      is not normally useful.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/empty-container
    tags: |-
      reliability
             maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Container contents are never initialized\nA method that queries the\
    \ contents of a collection or map (such as `containsKey` or `isEmpty`) is invoked\
    \ on an object that is known to be empty. Such method calls do not return interesting\
    \ results, and may indicate missing code or a logic error.\n\n\n## Recommendation\n\
    Either remove the collection/map if it is unnecessary, or ensure that it contains\
    \ the elements it was meant to contain.\n\n\n## Example\nThe following example\
    \ code iterates over an array of objects to determine whether it contains duplicate\
    \ elements. It maintains a collection `seen`, which is intended to contain all\
    \ the elements seen so far in traversing the array. If the current element is\
    \ already contained in that collection then the method returns `true`, indicating\
    \ that a duplicate has been found.\n\nNote, however, that no elements are ever\
    \ actually added to `seen`, so the method always returns `false`.\n\n\n```java\n\
    boolean containsDuplicates(Object[] array) {\n\tjava.util.Set<Object> seen = new\
    \ java.util.HashSet<Object>();\n\tfor (Object o : array) {\n\t\tif (seen.contains(o))\n\
    \t\t\treturn true;\n\t}\n\treturn false;\n}\n```\nTo fix this problem, a statement\
    \ `seen.add(o);` should be added to the end of the loop body to ensure that `seen`\
    \ is correctly maintained.\n\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html),\
    \ [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Collections/RemoveTypeMismatch.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Collections/RemoveTypeMismatch.bqrs
  metadata:
    name: Type mismatch on container modification
    description: |-
      Calling container modification methods such as 'Collection.remove'
                    or 'Map.remove' with an object of a type that is incompatible with
                    the corresponding container element type is unlikely to have any effect.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/type-mismatch-modification
    tags: |-
      reliability
             correctness
             logic
  queryHelp: "# Type mismatch on container modification\nThe `remove` method of the\
    \ `Collection` interface has an argument of type `Object`. Therefore, you can\
    \ try to remove an object of any type from a collection, regardless of the collection's\
    \ element type. However, although you can call `remove` with an argument of a\
    \ different type than that of the collection, it is unlikely that the collection\
    \ actually contains an object of this type.\n\nSimilar considerations apply to\
    \ other container modification methods, such as `Map.remove`, where the argument\
    \ may also have type `Object`.\n\n\n## Recommendation\nEnsure that you use the\
    \ correct argument with a call to `remove`.\n\n\n## Example\nIn the following\
    \ example, although the argument to `contains` is an integer, the code does not\
    \ result in a type error because the argument to `remove` does not have to match\
    \ the type of the elements of `list`. However, the argument is unlikely to be\
    \ found and removed (and the body of the `if` statement is therefore not executed),\
    \ so it is probably a typographical error: the argument should be enclosed in\
    \ quotation marks.\n\n\n```java\nvoid m(List<String> list) {\n\tif (list.remove(123))\
    \ {  // Call 'remove' with non-string argument (without quotation marks)\n\t\t\
    // ...\n\t}\n}\n```\nNote that you must take particular care when working with\
    \ collections over boxed types, as illustrated in the following example. The first\
    \ call to `remove` fails because you cannot compare two boxed numeric primitives\
    \ of different types, in this case `Short(1)` (in `set`) and `Integer(1)` (the\
    \ argument). Therefore, `remove` cannot find the item to remove. The second call\
    \ to `remove` succeeds because you can compare `Short(1)` and `Short(1)`. Therefore,\
    \ `remove` can find the item to remove.\n\n\n```java\nHashSet<Short> set = new\
    \ HashSet<Short>();\nshort s = 1;\nset.add(s);\n// Following statement fails,\
    \ because the argument is a literal int, which is auto-boxed \n// to an Integer\n\
    set.remove(1);\nSystem.out.println(set); // Prints [1]\n// Following statement\
    \ succeeds, because the argument is a literal int that is cast to a short, \n\
    // which is auto-boxed to a Short\nset.remove((short)1);\nSystem.out.println(set);\
    \ // Prints []\n```\n\n## References\n* Java API Specification: [Collection.remove](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html#remove(java.lang.Object)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Collections/WriteOnlyContainer.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Collections/WriteOnlyContainer.bqrs
  metadata:
    name: Container contents are never accessed
    description: A collection or map whose contents are never queried or accessed
      is useless.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/unused-container
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Container contents are never accessed\nIf the contents of a collection\
    \ or map are never accessed in any way, then it is useless and the code that updates\
    \ it is effectively dead code. Often, such objects are left over from an incomplete\
    \ refactoring, or they indicate an underlying logic error.\n\n\n## Recommendation\n\
    Either remove the collection/map if it is genuinely unnecessary, or ensure that\
    \ its elements are accessed.\n\n\n## Example\nIn the following example code, the\
    \ `reachable` method determines whether a node in a tree is reachable from `ROOT`.\
    \ It maintains a set `reachableNodes`, which contains all nodes that have previously\
    \ been found to be reachable. Most likely, this set is meant to act as a cache\
    \ to avoid spurious recomputation, but as it stands the code never checks whether\
    \ any node is contained in the set.\n\n\n```java\nprivate Set<Node> reachableNodes\
    \ = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tboolean reachable;\n\
    \tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\
    \tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\nIn\
    \ the following modification of the above example, `reachable` checks the cache\
    \ to see whether the node has already been considered.\n\n\n```java\nprivate Set<Node>\
    \ reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tif (reachableNodes.contains(n))\n\
    \t\t  return true;\n\t\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable\
    \ = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\
    \t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\n\n## References\n* Java\
    \ API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html),\
    \ [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/CompareIdenticalValues.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/CompareIdenticalValues.bqrs
  metadata:
    name: Comparison of identical values
    description: |-
      If the same expression occurs on both sides of a comparison
                    operator, the operator is redundant, and probably indicates a mistake.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/comparison-of-identical-expressions
    tags: |-
      reliability
             correctness
             logic
  queryHelp: "# Comparison of identical values\nIf two identical expressions are compared\
    \ (that is, checked for equality or inequality), this is typically an indication\
    \ of a mistake, because the Boolean value of the comparison is always the same.\
    \ Often, it indicates that the wrong qualifier has been used on a field access.\n\
    \nAn exception applies to inequality (`!=`) and equality (`==`) tests of a floating\
    \ point variable with itself: the special floating point value `NaN` (\"not-a-number\"\
    ) is the only value that is not considered to be equal to itself. Thus, the test\
    \ `x != x` where `x` is a `float` or `double` variable is equivalent to checking\
    \ whether `x` is `NaN`, and similarly for `x == x`.\n\n\n## Recommendation\nIt\
    \ is never good practice to compare a value with itself. If you require constant\
    \ behavior, use the Boolean literals `true` and `false`, rather than encoding\
    \ them obscurely as `1 == 1` or similar.\n\nIf an inequality test (using `!=`)\
    \ of a floating point variable with itself is intentional, it should be replaced\
    \ by `Double.isNaN(...)` or `Float.isNaN(...)` for readability. Similarly, if\
    \ an equality test (using `==`) of a floating point variable with itself is intentional,\
    \ it should be replaced by `!Double.isNaN(...)` or `!Float.isNaN(...)`.\n\n\n\
    ## Example\nIn the example below, the original version of `Customer` compares\
    \ `id` with `id`, which always returns `true`. The corrected version of `Customer`\
    \ includes the missing qualifier `o` in the comparison of `id` with `o.id`.\n\n\
    \n```java\nclass Customer {\n\t...\n\tpublic boolean equals(Object o) {\n\t\t\
    if (o == null) return false;\n\t\tif (Customer.class != o.getClass()) return false;\n\
    \t\tCustomer other = (Customer)o;\n\t\tif (!name.equals(o.name)) return false;\n\
    \t\tif (id != id) return false;  // Comparison of identical values\n\t\treturn\
    \ true;\n\t}\n}\n\nclass Customer {\n\t...\n\tpublic boolean equals(Object o)\
    \ {\n\t\tif (o == null) return false;\n\t\tif (Customer.class != o.getClass())\
    \ return false;\n\t\tCustomer other = (Customer)o;\n\t\tif (!name.equals(o.name))\
    \ return false;\n\t\tif (id != o.id) return false;  // Comparison corrected\n\t\
    \treturn true;\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java\
    \ Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [15.21.1. Numerical Equality Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21.1).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/CovariantCompareTo.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/CovariantCompareTo.bqrs
  metadata:
    name: Overloaded compareTo
    description: |-
      Defining 'Comparable.compareTo', where the parameter of 'compareTo' is not of the
                    appropriate type, overloads 'compareTo' instead of overriding it.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/wrong-compareto-signature
    tags: |-
      reliability
             correctness
  queryHelp: "# Overloaded compareTo\nClasses that implement `Comparable<T>` and define\
    \ a `compareTo` method whose parameter type is not `T` *overload* the `compareTo`\
    \ method instead of *overriding* it. This may not be intended.\n\n\n## Example\n\
    In the following example, the call to `compareTo` on line 17 calls the method\
    \ defined in class `Super`, instead of the method defined in class `Sub`, because\
    \ the type of `a` and `b` is `Super`. This may not be the method that the programmer\
    \ intended.\n\n\n```java\npublic class CovariantCompareTo {\n\tstatic class Super\
    \ implements Comparable<Super> {\n\t\tpublic int compareTo(Super rhs) {\n\t\t\t\
    return -1;\n\t\t}\n\t}\n\t\n\tstatic class Sub extends Super {\n\t\tpublic int\
    \ compareTo(Sub rhs) {  // Definition of compareTo uses a different parameter\
    \ type\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args)\
    \ {\n\t\tSuper a = new Sub();\n\t\tSuper b = new Sub();\n\t\tSystem.out.println(a.compareTo(b));\n\
    \t}\n}\n```\n\n## Recommendation\nTo *override* the `Comparable<T>.compareTo`\
    \ method, the parameter of `compareTo` must have type `T`.\n\nIn the example above,\
    \ this means that the type of the parameter of `Sub.compareTo` should be changed\
    \ to `Super`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*,\
    \ Item 12. Addison-Wesley, 2008.\n* Java Language Specification: [Overriding (by\
    \ Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1),\
    \ [Overloading](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.9).\n\
    * The Java Tutorials: [Overriding and Hiding Methods](https://docs.oracle.com/javase/tutorial/java/IandI/override.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/CovariantEquals.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/CovariantEquals.bqrs
  metadata:
    name: Overloaded equals
    description: |-
      Defining 'Object.equals', where the parameter of 'equals' is not of the
                    appropriate type, overloads 'equals' instead of overriding it.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/wrong-equals-signature
    tags: |-
      reliability
             correctness
  queryHelp: |
    # Overloaded equals
    Classes that define an `equals` method whose parameter type is not `Object` *overload* the `Object.equals` method instead of *overriding* it. This may not be intended.


    ## Recommendation
    To *override* the `Object.equals` method, the parameter of the `equals` method must have type `Object`.


    ## Example
    In the following example, the definition of class `BadPoint` does not override the `Object.equals` method. This means that `p.equals(q)` resolves to the default definition of `Object.equals` and returns `false`. Class `GoodPoint` correctly overrides `Object.equals`, so that `r.equals(s)` returns `true`.


    ```java
    class BadPoint {
        int x;
        int y;

        BadPoint(int x, int y) {
            this.x = x;
            this.y = y;
        }

        // overloaded equals method -- should be avoided
        public boolean equals(BadPoint q) {
            return x == q.x && y == q.y;
        }
    }

    BadPoint p = new BadPoint(1, 2);
    Object q = new BadPoint(1, 2);
    boolean badEquals = p.equals(q); // evaluates to false

    class GoodPoint {
        int x;
        int y;

        GoodPoint(int x, int y) {
            this.x = x;
            this.y = y;
        }

        // correctly overrides Object.equals(Object)
        public boolean equals(Object obj) {
            if (obj != null && getClass() == obj.getClass()) {
                GoodPoint q = (GoodPoint)obj;
                return x == q.x && y == q.y;
            }
            return false;
        }
    }

    GoodPoint r = new GoodPoint(1, 2);
    Object s = new GoodPoint(1, 2);
    boolean goodEquals = r.equals(s); // evaluates to true

    ```

    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 8. Addison-Wesley, 2008.
    * Java Language Specification: [Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1), [Overloading](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.9).
    * The Java Tutorials: [Overriding and Hiding Methods](https://docs.oracle.com/javase/tutorial/java/IandI/override.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/EqualsArray.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/EqualsArray.bqrs
  metadata:
    name: Equals or hashCode on arrays
    description: |-
      The 'equals' and 'hashCode' methods on arrays only consider object identity, not
                    array contents, which is unlikely to be what is intended.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/equals-on-arrays
    tags: |-
      reliability
             correctness
  queryHelp: "# Equals or hashCode on arrays\nThe `equals` and `hashCode` methods\
    \ on arrays only consider object identity, not array contents, which is unlikely\
    \ to be what is intended.\n\n\n## Recommendation\nTo compare the lengths of the\
    \ arrays and the corresponding pairs of elements in the arrays, use one of the\
    \ comparison methods from `java.util.Arrays`:\n\n* The method `Arrays.equals`\
    \ performs a shallow comparison. That is, array elements are compared using `equals`.\n\
    * The method `Arrays.deepEquals` performs a deep comparison, which is appropriate\
    \ for comparisons of nested arrays.\nSimilarly, `Arrays.hashCode` and `Arrays.deepHashCode`\
    \ can be used to compute shallow and deep hash codes based on the hash codes of\
    \ individual array elements.\n\n\n## Example\nIn the following example, the two\
    \ arrays are first compared using the `Object.equals` method. Because this checks\
    \ only reference equality and the two arrays are different objects, `Object.equals`\
    \ returns `false`. The two arrays are then compared using the `Arrays.equals`\
    \ method. Because this compares the length and contents of the arrays, `Arrays.equals`\
    \ returns `true`.\n\n\n```java\npublic void arrayExample(){\n    String[] array1\
    \ = new String[]{\"a\", \"b\", \"c\"};\n    String[] array2 = new String[]{\"\
    a\", \"b\", \"c\"};\n\n    // Reference equality tested: prints 'false'\n    System.out.println(array1.equals(array2));\n\
    \    \n    // Equality of array elements tested: prints 'true'\n    System.out.println(Arrays.equals(array1,\
    \ array2));\n}\n```\n\n## References\n* Java API Specification: [Arrays.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#equals(java.lang.Object[],java.lang.Object[])),\
    \ [Arrays.deepEquals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepEquals(java.lang.Object[],java.lang.Object[])),\
    \ [Objects.deepEquals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#deepEquals(java.lang.Object,java.lang.Object)),\
    \ [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)),\
    \ [Arrays.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#hashCode(java.lang.Object[])),\
    \ [Arrays.deepHashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepHashCode(java.lang.Object[])),\
    \ [Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/HashedButNoHash.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/HashedButNoHash.bqrs
  metadata:
    name: Hashed value without hashCode definition
    description: |-
      Classes that define an 'equals' method but no 'hashCode' method, and whose instances
                    are stored in a hashing data structure, can lead to unexpected results.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/hashing-without-hashcode
    tags: |-
      reliability
             correctness
  queryHelp: "# Hashed value without hashCode definition\nClasses that define an `equals`\
    \ method but no `hashCode` method can lead to unexpected results if instances\
    \ of those classes are stored in a hashing data structure. Hashing data structures\
    \ expect that hash codes fulfill the contract that two objects that `equals` considers\
    \ equal should have the same hash code. This contract is likely to be violated\
    \ by such classes.\n\n\n## Recommendation\nEvery class that implements a custom\
    \ `equals` method should also provide an implementation of `hashCode`.\n\n\n##\
    \ Example\nIn the following example, class `Point` has no implementation of `hashCode`.\
    \ Calling `hashCode` on two distinct `Point` objects with the same coordinates\
    \ would probably result in different hash codes. This would violate the contract\
    \ of the `hashCode` method, in which case objects of type `Point` should not be\
    \ stored in hashing data structures.\n\n\n```java\nclass Point {\n    int x;\n\
    \    int y;\n\n    Point(int x, int y) {\n        this.x = x;\n        this.y\
    \ = y;\n    }\n\n    public boolean equals(Object o) {\n    \tif (!(o instanceof\
    \ Point)) return false;\n    \tPoint q = (Point)o;\n    \treturn x == q.x && y\
    \ == q.y;\n    }\n}\n```\nIn the modification of the above example, the implementation\
    \ of `hashCode` for class `Point` is suitable because the hash code is computed\
    \ from exactly the same fields that are considered in the `equals` method. Therefore,\
    \ the contract of the `hashCode` method is fulfilled.\n\n\n```java\nclass Point\
    \ {\n    int x;\n    int y;\n\n    Point(int x, int y) {\n        this.x = x;\n\
    \        this.y = y;\n    }\n\n    public boolean equals(Object o) {\n       \
    \ if (!(o instanceof Point)) return false;\n        Point q = (Point)o;\n    \
    \    return x == q.x && y == q.y;\n    }\n\n    // Implement hashCode so that\
    \ equivalent points (with the same values of x and y) have the\n    // same hash\
    \ code\n    public int hashCode() {\n        int hash = 7;\n        hash = 31*hash\
    \ + x;\n        hash = 31*hash + y;\n        return hash;\n    }\n}\n\n```\n\n\
    ## References\n* J. Bloch, *Effective Java (second edition)*, Item 9. Addison-Wesley,\
    \ 2008.\n* Java API Specification: [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)),\
    \ [Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n\
    * IBM developerWorks: [Java theory and practice: Hashing it out](https://www.ibm.com/developerworks/java/library/j-jtp05273/index.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/IncomparableEquals.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/IncomparableEquals.bqrs
  metadata:
    name: Equals on incomparable types
    description: |-
      Calls of the form 'x.equals(y)', where the types of 'x' and 'y' are incomparable,
                    should always return 'false'.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/equals-on-unrelated-types
    tags: |-
      reliability
             correctness
  queryHelp: |
    # Equals on incomparable types
    Calls of the form `x.equals(y)`, where `x` and `y` have incomparable types, should always return `false` because the runtime types of `x` and `y` will be different. Two types are incomparable if they are distinct and do not have a common subtype.


    ## Recommendation
    Ensure that such comparisons use comparable types.


    ## Example
    In the following example, the call to `equals` on line 5 refers to the whole array by mistake, instead of a specific element. Therefore, "Value not found" is returned.


    ```java
    String[] anArray = new String[]{"a","b","c"}
    String valueToFind = "b";

    for(int i=0; i<anArray.length; i++){
      if(anArray.equals(valueToFind){    // anArray[i].equals(valueToFind) was intended
        return "Found value at index " + i;
      }
    }

    return "Value not found";
    ```

    ## References
    * Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/InconsistentCompareTo.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/InconsistentCompareTo.bqrs
  metadata:
    name: Inconsistent compareTo
    description: |-
      If a class overrides 'compareTo' but not 'equals', it may mean that 'compareTo'
                    and 'equals' are inconsistent.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/inconsistent-compareto-and-equals
    tags: |-
      reliability
             correctness
  queryHelp: "# Inconsistent compareTo\nA class that overrides `compareTo` but not\
    \ `equals` may not implement a natural ordering that is consistent with `equals`.\n\
    \n\n## Recommendation\nAlthough this consistency is not strictly required by the\
    \ `compareTo` contract, usually both methods should be overridden to ensure that\
    \ they are consistent, that is, that `x.compareTo(y)==0` is `true` if and only\
    \ if `x.equals(y)` is `true`, for any non-null `x` and `y`.\n\n\n## Example\n\
    In the following example, the class `InconsistentCompareTo` overrides `compareTo`\
    \ but not `equals`.\n\n\n```java\npublic class InconsistentCompareTo implements\
    \ Comparable<InconsistentCompareTo> {\n\tprivate int i = 0;\n\tpublic InconsistentCompareTo(int\
    \ i) {\n\t\tthis.i = i;\n\t}\n\t\n\tpublic int compareTo(InconsistentCompareTo\
    \ rhs) {\n\t\treturn i - rhs.i;\n\t}\n}\n```\nIn the following example, the class\
    \ `InconsistentCompareToFix` overrides both `compareTo` and `equals`.\n\n\n```java\n\
    public class InconsistentCompareToFix implements Comparable<InconsistentCompareToFix>\
    \ {\n\tprivate int i = 0;\n\tpublic InconsistentCompareToFix(int i) {\n\t\tthis.i\
    \ = i;\n\t}\n\t\n\tpublic int compareTo(InconsistentCompareToFix rhs) {\n\t\t\
    return i - rhs.i;\n\t}\n\n\tpublic boolean equals(InconsistentCompareToFix rhs)\
    \ {\n\t\treturn i == rhs.i;\n\t}\n}\n```\nIf you require a natural ordering that\
    \ is inconsistent with `equals`, you should document it clearly.\n\n\n## References\n\
    * J. Bloch, *Effective Java (second edition)*, Item 12. Addison-Wesley, 2008.\n\
    * Java API Specification: [Comparable.compareTo](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html#compareTo(T)),\
    \ [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/InconsistentEqualsHashCode.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/InconsistentEqualsHashCode.bqrs
  metadata:
    name: Inconsistent equals and hashCode
    description: |-
      If a class overrides only one of 'equals' and 'hashCode', it may mean that
                    'equals' and 'hashCode' are inconsistent.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/inconsistent-equals-and-hashcode
    tags: |-
      reliability
             correctness
             external/cwe/cwe-581
  queryHelp: "# Inconsistent equals and hashCode\nA class that overrides only one\
    \ of `equals` and `hashCode` is likely to violate the contract of the `hashCode`\
    \ method. The contract requires that `hashCode` gives the same integer result\
    \ for any two equal objects. Not enforcing this property may cause unexpected\
    \ results when storing and retrieving objects of such a class in a hashing data\
    \ structure.\n\n\n## Recommendation\nUsually, both methods should be overridden\
    \ to ensure that they are consistent.\n\n\n## Example\nIn the following example,\
    \ the class `InconsistentEqualsHashCode` overrides `hashCode` but not `equals`.\n\
    \n\n```java\npublic class InconsistentEqualsHashCode {\n\tprivate int i = 0;\n\
    \tpublic InconsistentEqualsHashCode(int i) {\n\t\tthis.i = i;\n\t}\n\n\tpublic\
    \ int hashCode() {\n\t\treturn i;\n\t}\n}\n```\nIn the following example, the\
    \ class `InconsistentEqualsHashCodeFix` overrides both `hashCode` and `equals`.\n\
    \n\n```java\npublic class InconsistentEqualsHashCodeFix {\n\tprivate int i = 0;\n\
    \tpublic InconsistentEqualsHashCodeFix(int i) {\n\t\tthis.i = i;\n\t}\n\n\t@Override\n\
    \tpublic int hashCode() {\n\t\treturn i;\n\t}\n\n\t@Override\n\tpublic boolean\
    \ equals(Object obj) {\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass()\
    \ != obj.getClass())\n\t\t\treturn false;\n\t\tInconsistentEqualsHashCodeFix that\
    \ = (InconsistentEqualsHashCodeFix) obj;\n\t\treturn this.i == that.i;\n\t}\n\
    }\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 9.\
    \ Addison-Wesley, 2008.\n* Java API Specification: [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)),\
    \ [Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n\
    * IBM developerWorks: [Java theory and practice: Hashing it out](https://www.ibm.com/developerworks/java/library/j-jtp05273/index.html).\n\
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Common Weakness Enumeration: [CWE-581](https://cwe.mitre.org/data/definitions/581.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/MissingInstanceofInEquals.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/MissingInstanceofInEquals.bqrs
  metadata:
    name: Equals method does not inspect argument type
    description: |-
      An implementation of 'equals' that does not check the type
                    of its argument may lead to failing casts.
    kind: problem
    problem.severity: error
    precision: high
    id: java/unchecked-cast-in-equals
    tags: |-
      reliability
             correctness
  queryHelp: "# Equals method does not inspect argument type\nAn implementation of\
    \ `equals` must be able to handle an argument of any type, to avoid failing casts.\
    \ Therefore, the implementation should inspect the type of its argument to see\
    \ if the argument can be safely cast to the class in which the `equals` method\
    \ is declared.\n\n\n## Recommendation\nUsually, an implementation of `equals`\
    \ should check the type of its argument using `instanceof`, following the general\
    \ pattern below.\n\n\n```java\nclass A {\n    // ...\n    public final boolean\
    \ equals(Object obj) {\n        if (!(obj instanceof A)) {\n        \treturn false;\n\
    \        }\n        A a = (A)obj;\n        // ...further checks...\n    }\n  \
    \  // ...\n}\n```\nUsing `instanceof` in this way has the added benefit that it\
    \ includes a guard against null pointer exceptions: if `obj` is `null`, the check\
    \ fails and `false` is returned. Therefore, after the check, it is guaranteed\
    \ that `obj` is not `null`, and its fields can be safely accessed.\n\nWhenever\
    \ you use `instanceof` to check the type of the argument, you should declare the\
    \ `equals` method `final`, so that subclasses are unable to cause a violation\
    \ of the symmetry requirement of the `equals` contract by further overriding `equals`.\n\
    \nIf you want subclasses to redefine the notion of equality by overriding `equals`,\
    \ use `getClass` instead of `instanceof` to check the type of the argument. However,\
    \ note that the use of `getClass` prevents any equality relationship between instances\
    \ of a class and its subclasses, even when no additional state is added in a subclass.\n\
    \n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 8. Addison-Wesley,\
    \ 2008.\n* Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n\
    * Java Language Specification: [Type Comparison Operator instanceof](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.20.2).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/RefEqBoxed.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/RefEqBoxed.bqrs
  metadata:
    name: Reference equality test of boxed types
    description: |-
      Comparing two boxed primitive values using the == or != operator
                    compares object identity, which may not be intended.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/reference-equality-of-boxed-types
    tags: |-
      reliability
             correctness
             external/cwe/cwe-595
  queryHelp: "# Reference equality test of boxed types\nComparing two boxed primitive\
    \ values using `==` or `!=` compares object identity, which may not be intended.\n\
    \n\n## Recommendation\nUsually, you should compare non-primitive objects, for\
    \ example boxed primitive values, by using their `equals` methods.\n\n\n## Example\n\
    With the following definition, the method call `refEq(new Integer(2), new Integer(2))`\
    \ returns `false` because the objects are not identical.\n\n\n```java\nboolean\
    \ refEq(Integer i, Integer j) {\n\treturn i == j;\n}\n```\nWith the following\
    \ definition, the method call `realEq(new Integer(2), new Integer(2))` returns\
    \ `true` because the objects contain equal values.\n\n\n```java\nboolean realEq(Integer\
    \ i, Integer j) {\n\treturn i.equals(j);\n}\n```\n\n## References\n* J. Bloch\
    \ and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 32.\
    \ Addison-Wesley, 2005.\n* Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)),\
    \ [Integer.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#equals(java.lang.Object)).\n\
    * Common Weakness Enumeration: [CWE-595](https://cwe.mitre.org/data/definitions/595.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/StringComparison.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/StringComparison.bqrs
  metadata:
    name: Reference equality test on strings
    description: |-
      Comparing two strings using the == or != operator
                    compares object identity, which may not be intended.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/reference-equality-on-strings
    tags: |-
      reliability
             external/cwe/cwe-597
  queryHelp: "# Reference equality test on strings\nComparing two `String` objects\
    \ using `==` or `!=` compares object identity, which may not be intended. The\
    \ same sequence of characters can be represented by two distinct `String` objects.\n\
    \n\n## Recommendation\nTo see if two `String` objects represent the same sequence\
    \ of characters, you should usually compare the objects by using their `equals`\
    \ methods.\n\n\n## Example\nWith the following definition, `headerStyle` is compared\
    \ to the empty string using `==`. This comparison can yield `false` even if `headerStyle`\
    \ is the empty string, because it compares the identity of the two string objects\
    \ rather than their contents. For example, if `headerStyle` was initialized by\
    \ an XML parser or a JSON parser, then it might have been created with code like\
    \ `String.valueOf(buf,start,len)`. Such code will produce a new string object\
    \ every time it is called.\n\n\n```java\nvoid printHeader(String headerStyle)\
    \ {\n\tif (headerStyle == null || headerStyle == \"\") {\n\t\t// No header\n\t\
    \treturn;\n\t}\n\t// ... print the header\n}\n\n```\nWith the following definition,\
    \ `headerStyle` is tested using the `equals` method. This version will reliably\
    \ detect whenever `headerStyle` is the empty string.\n\n\n```java\nvoid printHeader(String\
    \ headerStyle) {\n\tif (headerStyle == null || headerStyle.equals(\"\")) {\n\t\
    \t// No header\n\t\treturn;\n\t}\n\t// ... print the header\n}\n\n```\n\n## References\n\
    * Java API Specification: [String.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#equals(java.lang.Object)),\
    \ [String.intern()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#intern()).\n\
    * Java Language Specification: [15.21.3 Reference Equality Operators == and !=](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21.3),\
    \ [3.10.5 String Literals ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.5),\
    \ [15.28 Constant Expressions](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.28).\n\
    * Common Weakness Enumeration: [CWE-597](https://cwe.mitre.org/data/definitions/597.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/UselessComparisonTest.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/UselessComparisonTest.bqrs
  metadata:
    name: Useless comparison test
    description: |-
      A comparison operation that always evaluates to true or always
                    evaluates to false may indicate faulty logic and may result in
                    dead code.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/constant-comparison
    tags: |-
      correctness
             logic
             external/cwe/cwe-570
             external/cwe/cwe-571
  queryHelp: "# Useless comparison test\nThe result of certain comparison tests can\
    \ sometimes be inferred from their context and the results of other comparisons.\
    \ This can be an indication of faulty logic and may result in dead code or infinite\
    \ loops if, for example, a loop condition never changes its value.\n\n\n## Recommendation\n\
    Inspect the code to check whether the logic is correct, and consider simplifying\
    \ the logical expression.\n\n\n## Example\nIn the following example the final\
    \ test on `x` will always be `true`, and thus the condition is redundant and potentially\
    \ wrong. If the \"do more stuff\" part is intended to always execute after the\
    \ loop then the condition should be removed to make this clear.\n\n\n```java\n\
    void method(int x) {\n\twhile(x >= 0) {\n\t\t// do stuff\n\t\tx--;\n\t}\n\tif\
    \ (x < 0) { // BAD: always true\n\t\t// do more stuff\n\t}\n}\n```\n\n## References\n\
    * Java Language Specification: [The if Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.9).\n\
    * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n\
    * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Comparison/WrongNanComparison.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Comparison/WrongNanComparison.bqrs
  metadata:
    name: Wrong NaN comparison
    description: |-
      A comparison with 'NaN' using '==' or '!=' will always yield the same result
                    and is unlikely to be intended.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/comparison-with-nan
    tags: correctness
  queryHelp: |
    # Wrong NaN comparison
    The special floating-point number `NaN` is defined to be different from all other floating-point numbers, including itself, when compared using the equality operators, `==` and `!=`.


    ## Recommendation
    To check whether a variable `x` is `NaN` use the method `isNaN` that is defined on both `java.lang.Float` and `java.lang.Double`.


    ## Example
    The expression `x == Double.NaN` is always false. This expression should be replaced by `Double.isNaN(x)`, which accurately identifies whether `x` is equal to `Double.NaN`.


    ## References
    * Java Language Specification: [Numerical Equality Operators == and !=](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21.1).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/CallsToConditionWait.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/CallsToConditionWait.bqrs
  metadata:
    name: Wait on condition
    description: |-
      Calling 'wait' on a 'Condition' interface may result in unexpected behavior and is
                    probably a typographical error.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/wait-on-condition-interface
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-662
  queryHelp: |
    # Wait on condition
    Calling `wait` on an object of type `java.util.concurrent.locks.Condition` may result in unexpected behavior because `wait` is a method of the `Object` class, not the `Condition` interface itself. Such a call is probably a typographical error: typing "wait" instead of "await".


    ## Recommendation
    Instead of `Object.wait`, use one of the `Condition.await` methods.


    ## References
    * Java API Specification: [java.util.concurrent.Condition](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html).
    * Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/CallsToRunnableRun.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/CallsToRunnableRun.bqrs
  metadata:
    name: Direct call to a run() method
    description: |-
      Directly calling a 'Thread' object's 'run' method does not start a separate thread
                    but executes the method within the current thread.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/call-to-thread-run
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-572
  queryHelp: "# Direct call to a run() method\nA direct call of a `Thread` object's\
    \ `run` method does not start a separate thread. The method is executed within\
    \ the current thread. This is an unusual use because `Thread.run()` is normally\
    \ intended to be called from within a separate thread.\n\n\n## Recommendation\n\
    To execute `Runnable.run` from within a separate thread, do one of the following:\n\
    \n* Construct a `Thread` object using the `Runnable` object, and call `start`\
    \ on the `Thread` object.\n* Define a subclass of a `Thread` object, and override\
    \ the definition of its `run` method. Then construct an instance of this subclass\
    \ and call `start` on that instance directly.\n\n## Example\nIn the following\
    \ example, the main thread, `ThreadDemo`, calls the child thread, `NewThread`,\
    \ using `run`. This causes the child thread to run to completion before the rest\
    \ of the main thread is executed, so that \"Child thread activity\" is printed\
    \ before \"Main thread activity\".\n\n\n```java\npublic class ThreadDemo {\n \
    \   public static void main(String args[]) {\n        NewThread runnable = new\
    \ NewThread();\n\n        runnable.run();    // Call to 'run' does not start a\
    \ separate thread\n\n        System.out.println(\"Main thread activity.\");\n\
    \    }\n}\n\nclass NewThread extends Thread {\n    public void run() {\n     \
    \   try {\n            Thread.sleep(10000);\n        }\n        catch (InterruptedException\
    \ e) {\n            System.out.println(\"Child interrupted.\");\n        }\n \
    \       System.out.println(\"Child thread activity.\");\n    }\n}\n```\nTo enable\
    \ the two threads to run concurrently, create the child thread and call `start`,\
    \ as shown below. This causes the main thread to continue while the child thread\
    \ is waiting, so that \"Main thread activity\" is printed before \"Child thread\
    \ activity\".\n\n\n```java\npublic class ThreadDemo {\n    public static void\
    \ main(String args[]) {\n    \tNewThread runnable = new NewThread();\n    \t\n\
    \        runnable.start();                                         // Call 'start'\
    \ method\n        \n        System.out.println(\"Main thread activity.\");\n \
    \   }\n}\n```\n\n## References\n* The Java Tutorials: [Defining and Starting a\
    \ Thread](https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html).\n\
    * Common Weakness Enumeration: [CWE-572](https://cwe.mitre.org/data/definitions/572.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/DateFormatThreadUnsafe.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/DateFormatThreadUnsafe.bqrs
  metadata:
    name: Thread-unsafe use of DateFormat
    description: |-
      Static fields of type 'DateFormat' (or its descendants) should be avoided
                    because the class 'DateFormat' is not thread-safe.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/thread-unsafe-dateformat
    tags: |-
      reliability
             correctness
             concurrency
  queryHelp: "# Thread-unsafe use of DateFormat\nStatic fields of type `java.text.DateFormat`\
    \ or its descendants should be avoided because the class `DateFormat` is not thread-safe.\n\
    \n\n## Recommendation\nUse instance fields instead and synchronize access where\
    \ necessary.\n\n\n## Example\nIn the following example, `DateFormattingThread`\
    \ declares a static field `dateF` of type `DateFormat`. When instances of `DateFormattingThread`\
    \ are created and run by `DateFormatThreadUnsafe`, erroneous results are output\
    \ because `dateF` is shared by all instances of `DateFormattingThread`.\n\n\n\
    ```java\nclass DateFormattingThread implements Runnable {\n    public static DateFormat\
    \ dateF = new SimpleDateFormat(\"yyyyMMdd\");  // Static field declared\n\n  \
    \  public void run() {\n        for(int i=0; i < 10; i++){\n            try {\n\
    \                Date d = dateF.parse(\"20121221\");\n                System.out.println(d);\n\
    \            } catch (ParseException e) { }\n        }\n    }\n}\n\npublic class\
    \ DateFormatThreadUnsafe {\n    \n    public static void main(String[] args) {\n\
    \        for(int i=0; i<100; i++){\n            new Thread(new DateFormattingThread()).start();\n\
    \        }\n    }\n\n}\n```\nIn the following modification of the above example,\
    \ `DateFormattingThread` declares an *instance* field `dateF` of type `DateFormat`.\
    \ When instances of `DateFormattingThread` are created and run by `DateFormatThreadUnsafeFix`,\
    \ correct results are output because there is a separate instance of `dateF` for\
    \ each instance of `DateFormattingThread`.\n\n\n```java\nclass DateFormattingThread\
    \ implements Runnable {\n    private DateFormat dateF = new SimpleDateFormat(\"\
    yyyyMMdd\");  // Instance field declared\n\n    public void run() {\n        for(int\
    \ i=0; i < 10; i++){\n            try {\n                Date d = dateF.parse(\"\
    20121221\");\n                System.out.println(d);\n            } catch (ParseException\
    \ e) { }\n        }\n    }\n}\n\npublic class DateFormatThreadUnsafeFix {\n  \
    \  \n    public static void main(String[] args) {\n        for(int i=0; i<100;\
    \ i++){\n            new Thread(new DateFormattingThread()).start();\n       \
    \ }\n    }\n\n}\n```\n\n## References\n* Java API Specification: [java.text.DateFormat\
    \ synchronization](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DateFormat.html#synchronization).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/DoubleCheckedLocking.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/DoubleCheckedLocking.bqrs
  metadata:
    name: Double-checked locking is not thread-safe
    description: |-
      A repeated check on a non-volatile field is not thread-safe, and
                    could result in unexpected behavior.
    kind: problem
    problem.severity: error
    precision: high
    id: java/unsafe-double-checked-locking
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-609
  queryHelp: |
    # Double-checked locking is not thread-safe
    Double-checked locking is a common pattern for lazy initialization of a field accessed by multiple threads. Depending on the memory model of the underlying runtime, it can, however, be quite difficult to implement correctly, since reorderings performed by compiler, runtime, or CPU might expose un-initialized or half-way initialized objects to other threads. Java has since version 5 improved its memory model to support double-checked locking if the underlying field is marked `volatile` and if all initialization happens before the volatile write.


    ## Recommendation
    First, it should be considered whether the getter that performs the lazy initialization is performance critical. If not, a much simpler solution is to completely avoid double-checked locking and simply mark the entire getter as `synchronized`. This is much easier to get right and guards against hard-to-find concurrency bugs.

    If double-checked locking is used, it is important that the underlying field is `volatile` and that the update to the field is the last thing that happens in the synchronized region, that is, all initialization must be done before the field is assigned. Furthermore, the Java version must be 5 or newer. Reading a `volatile` field has a slight overhead, so it is also useful to use a local variable to minimize the number of volatile reads.


    ## Example
    The following code lazily initializes `f` to `new MyObject()`.


    ```java
    private Object lock = new Object();
    private MyObject f = null;

    public MyObject getMyObject() {
      if (f == null) {
        synchronized(lock) {
          if (f == null) {
            f = new MyObject(); // BAD
          }
        }
      }
      return f;
    }

    ```
    This code is not thread-safe as another thread might see the assignment to `f` before the constructor finishes evaluating, for example if the compiler inlines the memory allocation and the constructor and reorders the assignment to `f` to occur just after the memory allocation.

    Another example that also is not thread-safe, even when `volatile` is used, is if additional initialization happens after the assignment to `f`, since then other threads may access the constructed object before it is fully initialized, even without any reorderings by the compiler or runtime.


    ```java
    private Object lock = new Object();
    private volatile MyObject f = null;

    public MyObject getMyObject() {
      if (f == null) {
        synchronized(lock) {
          if (f == null) {
            f = new MyObject();
            f.init(); // BAD
          }
        }
      }
      return f;
    }

    ```
    The code above should be rewritten to both use `volatile` and finish all initialization before `f` is updated. Additionally, a local variable can be used to avoid reading the field more times than necessary.


    ```java
    private Object lock = new Object();
    private volatile MyObject f = null;

    public MyObject getMyObject() {
      MyObject result = f;
      if (result == null) {
        synchronized(lock) {
          result = f;
          if (result == null) {
            result = new MyObject();
            result.init();
            f = result; // GOOD
          }
        }
      }
      return result;
    }

    ```
    As a final note, it is possible to use double-checked locking correctly without `volatile` if the object you construct is immutable (that is, the object declares all fields as `final`), and the double-checked field is read exactly once outside the synchronized block.

    Given that all fields in `MyImmutableObject` are declared `final` then the following example is protected against exposing uninitialized fields to another thread. However, since there are two reads of `f` without synchronization, it is possible that these are reordered, which means that this method can return `null`.


    ```java
    private Object lock = new Object();
    private MyImmutableObject f = null;

    public MyImmutableObject getMyImmutableObject() {
      if (f == null) {
        synchronized(lock) {
          if (f == null) {
            f = new MyImmutableObject();
          }
        }
      }
      return f; // BAD
    }

    ```
    In this case, using a local variable to minimize the number of field reads is no longer a performance improvement, but rather a crucial detail that is necessary for correctness.


    ## References
    * [The "Double-Checked Locking is Broken" Declaration](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html).
    * Java Language Specification: [17.4. Memory Model](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4).
    * Wikipedia: [Double-checked locking](https://en.wikipedia.org/wiki/Double-checked_locking).
    * Aleksey Shipilëv: [Safe Publication and Safe Initialization in Java](https://shipilev.net/blog/2014/safe-public-construction/).
    * Aleksey Shipilëv: [Close Encounters of The Java Memory Model Kind](https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/).
    * Common Weakness Enumeration: [CWE-609](https://cwe.mitre.org/data/definitions/609.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/DoubleCheckedLockingWithInitRace.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/DoubleCheckedLockingWithInitRace.bqrs
  metadata:
    name: Race condition in double-checked locking object initialization
    description: |-
      Performing additional initialization on an object after
                    assignment to a shared variable guarded by double-checked
                    locking is not thread-safe, and could result in unexpected
                    behavior.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/unsafe-double-checked-locking-init-order
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-609
  queryHelp: |
    # Race condition in double-checked locking object initialization
    Double-checked locking is a common pattern for lazy initialization of a field accessed by multiple threads. Depending on the memory model of the underlying runtime, it can, however, be quite difficult to implement correctly, since reorderings performed by compiler, runtime, or CPU might expose un-initialized or half-way initialized objects to other threads. Java has since version 5 improved its memory model to support double-checked locking if the underlying field is marked `volatile` and if all initialization happens before the volatile write.


    ## Recommendation
    First, it should be considered whether the getter that performs the lazy initialization is performance critical. If not, a much simpler solution is to completely avoid double-checked locking and simply mark the entire getter as `synchronized`. This is much easier to get right and guards against hard-to-find concurrency bugs.

    If double-checked locking is used, it is important that the underlying field is `volatile` and that the update to the field is the last thing that happens in the synchronized region, that is, all initialization must be done before the field is assigned. Furthermore, the Java version must be 5 or newer. Reading a `volatile` field has a slight overhead, so it is also useful to use a local variable to minimize the number of volatile reads.


    ## Example
    The following code lazily initializes `f` to `new MyObject()`.


    ```java
    private Object lock = new Object();
    private MyObject f = null;

    public MyObject getMyObject() {
      if (f == null) {
        synchronized(lock) {
          if (f == null) {
            f = new MyObject(); // BAD
          }
        }
      }
      return f;
    }

    ```
    This code is not thread-safe as another thread might see the assignment to `f` before the constructor finishes evaluating, for example if the compiler inlines the memory allocation and the constructor and reorders the assignment to `f` to occur just after the memory allocation.

    Another example that also is not thread-safe, even when `volatile` is used, is if additional initialization happens after the assignment to `f`, since then other threads may access the constructed object before it is fully initialized, even without any reorderings by the compiler or runtime.


    ```java
    private Object lock = new Object();
    private volatile MyObject f = null;

    public MyObject getMyObject() {
      if (f == null) {
        synchronized(lock) {
          if (f == null) {
            f = new MyObject();
            f.init(); // BAD
          }
        }
      }
      return f;
    }

    ```
    The code above should be rewritten to both use `volatile` and finish all initialization before `f` is updated. Additionally, a local variable can be used to avoid reading the field more times than necessary.


    ```java
    private Object lock = new Object();
    private volatile MyObject f = null;

    public MyObject getMyObject() {
      MyObject result = f;
      if (result == null) {
        synchronized(lock) {
          result = f;
          if (result == null) {
            result = new MyObject();
            result.init();
            f = result; // GOOD
          }
        }
      }
      return result;
    }

    ```
    As a final note, it is possible to use double-checked locking correctly without `volatile` if the object you construct is immutable (that is, the object declares all fields as `final`), and the double-checked field is read exactly once outside the synchronized block.

    Given that all fields in `MyImmutableObject` are declared `final` then the following example is protected against exposing uninitialized fields to another thread. However, since there are two reads of `f` without synchronization, it is possible that these are reordered, which means that this method can return `null`.


    ```java
    private Object lock = new Object();
    private MyImmutableObject f = null;

    public MyImmutableObject getMyImmutableObject() {
      if (f == null) {
        synchronized(lock) {
          if (f == null) {
            f = new MyImmutableObject();
          }
        }
      }
      return f; // BAD
    }

    ```
    In this case, using a local variable to minimize the number of field reads is no longer a performance improvement, but rather a crucial detail that is necessary for correctness.


    ## References
    * [The "Double-Checked Locking is Broken" Declaration](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html).
    * Java Language Specification: [17.4. Memory Model](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4).
    * Wikipedia: [Double-checked locking](https://en.wikipedia.org/wiki/Double-checked_locking).
    * Aleksey Shipilëv: [Safe Publication and Safe Initialization in Java](https://shipilev.net/blog/2014/safe-public-construction/).
    * Aleksey Shipilëv: [Close Encounters of The Java Memory Model Kind](https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/).
    * Common Weakness Enumeration: [CWE-609](https://cwe.mitre.org/data/definitions/609.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/FutileSynchOnField.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/FutileSynchOnField.bqrs
  metadata:
    name: Futile synchronization on field
    description: |-
      Synchronizing on a field and updating that field while the lock is held is unlikely
                    to provide the desired thread safety.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/unsafe-sync-on-field
    tags: |-
      reliability
             correctness
             concurrency
             language-features
             external/cwe/cwe-662
  queryHelp: "# Futile synchronization on field\nA block of code that synchronizes\
    \ on a field and updates that field while the lock is held is unlikely to provide\
    \ the desired thread safety. Such a synchronized block does not prevent multiple\
    \ unsynchronized assignments to that field because it obtains a lock on the object\
    \ stored *in* the field rather than the field itself.\n\n\n## Recommendation\n\
    Instead of synchronizing on the field itself, consider synchronizing on a separate\
    \ lock object when you want to avoid simultaneous updates to the field. You can\
    \ do this by declaring a synchronized method and using it for any field updates.\n\
    \n\n## Example\nIn the following example, in class A, synchronization takes place\
    \ on the field that is updated in the body of the `setField` method.\n\n\n```java\n\
    public class A {\n    private Object field;  \n    \n    public void setField(Object\
    \ o){\n        synchronized (field){    // BAD: synchronize on the field to be\
    \ updated\n            field = o;\n            // ... more code ...          \n\
    \        }\n    }\n}\n```\nIn class B, the recommended approach is shown, where\
    \ synchronization takes place on a separate lock object.\n\n\n```java\npublic\
    \ class B {\n   private final Object lock = new Object();\n   private Object field;\n\
    \n   public void setField(Object o){\n       synchronized (lock){      // GOOD:\
    \ synchronize on a separate lock object\n           field = o;\n           //\
    \ ... more code ...\n       }\n   }\n}\n```\n\n## References\n* Java Language\
    \ Specification: [The synchronized Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.19),\
    \ [synchronized Methods](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.3.6).\n\
    * The Java Tutorials: [Lock Objects](https://docs.oracle.com/javase/tutorial/essential/concurrency/newlocks.html).\n\
    * Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/NonSynchronizedOverride.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/NonSynchronizedOverride.bqrs
  metadata:
    name: Non-synchronized override of synchronized method
    description: |-
      If a synchronized method is overridden in a subclass, and the overriding method is
                    not synchronized, the thread-safety of the subclass may be broken.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/non-sync-override
    tags: |-
      reliability
             correctness
             concurrency
             language-features
             external/cwe/cwe-820
  queryHelp: |
    # Non-synchronized override of synchronized method
    If a synchronized method is overridden in a subclass, the compiler does not require the overriding method to be synchronized. However, if the overriding method is not synchronized, the thread-safety of the subclass may be broken.


    ## Recommendation
    Ensure that the overriding method is synchronized, if necessary.


    ## References
    * Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * Common Weakness Enumeration: [CWE-820](https://cwe.mitre.org/data/definitions/820.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/NotifyNotNotifyAll.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/NotifyNotNotifyAll.bqrs
  metadata:
    name: notify instead of notifyAll
    description: |-
      Calling 'notify' instead of 'notifyAll' may fail to wake up the correct thread and
                    cannot wake up multiple threads.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/notify-instead-of-notify-all
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-662
  queryHelp: |
    # notify instead of notifyAll
    Calls to the `notify` method rather than `notifyAll` may fail to wake up the correct thread if an object's monitor (intrinsic lock) is used for multiple conditions. `notify` only wakes up a single arbitrary thread that is waiting on the object's monitor, whereas `notifyAll` wakes up all such threads.


    ## Recommendation
    Ensure that the call to `notify` instead of `notifyAll` is a correct and desirable optimization. If not, call `notifyAll` instead.


    ## Example
    In the following example, the methods `produce` and `consume` both use `notify` to tell any waiting threads that an object has been added or removed from the buffer. However, this means that only *one* thread is notified. The woken-up thread might not be able to proceed due to its condition being false, immediately going back to the waiting state. As a result no progress is made.


    ```java
    class ProducerConsumer {
        private static final int MAX_SIZE=3;
        private List<Object> buf = new ArrayList<Object>();

        public synchronized void produce(Object o) {
            while (buf.size()==MAX_SIZE) {
                try {
                    wait();
                }
                catch (InterruptedException e) {
                   ...
                }
            }
            buf.add(o);
            notify(); // 'notify' is used
        }

        public synchronized Object consume() {

            while (buf.size()==0) {
                try {
                    wait();
                }
                catch (InterruptedException e) {
                    ...
                }
            }
            Object o = buf.remove(0);
            notify(); // 'notify' is used
            return o;
        }
    }

    ```
    When using `notifyAll` instead of `notify`, *all* threads are notified, and if there are any threads that could proceed, we can be sure that at least one of them will do so.


    ## References
    * J. Bloch. *Effective Java (second edition)*, p. 277. Addison-Wesley, 2008.
    * Java API Specification: [Object.notify()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notify()), [Object.notifyAll()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notifyAll()).
    * Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/SleepWithLock.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/SleepWithLock.bqrs
  metadata:
    name: Sleep with lock held
    description: |-
      Calling 'Thread.sleep' with a lock held may lead to very poor
                    performance or even deadlock.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/sleep-with-lock-held
    tags: |-
      reliability
             correctness
             concurrency
             external/cwe/cwe-833
  queryHelp: |
    # Sleep with lock held
    Calling `Thread.sleep` with a lock held may lead to very poor performance or even deadlock. This is because `Thread.sleep` does not cause a thread to release its locks.


    ## Recommendation
    `Thread.sleep` should be called only outside of a `synchronized` block. However, a better way for threads to yield execution time to other threads may be to use either of the following solutions:

    * The `java.util.concurrent` library
    * The `wait` and `notifyAll` methods

    ## Example
    In the following example of the problem, two threads, `StorageThread` and `OtherThread`, are started. Both threads output a message to show that they have started but then `StorageThread` locks `counter` and goes to sleep. The lock prevents `OtherThread` from locking `counter`, so it has to wait until `StorageThread` has woken up and unlocked `counter` before it can continue.


    ```java
    class StorageThread implements Runnable{
        public static Integer counter = 0;
        private static final Object LOCK = new Object();

        public void run() {
            System.out.println("StorageThread started.");
            synchronized(LOCK) {  // "LOCK" is locked just before the thread goes to sleep
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) { ... }
            }
            System.out.println("StorageThread exited.");
        }
    }

    class OtherThread implements Runnable{
        public void run() {
            System.out.println("OtherThread started.");
            synchronized(StorageThread.LOCK) {
                StorageThread.counter++;
            }
            System.out.println("OtherThread exited.");
        }
    }

    public class SleepWithLock {
        public static void main(String[] args) {
            new Thread(new StorageThread()).start();
            new Thread(new OtherThread()).start();
        }
    }

    ```
    To avoid this problem, `StorageThread` should call `Thread.sleep` outside the `synchronized` block instead, so that `counter` is unlocked.


    ## References
    * Java API Specification: [Thread.sleep()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#sleep(long)), [Object.wait()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#wait()), [Object.notifyAll()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notifyAll()), [java.util.concurrent](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html).
    * Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/StartInConstructor.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/StartInConstructor.bqrs
  metadata:
    name: Start of thread in constructor
    description: |-
      Starting a thread within a constructor may cause the thread to start before
                    any subclass constructor has completed its initialization, causing unexpected
                    results.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/thread-start-in-constructor
    tags: |-
      reliability
             correctness
             concurrency
  queryHelp: "# Start of thread in constructor\nStarting a thread within a constructor\
    \ may cause unexpected results. If the class is extended, the thread may start\
    \ before the subclass constructor has completed its initialization, which may\
    \ not be intended.\n\n\n## Recommendation\nAvoid starting threads in constructors.\
    \ Typically, the constructor of a class only *constructs* the thread object, and\
    \ a separate `start` method should be provided to *start* the thread object created\
    \ by the constructor.\n\n\n## Example\nIn the following example, because the `Test`\
    \ constructor implicitly calls the `Super` constructor, the thread created in\
    \ the `Super` constructor may start before `this.name` has been initialized. Therefore,\
    \ the program may output \"hello \" followed by a null string.\n\n\n```java\n\
    class Super {\n    public Super() {\n        new Thread() {\n            public\
    \ void run() {\n                System.out.println(Super.this.toString());\n \
    \           }\n        }.start(); // BAD: The thread is started in the constructor\
    \ of 'Super'.\n    }\n\n    public String toString() {\n        return \"hello\"\
    ;\n    }\n}\n\nclass Test extends Super {\n    private String name;\n    public\
    \ Test(String nm) {\n        // The thread is started before\n        // this\
    \ line is run\n        this.name = nm;\n    }\n\n    public String toString()\
    \ {\n        return super.toString() + \" \" + name;\n    }\n\n    public static\
    \ void main(String[] args) {\n        new Test(\"my friend\");\n    }\n}\n```\n\
    In the following modified example, the thread created in the `Super` constructor\
    \ is not started within the constructor; `main` starts the thread after `this.name`\
    \ has been initialized. This results in the program outputting \"hello my friend\"\
    .\n\n\n```java\nclass Super {\n    Thread thread;\n    public Super() {\n    \
    \    thread = new Thread() {\n            public void run() {\n              \
    \  System.out.println(Super.this.toString());\n            }\n        };\n   \
    \ }\n\n    public void start() {  // good\n        thread.start();\n    }\n  \
    \  \n    public String toString() {\n        return \"hello\";\n    }\n}\n\nclass\
    \ Test extends Super {\n    private String name;\n    public Test(String nm) {\n\
    \        this.name = nm;\n    }\n\n    public String toString() {\n        return\
    \ super.toString() + \" \" + name;\n    }\n\n    public static void main(String[]\
    \ args) {\n        Test t = new Test(\"my friend\");\n        t.start();\n   \
    \ }\n}\n```\n\n## References\n* IBM developerWorks: [Don't start threads from\
    \ within constructors](https://web.archive.org/web/20200417101823/http://www.ibm.com/developerworks/java/library/j-jtp0618/index.html#4).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/SynchOnBoxedType.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/SynchOnBoxedType.bqrs
  metadata:
    name: Synchronization on boxed types or strings
    description: |-
      Synchronizing on boxed types or strings may lead to
                    deadlock since an instance of that type is likely to
                    be shared between many parts of the program.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/sync-on-boxed-types
    tags: |-
      reliability
             correctness
             concurrency
             language-features
             external/cwe/cwe-662
  queryHelp: "# Synchronization on boxed types or strings\nCode should not synchronize\
    \ on a variable or field of a boxed type (for example `Integer`, `Boolean`) or\
    \ of type `String` since it is likely to contain an object that is used throughout\
    \ the program. For example, `Boolean.TRUE` holds a single instance that will be\
    \ used in many places throughout the program: whenever `true` is autoboxed or\
    \ a call to `Boolean.valueOf` is made with `true` as an argument the same instance\
    \ of `Boolean` is returned. It is therefore likely that two classes synchronizing\
    \ on a field of type `Boolean` will end up synchronizing on the same object. This\
    \ may lead to deadlock or threads being blocked unnecessarily.\n\n\n## Recommendation\n\
    Synchronize on a specific lock object instead of using an object with a boxed\
    \ type.\n\n\n## Example\nIn the following example, the intention is to allow `ThreadA`\
    \ and `ThreadB` to run at the same time. Unfortunately, `ThreadA.lock` and `ThreadB.lock`\
    \ both refer to the same object (that is, the interned value of the `String` `\"\
    lock\"`) so the synchronized blocks in their run methods can not be executed concurrently.\n\
    \n\n```java\nclass BadSynchronize{\n\t\t\n\tclass ThreadA extends Thread{\n\t\t\
    private String value = \"lock\"\n\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(value){\n\
    \t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass ThreadB extends Thread{\n\t\t\
    private String value = \"lock\"\n\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(value){\n\
    \t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run(){\n\t\tnew ThreadA().start();\n\
    \t\tnew ThreadB().start();\n\t}\n\t\t\n}\n```\nIn the following example, the approach\
    \ recommended above is shown. A separate lock object is created for each thread\
    \ allowing them to execute concurrently.\n\n\n```java\nclass GoodSynchronize{\n\
    \t\t\n\tclass ThreadA extends Thread{\n\t\tprivate Object lock = new Object();\n\
    \t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(lock){\n\t\t\t\t//...\n\t\t\t\
    }\n\t\t}\n\t}\n\t\n\tclass ThreadB extends Thread{\n\t\tprivate Object lock =\
    \ new Object();\n\t\t\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(lock){\n\
    \t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run(){\n\t\tnew ThreadA().start();\n\
    \t\tnew ThreadB().start();\n\t}\n\t\t\n}\n```\n\n## References\n* SEI CERT Oracle\
    \ Coding Standard for Java: [LCK01-J. Do not synchronize on objects that may be\
    \ reused](https://wiki.sei.cmu.edu/confluence/display/java/LCK01-J.+Do+not+synchronize+on+objects+that+may+be+reused),\n\
    * Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/SynchSetUnsynchGet.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/SynchSetUnsynchGet.bqrs
  metadata:
    name: Inconsistent synchronization of getter and setter
    description: |-
      If a class has a synchronized 'set' method, and a similarly-named 'get' method is
                    not also synchronized, calls to the 'get' method may not return a consistent state
                    for the object.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/unsynchronized-getter
    tags: |-
      reliability
             correctness
             concurrency
             language-features
             external/cwe/cwe-413
             external/cwe/cwe-662
  queryHelp: |
    # Inconsistent synchronization of getter and setter
    If a class has a synchronized `set` method and a similarly-named `get` method is not also synchronized, calls to the `get` method may not return a consistent state for the object.


    ## Recommendation
    Synchronize read operations as well as write operations. You should usually synchronize the `get` method.


    ## References
    * Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).
    * Common Weakness Enumeration: [CWE-413](https://cwe.mitre.org/data/definitions/413.html).
    * Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/SynchWriteObject.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/SynchWriteObject.bqrs
  metadata:
    name: Inconsistent synchronization for writeObject()
    description: |-
      Classes with a synchronized 'writeObject' method but no other
                    synchronized methods usually lack a sufficient level of synchronization.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/inconsistent-sync-writeobject
    tags: |-
      reliability
             correctness
             concurrency
             language-features
             external/cwe/cwe-662
  queryHelp: |
    # Inconsistent synchronization for writeObject()
    Classes with a synchronized `writeObject` method but no other synchronized methods usually lack a sufficient level of synchronization. If any mutable state of this class can be modified without proper synchronization, the serialization using the `writeObject` method may result in an inconsistent state.


    ## Recommendation
    See if synchronization is necessary on methods other than `writeOject` to make the class thread-safe. Any methods that access or modify the state of an object of this class should usually be synchronized as well.


    ## References
    * Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).
    * Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Concurrency/UnreleasedLock.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Concurrency/UnreleasedLock.bqrs
  metadata:
    name: Unreleased lock
    description: |-
      A lock that is acquired one or more times without a matching number of unlocks
                    may cause a deadlock.
    kind: problem
    problem.severity: error
    security-severity: 5.0
    precision: medium
    id: java/unreleased-lock
    tags: |-
      reliability
             security
             external/cwe/cwe-764
             external/cwe/cwe-833
  queryHelp: |
    # Unreleased lock
    When a thread acquires a lock it must make sure to unlock it again; failing to do so can lead to deadlocks. If a lock allows a thread to acquire it multiple times, for example `java.util.concurrent.locks.ReentrantLock`, then the number of locks must match the number of unlocks in order to fully release the lock.


    ## Recommendation
    It is recommended practice always to immediately follow a call to `lock` with a `try` block and place the call to `unlock` inside the `finally` block. Beware of calls inside the `finally` block that could cause exceptions, as this may result in skipping the call to `unlock`.


    ## Example
    The typical pattern for using locks safely looks like this:


    ```java
    public void m() {
       lock.lock();
       // A
       try {
          // ... method body
       } finally {
          // B
          lock.unlock();
       }
    }
    ```
    If any code that can cause a premature method exit (for example by throwing an exception) is inserted at either point `A` or `B` then the method might not unlock, so this should be avoided.


    ## References
    * Java API Specification: [java.util.concurrent.locks.Lock](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Lock.html), [java.util.concurrent.locks.ReentrantLock](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html).
    * Common Weakness Enumeration: [CWE-764](https://cwe.mitre.org/data/definitions/764.html).
    * Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Finalization/NullifiedSuperFinalize.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Finalization/NullifiedSuperFinalize.bqrs
  metadata:
    name: Finalizer inconsistency
    description: |-
      A 'finalize' method that does not call 'super.finalize' may leave
                    cleanup actions undone.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/missing-super-finalize
    tags: |-
      reliability
             maintainability
             external/cwe/cwe-568
  queryHelp: "# Finalizer inconsistency\nA `finalize` method that overrides the finalizer\
    \ of a superclass but does not call `super.finalize` may leave system resources\
    \ undisposed of or cause other cleanup actions to be left undone.\n\n\n## Recommendation\n\
    Make sure that all `finalize` methods call `super.finalize` to ensure that the\
    \ finalizer of its superclass is executed. Finalizer chaining is not automatic\
    \ in Java.\n\nIt is also possible to defend against subclasses that do not call\
    \ `super.finalize` by putting the cleanup code into a *finalizer guardian* instead\
    \ of the `finalize` method. A finalizer guardian is an anonymous object instance\
    \ that contains the cleanup code for the enclosing object in its `finalize` method.\
    \ The only reference to the finalizer guardian is stored in a private field of\
    \ the enclosing instance, which means that both the guardian and the enclosing\
    \ instance can be finalized at the same time. This way, a subclass cannot block\
    \ the execution of the cleanup code by not calling `super.finalize`.\n\n\n## Example\n\
    In the following example, `WrongCache.finalize` does not call `super.finalize`,\
    \ which means that native resources are not disposed of. However, `RightCache.finalize`\
    \ *does* call `super.finalize`, which means that native resources *are* disposed\
    \ of.\n\n\n```java\nclass LocalCache {\n    private Collection<NativeResource>\
    \ localResources;\n\n    //...\n\n    protected void finalize() throws Throwable\
    \ {\n        for (NativeResource r : localResources) {\n            r.dispose();\n\
    \        }\n    };\n}\n\nclass WrongCache extends LocalCache {\n    //...\n  \
    \  @Override\n    protected void finalize() throws Throwable {\n        // BAD:\
    \ Empty 'finalize', which does not call 'super.finalize'.\n        //        Native\
    \ resources in LocalCache are not disposed of.\n    }\n}\n\nclass RightCache extends\
    \ LocalCache {\n    //...\n    @Override\n    protected void finalize() throws\
    \ Throwable {\n        // GOOD: 'finalize' calls 'super.finalize'.\n        //\
    \        Native resources in LocalCache are disposed of.\n        super.finalize();\n\
    \    }\n}\n\n```\nThe following example shows a finalizer guardian.\n\n\n```java\n\
    class GuardedLocalCache {\n\tprivate Collection<NativeResource> localResources;\n\
    \t// A finalizer guardian, which performs the finalize actions for 'GuardedLocalCache'\n\
    \t// even if a subclass does not call 'super.finalize' in its 'finalize' method\n\
    \tprivate Object finalizerGuardian = new Object() {\n\t\tprotected void finalize()\
    \ throws Throwable {\n\t\t\tfor (NativeResource r : localResources) {\n\t\t\t\t\
    r.dispose();\n\t\t\t}\n\t\t};\n\t};\n}\n```\n\n## References\n* Java API Specification:\
    \ [Object.finalize()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#finalize()).\n\
    * J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n\
    * Common Weakness Enumeration: [CWE-568](https://cwe.mitre.org/data/definitions/568.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Frameworks/JUnit/BadSuiteMethod.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Frameworks/JUnit/BadSuiteMethod.bqrs
  metadata:
    name: Bad suite method
    description: |-
      A 'suite' method in a JUnit 3.8 test that does not match the expected signature is not
                    detected by JUnit.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/wrong-junit-suite-signature
    tags: |-
      testability
             maintainability
             frameworks/junit
  queryHelp: "# Bad suite method\nJUnit 3.8 requires that a `suite` method for defining\
    \ a `TestSuite` that will be used by a `TestRunner` has a specific signature.\
    \ If the `suite` method does not have the expected signature, JUnit does not detect\
    \ the method as a `suite` method.\n\n\n## Recommendation\nMake sure that `suite`\
    \ methods in junit `TestCase` classes are declared both `public` and `static`,\
    \ and that they have a return type of `junit.framework.Test` or one of its subtypes.\n\
    \n\n## Example\nIn the following example, `BadSuiteMethod.suite` is not detected\
    \ by JUnit because it is not declared `public`. However, `CorrectSuiteMethod.suite`\
    \ *is* detected by JUnit because it has the expected signature.\n\n\n```java\n\
    public class BadSuiteMethod extends TestCase {\n\t// BAD: JUnit 3.8 does not detect\
    \ the following method as a 'suite' method.\n\t// The method should be public,\
    \ static, and return 'junit.framework.Test' \n\t// or one of its subtypes.\n\t\
    static Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new\
    \ MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\
    \t\treturn suite;\n\t}\n}\n\npublic class CorrectSuiteMethod extends TestCase\
    \ {\n\t// GOOD: JUnit 3.8 correctly detects the following method as a 'suite'\
    \ method.\n\tpublic static Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\
    \t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"\
    testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n```\n\n## References\n* JUnit:\
    \ [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Frameworks/Swing/BadlyOverriddenAdapter.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Frameworks/Swing/BadlyOverriddenAdapter.bqrs
  metadata:
    name: Bad implementation of an event Adapter
    description: |-
      In a class that extends a Swing or Abstract Window Toolkit event adapter, an
                    event handler that does not have exactly the same name as the event handler that it
                    overrides means that the overridden event handler is not called.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/wrong-swing-event-adapter-signature
    tags: |-
      reliability
             maintainability
             frameworks/swing
  queryHelp: |
    # Bad implementation of an event Adapter
    Event adapters in Swing (and Abstract Window Toolkit) provide a convenient way for programmers to implement event listeners. However, care must be taken to get the names of the overridden methods right, or the event handlers will not be called.


    ## In Depth
    The event listener interfaces in Swing (and Abstract Window Toolkit) have many methods. For example, `java.awt.event.MouseListener` is defined as follows:

    ```java
    public interface MouseListener extends EventListener {
        public abstract void mouseClicked(MouseEvent);
        public abstract void mousePressed(MouseEvent);
        public abstract void mouseReleased(MouseEvent);
        public abstract void mouseEntered(MouseEvent);
        public abstract void mouseExited(MouseEvent);
    }
    ```
    The large number of methods can make such interfaces lengthy and tedious to implement, especially because it is rare that all of the methods need to be overridden. It is much more common that you need to override only one method, for example the `mouseClicked` event.

    For this reason, Swing supplies *adapter* classes that provide default, blank implementations of interface methods. An example is `MouseAdapter`, which provides default implementations for the methods in `MouseListener`, `MouseWheelListener` and `MouseMotionListener`. (Note that an adapter often implements multiple interfaces to avoid a large number of small adapter classes.) This makes it easy for programmers to implement just the methods they need from a given interface.

    Unfortunately, adapter classes are also a source of potential defects. Because the `@Override` annotation is not compulsory, it is very easy for programmers not to use it and then mistype the name of the method. This introduces a new method rather than implementing the relevant event handler.


    ## Recommendation
    Ensure that any overriding methods have exactly the same name as the overridden method.


    ## Example
    In the following example, the programmer has tried to implement the `mouseClicked` function but has misspelled the function name. This makes the function inoperable but the programmer gets no warning about this from the compiler.


    ```java
    add(new MouseAdapter() {
        public void mouseClickd(MouseEvent e) {
            // ...
        }
    });
    ```
    In the following modified example, the function name is spelled correctly. It is also preceded by the `@Override` annotation, which will cause the compiler to display an error if there is not a function of the same name to be overridden.


    ```java
    add(new MouseAdapter() {
        @Override
        public void mouseClicked(MouseEvent e) {
            // ...
        }
    });
    ```

    ## References
    * D. Flanagan, *Java Foundation Classes in a Nutshell*, Chapter 26. O'Reilly, 1999.
    * Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).
    * The Java Tutorials: [Event Adapters](https://docs.oracle.com/javase/tutorial/uiswing/events/generalrules.html#eventAdapters).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Inheritance/NoNonFinalInConstructor.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Inheritance/NoNonFinalInConstructor.bqrs
  metadata:
    name: Non-final method invocation in constructor
    description: |-
      If a constructor calls a method that is overridden in a subclass, the result can be
                    unpredictable.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/non-final-call-in-constructor
    tags: |-
      reliability
             correctness
             logic
  queryHelp: "# Non-final method invocation in constructor\nIf a constructor calls\
    \ a method that is overridden in a subclass, it can cause the overriding method\
    \ in the subclass to be called before the subclass has been initialized. This\
    \ can lead to unexpected results.\n\n\n## Recommendation\nDo not call a non-final\
    \ method from within a constructor if that method could be overridden in a subclass.\n\
    \n\n## Example\nIn the following example, executing `new Sub(\"test\")` results\
    \ in a `NullPointerException`. This is because the subclass constructor implicitly\
    \ calls the superclass constructor, which in turn calls the overridden `init`\
    \ method before the field `s` is initialized in the subclass constructor.\n\n\n\
    ```java\npublic class Super {\n\tpublic Super() {\n\t\tinit();\n\t}\n\t\n\tpublic\
    \ void init() {\n\t}\n}\n\npublic class Sub extends Super {\n\tString s;\n\tint\
    \ length;\n\n\tpublic Sub(String s) {\n\t\tthis.s = s==null ? \"\" : s;\n\t}\n\
    \t\n\t@Override\n\tpublic void init() {\n\t\tlength = s.length();\n\t}\n}\n```\n\
    To avoid this problem:\n\n* The `init` method in the super constructor should\
    \ be made `final` or `private`.\n* The initialization that is performed in the\
    \ overridden `init` method in the subclass can be moved to the subclass constructor\
    \ itself, or delegated to a separate final or private method that is called from\
    \ within the subclass constructor.\n\n## References\n* J. Bloch, *Effective Java\
    \ (second edition)*, pp. 89&ndash;90. Addison-Wesley, 2008.\n* The Java Tutorials:\
    \ [Writing Final Classes and Methods](https://docs.oracle.com/javase/tutorial/java/IandI/final.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/ContainerSizeCmpZero.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/ContainerSizeCmpZero.bqrs
  metadata:
    name: Container size compared to zero
    description: Comparing the size of a container to zero with this operator will
      always return the same value.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/test-for-negative-container-size
    tags: |-
      reliability
             correctness
             logic
  queryHelp: |
    # Container size compared to zero
    A map, collection, string or array will always have size of at least zero. Checking that an object of one of these types has size greater than or equal to zero will always be true, while checking that it has size less than zero will always be false.


    ## Recommendation
    For collections, maps and strings, if the intention was to check whether the object was empty, is it preferred to use the `isEmpty()` method. For arrays, check that the `length` field is greater than (**not** equal to) zero.


    ## Example
    The following example shows creation of a file guarded by comparison of a string length with zero. This can result in the attempted creation of a file with an empty name.


    ```java
    import java.io.File;

    class ContainerSizeCmpZero
    {
        private static File MakeFile(String filename) {
        if(filename != null && filename.length() >= 0) {
            return new File(filename);
        }
        return new File("default.name");
        }
    }

    ```
    In the following revised example, the check against zero has been replaced with a call to `isEmpty()`. This correctly guards against the attempted creation of a file with an empty name.


    ```java
    import java.io.File;

    class ContainerSizeCmpZero
    {
        private static File MakeFile(String filename) {
        if(filename != null && !filename.isEmpty()) {
            return new File(filename);
        }
        return new File("default.name");
        }
    }

    ```

    ## References
    * Java API Specification: [ Collection.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html#isEmpty()), [ Map.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#isEmpty()), [ String.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#isEmpty()).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/ContradictoryTypeChecks.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/ContradictoryTypeChecks.bqrs
  metadata:
    name: Contradictory type checks
    description: |-
      Contradictory dynamic type checks in `instanceof` expressions
                    and casts may cause dead code or even runtime errors, and usually
                    indicate a logic error.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/contradictory-type-checks
    tags: |-
      correctness
             logic
  queryHelp: "# Contradictory type checks\nIf an `instanceof` expression occurs in\
    \ a position where the type test is guaranteed to return `false`, this is often\
    \ due to a typo or logical mistake. It also suggests that the surrounding code\
    \ is not well tested, or possibly even dead.\n\nSimilarly, a cast that is guaranteed\
    \ to fail usually indicates badly tested or dead code.\n\n\n## Recommendation\n\
    Inspect the surrounding code for logical errors.\n\n\n## Example\nIn the following\
    \ example, method `getKind` first checks whether its argument `x` is an instance\
    \ of class `Mammal`, and then whether it is an instance of class `Tiger`.\n\n\n\
    ```java\nString getKind(Animal a) {\n\tif (a instanceof Mammal) {\n\t\treturn\
    \ \"Mammal\";\n\t} else if (a instanceof Tiger) {\n\t\treturn \"Tiger!\";\n\t\
    } else {\n\t\treturn \"unknown\";\n\t}\n}\n```\nIf `Tiger` is a subclass of `Mammal`,\
    \ then the second `instanceof` check can never evaluate to `true`. Clearly, the\
    \ two conditions should be swapped:\n\n\n```java\nString getKind(Animal a) {\n\
    \tif (a instanceof Tiger) {\n\t\treturn \"Tiger!\";\n\t} else if (a instanceof\
    \ Mammal) {\n\t\treturn \"Mammal\";\n\t} else {\n\t\treturn \"unknown\";\n\t}\n\
    }\n```\n\n## References\n* Java Language Specification: [Type Comparison Operator\
    \ instanceof](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.20.2).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/DangerousNonCircuitLogic.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/DangerousNonCircuitLogic.bqrs
  metadata:
    name: Dangerous non-short-circuit logic
    description: |-
      Using a bitwise logical operator on a boolean where a conditional-and or
                    conditional-or operator is intended may yield the wrong result or
                    cause an exception.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/non-short-circuit-evaluation
    tags: |-
      reliability
             readability
             external/cwe/cwe-691
  queryHelp: "# Dangerous non-short-circuit logic\nUsing a bitwise logical operator\
    \ (`&` or `|`) on a boolean where a conditional-and or conditional-or operator\
    \ (`&&` or `||`) is intended may yield the wrong result or cause an exception.\
    \ This is especially true if the left-hand operand is a guard for the right-hand\
    \ operand.\n\nTypically, as in the example below, this kind of defect is introduced\
    \ by simply mistyping the intended logical operator rather than any conceptual\
    \ mistake by the programmer.\n\n\n## Recommendation\nIf the right-hand side of\
    \ an expression is only intended to be evaluated if the left-hand side evaluates\
    \ to `true`, use a conditional-and.\n\nSimilarly, if the right-hand side of an\
    \ expression is only intended to be evaluated if the left-hand side evaluates\
    \ to `false`, use a conditional-or.\n\n\n## Example\nIn the following example,\
    \ the `hasForename` method is implemented correctly. For a forename to be valid\
    \ it must be a non-null string with a non-zero length. The method has two expressions\
    \ (`forename != null` and `forename.length() > 0`) to check these two properties.\
    \ The second check is executed only if the first succeeds, because they are combined\
    \ using a conditional-and operator (`&&`).\n\nIn contrast, although `hasSurname`\
    \ looks almost the same, it contains a defect. Again there are two tests (`surname\
    \ != null` and `surname.length() > 0`), but they are linked by a bitwise logical\
    \ operator (`&`). Both sides of a bitwise logical operator are *always* evaluated,\
    \ so if `surname` is `null` the `hasSurname` method throws a `NullPointerException`.\
    \ To fix the defect, change `&` to `&&`.\n\n\n```java\npublic class Person\n{\n\
    \tprivate String forename;\n\tprivate String surname;\n\n\tpublic boolean hasForename()\
    \ {\n\t\treturn forename != null && forename.length() > 0;  // GOOD: Conditional-and\
    \ operator\n\t}\n\n\tpublic boolean hasSurname() {\n\t\treturn surname != null\
    \ & surname.length() > 0;  // BAD: Bitwise AND operator\n\t}\n\n\t// ...\n}\n\
    ```\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls,\
    \ and Corner Cases*, Puzzle 42. Addison-Wesley, 2005.\n* Java Language Specification:\
    \ [15.22.2 Boolean Logical Operators &amp;, ^, and |](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.2),\
    \ [15.23 Conditional-And Operator &amp;&amp;](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.23),\
    \ [15.24 Conditional-Or Operator ||](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.24).\n\
    * Common Weakness Enumeration: [CWE-691](https://cwe.mitre.org/data/definitions/691.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/EqualsTypo.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/EqualsTypo.bqrs
  metadata:
    name: Typo in equals
    description: A method named 'equal' may be intended to be named 'equals'.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/equals-typo
    tags: |-
      maintainability
             readability
             naming
  queryHelp: "# Typo in equals\nA method named `equal` may be a typographical error.\
    \ `equals` may have been intended instead.\n\n\n## Recommendation\nEnsure that\
    \ any such method is intended to have this name. Even if it is, it may be better\
    \ to rename it to avoid confusion with the inherited method `Object.equals`.\n\
    \n\n## Example\nThe following example shows a method named `equal`. It may be\
    \ better to rename it.\n\n\n```java\npublic class Complex\n{\n\tprivate double\
    \ real;\n\tprivate double complex;\n\n\t// ...\n\n\tpublic boolean equal(Object\
    \ obj) {  // The method is named 'equal'.\n\t\tif (!getClass().equals(obj.getClass()))\n\
    \t\t\treturn false;\n\t\tComplex other = (Complex) obj;\n\t\treturn real == other.real\
    \ && complex == other.complex;\n\t}\n}\n```\n\n## References\n* Java API Specification:\
    \ [ equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/HashCodeTypo.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/HashCodeTypo.bqrs
  metadata:
    name: Typo in hashCode
    description: A method named 'hashcode' may be intended to be named 'hashCode'.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/hashcode-typo
    tags: |-
      maintainability
             readability
             naming
  queryHelp: "# Typo in hashCode\nA method named `hashcode` may be a typographical\
    \ error. `hashCode` (different capitalization) may have been intended instead.\n\
    \n\n## Recommendation\nEnsure that any such method is intended to have this name.\
    \ Even if it is, it may be better to rename it to avoid confusion with the inherited\
    \ method `Object.hashCode`.\n\n\n## Example\nThe following example shows a method\
    \ named `hashcode`. It may be better to rename it.\n\n\n```java\npublic class\
    \ Person\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String\
    \ surname;\n\n\t// ...\n\n\tpublic int hashcode() {  // The method is named 'hashcode'.\n\
    \t\tint hash = 23 * title.hashCode();\n\t\thash ^= 13 * forename.hashCode();\n\
    \t\treturn hash ^ surname.hashCode();\n\t}\n}\n```\n\n## References\n* Java API\
    \ Specification: [ Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/MissingFormatArg.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/MissingFormatArg.bqrs
  metadata:
    name: Missing format argument
    description: |-
      A format call with an insufficient number of arguments causes
                    an 'IllegalFormatException'.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/missing-format-argument
    tags: |-
      correctness
             external/cwe/cwe-685
  queryHelp: |
    # Missing format argument
    When formatting strings using `printf`-style format strings, one must ensure that the number of supplied arguments matches the number of arguments referenced by the format string. Additional arguments will be thrown away silently, which may not be the intended behavior, and too few arguments will cause an `IllegalFormatException`.

    Format strings are used by the `format` method on the classes `String`, `Formatter`, `Console`, `PrintWriter`, and `PrintStream`. Several of these classes also supply the method alias `printf`. The class `Console` has two additional methods, `readLine` and `readPassword`, that also use format strings.


    ## Recommendation
    Supply the correct number of arguments to the format method, or change the format string to use the correct arguments.


    ## Example
    The following example supplies only one argument to be formatted, but the format string refers to two arguments, so this will throw an `IllegalFormatException`.


    ```java
    System.out.format("First string: %s Second string: %s", "Hello world");

    ```

    ## References
    * Java API Specification: [Format string syntax](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax), [Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html), [Class Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html), [Class Console](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Console.html), [Class PrintWriter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintWriter.html), [Class PrintStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html).
    * SLF4J library: [org.slf4j.Logger](https://www.slf4j.org/apidocs/org/slf4j/Logger.html).
    * Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/MissingSpaceTypo.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/MissingSpaceTypo.bqrs
  metadata:
    name: Missing space in string literal
    description: |-
      Joining strings at compile-time to construct a string literal
                    so that two words are concatenated without a separating space
                    usually indicates a text error.
    kind: problem
    problem.severity: recommendation
    precision: very-high
    id: java/missing-space-in-concatenation
    tags: readability
  queryHelp: |
    # Missing space in string literal
    Splitting a long string literal over multiple lines can often aid readability, but this also makes it difficult to notice whether a space is missing where the strings are concatenated.


    ## Recommendation
    Check the string literal to see whether it has the intended text. In particular, look for missing spaces near line breaks.


    ## Example
    The following example shows a text literal that is split over two lines and omits a space character between the two words at the line break.


    ```java
    String s = "This text is" +
      "missing a space.";

    ```

    ## References
    * Java Language Specification: [String Literals](https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.5).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/SelfAssignment.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/SelfAssignment.bqrs
  metadata:
    name: Self assignment
    description: Assigning a variable to itself has no effect.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/redundant-assignment
    tags: |-
      reliability
             correctness
             logic
  queryHelp: |
    # Self assignment
    Assigning a variable to itself does not have any effect. Therefore, such an assignment is either completely unnecessary, or it indicates a typo or a similar mistake.


    ## Recommendation
    If the assignment is unnecessary, remove it. If the assignment indicates a typo or a similar mistake, correct the mistake.


    ## Example
    The following example shows part of a method that is intended to make a copy of an existing `MotionEvent` without preserving its history. On line 8, `o.mFlags` is assigned to itself. Given that the statement is surrounded by statements that transfer information from the fields of `o` to the fields of the new event, `ev`, the statement is clearly a mistake. To correct this, the `mFlags` value should be assigned to `ev.mFlags` instead, as shown in the corrected method.


    ```java
    static public MotionEvent obtainNoHistory(MotionEvent o) {
        MotionEvent ev = obtain(o.mNumPointers, 1);
        ev.mDeviceId = o.mDeviceId;
        o.mFlags = o.mFlags;  // Variable is assigned to itself
        ...
    }

    static public MotionEvent obtainNoHistory(MotionEvent o) {
        MotionEvent ev = obtain(o.mNumPointers, 1);
        ev.mDeviceId = o.mDeviceId;
        ev.mFlags = o.mFlags;  // Variable is assigned correctly
        ...
    }

    ```

    ## References
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/StringBufferCharInit.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/StringBufferCharInit.bqrs
  metadata:
    name: Character passed to StringBuffer or StringBuilder constructor
    description: |-
      A character value is passed to the constructor of 'StringBuffer' or 'StringBuilder'. This value will
                    be converted to an integer and interpreted as the buffer's initial capacity, which is probably not intended.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/string-buffer-char-init
    tags: |-
      reliability
             maintainability
  queryHelp: "# Character passed to StringBuffer or StringBuilder constructor\nPassing\
    \ a character to the constructor of `StringBuffer` or `StringBuilder` is probably\
    \ intended to insert the character into the newly created buffer. In fact, however,\
    \ the character value is converted to an integer and interpreted as the buffer's\
    \ initial capacity, which may yield unexpected results.\n\n\n## Example\nThe following\
    \ example shows a class representing points in two-dimensional Cartesian coordinates.\
    \ The `toString` method uses a `StringBuffer` to construct a human-readable representation\
    \ of the form `(x, y)`, where `x` and `y` are the point's coordinates.\n\nHowever,\
    \ the opening parenthesis is passed to the `StringBuffer` constructor as character\
    \ literal. Instead of being used to initialise the buffer's contents, the character\
    \ is converted to the integer value 40 and interpreted as the buffer's initial\
    \ capacity. Thus, the string representation returned by `toString` will be missing\
    \ the opening parenthesis. (Note that passing a character to `append`, on the\
    \ other hand, is unproblematic.)\n\n\n```java\nclass Point {\n\tprivate double\
    \ x, y;\n\t\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y\
    \ = y;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer res\
    \ = new StringBuffer('(');\n\t\tres.append(x);\n\t\tres.append(\", \");\n\t\t\
    res.append(y);\n\t\tres.append(')');\n\t\treturn res.toString();\n\t}\n}\n\n```\n\
    \n## Recommendation\nIf the character used to initialize the buffer is a character\
    \ literal, simply replace it with the corresponding string literal. So, in our\
    \ example, replace `new StringBuffer('(')` with `new StringBuffer(\"(\")`. If\
    \ the character is not a literal value, use method `String.valueOf` to convert\
    \ it to a string.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers:\
    \ Traps, Pitfalls, and Corner Cases*, Puzzle 23. Addison-Wesley, 2005.\n* NetBeans\
    \ IDE: [Java Hints](https://web.archive.org/web/20210117160808/http://wiki.netbeans.org/Java_Hints)\n\
    * PMD: [Rule StringBufferInstantiationWithChar](https://pmd.github.io/latest/pmd_rules_java_errorprone.html#stringbufferinstantiationwithchar)\n\
    * Java API: [StringBuffer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html),\
    \ [java.lang.StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/SuspiciousDateFormat.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/SuspiciousDateFormat.bqrs
  metadata:
    name: Suspicious date format
    description: Using a data format that includes both 'M' and 'Y' is likely to give
      unexpected results.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/suspicious-date-format
    tags: correctness
  queryHelp: |
    # Suspicious date format
    The Java `SimpleDateFormat` class provides many placeholders so that you can define precisely the date format required. However, this also makes it easy to define a pattern that doesn't behave exactly as you intended. The most common mistake is to use the `Y` placeholder (which represents the ISO 8601 week year), rather than `y` (which represents the actual year). In this case, the date reported will appear correct until the end of the year, when the "week year" may differ from the actual year.


    ## Recommendation
    Ensure the format pattern's use of `Y` is correct, and if not replace it with `y`.


    ## Example
    The following example uses the date format `YYYY-MM-dd`. On the 30th of December 2019, this code will output "2020-12-30", rather than the intended "2019-12-30".


    ```java
    System.out.println(new SimpleDateFormat("YYYY-MM-dd").format(new Date()));

    ```
    The correct pattern in this case would be `yyyy-MM-dd` instead of `YYYY-MM-dd`.


    ## References
    * Java API Specification: [SimpleDateFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/SimpleDateFormat.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/ToStringTypo.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/ToStringTypo.bqrs
  metadata:
    name: Typo in toString
    description: A method named 'tostring' may be intended to be named 'toString'.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/tostring-typo
    tags: |-
      maintainability
             readability
             naming
  queryHelp: "# Typo in toString\nA method named `tostring` may be a typographical\
    \ error. `toString` (different capitalization) may have been intended instead.\n\
    \n\n## Recommendation\nEnsure that any such method is intended to have this name.\
    \ Even if it is, it may be better to rename it to avoid confusion with the inherited\
    \ method `Object.toString`.\n\n\n## Example\nThe following example shows a method\
    \ named `tostring`. It may be better to rename it.\n\n\n```java\npublic class\
    \ Customer\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate\
    \ String surname;\n\n\t// ...\n\n\tpublic String tostring() {  // The method is\
    \ named 'tostring'.\n\t\treturn title + \" \" + forename + \" \" + surname;\n\t\
    }\n}\n```\n\n## References\n* Java API Specification: [ Object.toString](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Likely Typos/UnusedFormatArg.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Likely Typos/UnusedFormatArg.bqrs
  metadata:
    name: Unused format argument
    description: |-
      A format call with a format string that refers to fewer
                    arguments than the number of supplied arguments will silently
                    ignore the additional arguments.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/unused-format-argument
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-685
  queryHelp: |
    # Unused format argument
    When formatting strings using `printf`-style format strings, one must ensure that the number of supplied arguments matches the number of arguments referenced by the format string. Additional arguments will be thrown away silently, which may not be the intended behavior, and too few arguments will cause an `IllegalFormatException`.

    Format strings are used by the `format` method on the classes `String`, `Formatter`, `Console`, `PrintWriter`, and `PrintStream`. Several of these classes also supply the method alias `printf`. The class `Console` has two additional methods, `readLine` and `readPassword`, that also use format strings.


    ## Recommendation
    Change the format string to use all the arguments, or remove the unnecessary arguments.


    ## Example
    The following example supplies three arguments to be formatted, but the format string only refers to two arguments, so this will silently ignore the third argument.


    ```java
    System.out.format("First string: %s Second string: %s", "Hello", "world", "!");

    ```

    ## References
    * Java API Specification: [Format string syntax](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax), [Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html), [Class Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html), [Class Console](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Console.html), [Class PrintWriter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintWriter.html), [Class PrintStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html).
    * SLF4J library: [org.slf4j.Logger](https://www.slf4j.org/apidocs/org/slf4j/Logger.html).
    * Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Nullness/NullAlways.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Nullness/NullAlways.bqrs
  metadata:
    name: Dereferenced variable is always null
    description: Dereferencing a variable whose value is 'null' causes a 'NullPointerException'.
    kind: problem
    problem.severity: error
    precision: very-high
    id: java/dereferenced-value-is-always-null
    tags: |-
      reliability
             correctness
             exceptions
             external/cwe/cwe-476
  queryHelp: "# Dereferenced variable is always null\nIf a variable is dereferenced,\
    \ and the variable has a `null` value on all possible execution paths leading\
    \ to the dereferencing, the dereferencing is guaranteed to result in a `NullPointerException`.\n\
    \nA variable may also be implicitly dereferenced if its type is a boxed primitive\
    \ type, and the variable occurs in a context in which implicit unboxing occurs.\
    \ Note that the conditional operator unboxes its second and third operands when\
    \ one of them is a primitive type and the other is the corresponding boxed type.\n\
    \n\n## Recommendation\nEnsure that the variable does not have a `null` value when\
    \ it is dereferenced.\n\n\n## Example\nIn the following examples, the condition\
    \ `!dir.exists()` is only executed if `dir` is `null`. The second example guards\
    \ the expression correctly by using `&&` instead of `||`.\n\n\n```java\npublic\
    \ void createDir(File dir) {\n\tif (dir != null || !dir.exists()) // BAD\n\t\t\
    dir.mkdir();\n}\n\npublic void createDir(File dir) {\n\tif (dir != null && !dir.exists())\
    \ // GOOD\n\t\tdir.mkdir();\n}\n\n```\n\n## References\n* The Java Tutorials:\
    \ [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).\n\
    * Java Language Specification: [Conditional Operator ? :](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.25).\n\
    * Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Nullness/NullExprDeref.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Nullness/NullExprDeref.bqrs
  metadata:
    name: Dereferenced expression may be null
    description: |-
      Dereferencing an expression whose value may be 'null' may cause a
                    'NullPointerException'.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/dereferenced-expr-may-be-null
    tags: |-
      reliability
             correctness
             exceptions
             external/cwe/cwe-476
  queryHelp: |
    # Dereferenced expression may be null
    Dereferencing a `null` value leads to a `NullPointerException`.

    An expression may be implicitly dereferenced if its type is a boxed primitive type, and it occurs in a context in which implicit unboxing occurs.


    ## Recommendation
    Ensure that the expression does not have a `null` value when it is dereferenced. Use boxed types as appropriate to hold values that are potentially `null`.


    ## Example
    In the following example implicit unboxing can cause a `NullPointerException` if `helper` is `null`.


    ```java
    public int getID() {
        return helper == null ? null : helper.getID();
    }

    ```
    If the method is intended to return `null`, the return type should be changed to `Integer`.


    ## References
    * The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).
    * Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Nullness/NullMaybe.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Nullness/NullMaybe.bqrs
  metadata:
    name: Dereferenced variable may be null
    description: |-
      Dereferencing a variable whose value may be 'null' may cause a
                    'NullPointerException'.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/dereferenced-value-may-be-null
    tags: |-
      reliability
             correctness
             exceptions
             external/cwe/cwe-476
             non-local
  queryHelp: "# Dereferenced variable may be null\nIf a variable is dereferenced,\
    \ and the variable may have a `null` value on some execution paths leading to\
    \ the dereferencing, the dereferencing may result in a `NullPointerException`.\n\
    \nA variable may also be implicitly dereferenced if its type is a boxed primitive\
    \ type, and the variable occurs in a context in which implicit unboxing occurs.\
    \ Note that the conditional operator unboxes its second and third operands when\
    \ one of them is a primitive type and the other is the corresponding boxed type.\n\
    \n\n## Recommendation\nEnsure that the variable does not have a `null` value when\
    \ it is dereferenced.\n\n\n## Example\nIn the following example, the use of the\
    \ conditional operator causes implicit unboxing, since the integer literal has\
    \ type `int`. If the parameter `p` is ever `null` then a `NullPointerException`\
    \ will occur.\n\n\n```java\npublic Integer f(Integer p) {\n\treturn true ? p :\
    \ 5;\n}\n\n```\nIf the implicit unboxing is unintentional, it can be prevented\
    \ by making sure that both branches of the conditional operator have the same\
    \ type.\n\n\n## References\n* The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).\n\
    * Java Language Specification: [Conditional Operator ? :](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.25).\n\
    * Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Reflection/AnnotationPresentCheck.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Reflection/AnnotationPresentCheck.bqrs
  metadata:
    name: AnnotationPresent check
    description: |-
      If an annotation has not been annotated with a 'RUNTIME' retention policy, checking
                    for its presence at runtime is not possible.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/ineffective-annotation-present-check
    tags: |-
      correctness
             logic
  queryHelp: "# AnnotationPresent check\nTo be able to use the `isAnnotationPresent`\
    \ method on an `AnnotatedElement` at runtime, an annotation must be explicitly\
    \ annotated with a `RUNTIME` retention policy. Otherwise, the annotation is not\
    \ retained at runtime and cannot be observed using reflection.\n\n\n## Recommendation\n\
    Explicitly annotate annotations with a `RUNTIME` retention policy if you want\
    \ to observe their presence using `AnnotatedElement.isAnnotationPresent` at runtime.\n\
    \n\n## Example\nIn the following example, the call to `isAnnotationPresent` returns\
    \ `false` because the annotation cannot be observed using reflection.\n\n\n```java\n\
    public class AnnotationPresentCheck {\n\tpublic static @interface UntrustedData\
    \ { }\n\n\t@UntrustedData\n\tpublic static String getUserData() {\n\t\tScanner\
    \ scanner = new Scanner(System.in);\n\t\treturn scanner.nextLine();\n\t}\n\n\t\
    public static void main(String[] args) throws NoSuchMethodException, SecurityException\
    \ {\n\t\tString data = getUserData();\n\t\tMethod m = AnnotationPresentCheck.class.getMethod(\"\
    getUserData\");\n\t\tif(m.isAnnotationPresent(UntrustedData.class)) {  // Returns\
    \ 'false'\n\t\t\tSystem.out.println(\"Not trusting data from user.\");\n\t\t}\n\
    \t}\n}\n```\nTo correct this, the annotation is annotated with a `RUNTIME` retention\
    \ policy.\n\n\n```java\npublic class AnnotationPresentCheckFix {\n\t@Retention(RetentionPolicy.RUNTIME)\
    \  // Annotate the annotation\n\tpublic static @interface UntrustedData { }\n\n\
    \t@UntrustedData\n\tpublic static String getUserData() {\n\t\tScanner scanner\
    \ = new Scanner(System.in);\n\t\treturn scanner.nextLine();\n\t}\n\n\tpublic static\
    \ void main(String[] args) throws NoSuchMethodException, SecurityException {\n\
    \t\tString data = getUserData();\n\t\tMethod m = AnnotationPresentCheckFix.class.getMethod(\"\
    getUserData\");\n\t\tif(m.isAnnotationPresent(UntrustedData.class)) {  // Returns\
    \ 'true'\n\t\t\tSystem.out.println(\"Not trusting data from user.\");\n\t\t}\n\
    \t}\n}\n```\n\n## References\n* Java API Specification: [Annotation Type Retention](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/Retention.html),\
    \ [RetentionPolicy.RUNTIME](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/RetentionPolicy.html#RUNTIME),\
    \ [AnnotatedElement.isAnnotationPresent()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/reflect/AnnotatedElement.html#isAnnotationPresent(java.lang.Class)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Resource Leaks/CloseReader.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Resource Leaks/CloseReader.bqrs
  metadata:
    name: Potential input resource leak
    description: |-
      A resource that is opened for reading but not closed may cause a resource
                    leak.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/input-resource-leak
    tags: |-
      efficiency
             correctness
             resources
             external/cwe/cwe-404
             external/cwe/cwe-772
  queryHelp: "# Potential input resource leak\nA subclass of `Reader` or `InputStream`\
    \ that is opened for reading but not closed may cause a resource leak.\n\n\n##\
    \ Recommendation\nEnsure that the resource is always closed to avoid a resource\
    \ leak. Note that, because of exceptions, it is safest to close a resource in\
    \ a `finally` block. (However, this is unnecessary for subclasses of `CharArrayReader`,\
    \ `StringReader` and `ByteArrayInputStream`.)\n\nFor Java 7 or later, the recommended\
    \ way to close resources that implement `java.lang.AutoCloseable` is to declare\
    \ them within a `try-with-resources` statement, so that they are closed implicitly.\n\
    \n\n## Example\nIn the following example, the resource `br` is opened but not\
    \ closed.\n\n\n```java\npublic class CloseReader {\n\tpublic static void main(String[]\
    \ args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new FileReader(\"\
    C:\\\\test.txt\"));\n\t\tSystem.out.println(br.readLine());\n\t\t// ...\n\t}\n\
    }\n```\nIn the following example, the resource `br` is opened in a `try` block\
    \ and later closed in a `finally` block.\n\n\n```java\npublic class CloseReaderFix\
    \ {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader\
    \ br = null;\n\t\ttry {\n\t\t\tbr = new BufferedReader(new FileReader(\"C:\\\\\
    test.txt\"));\n\t\t\tSystem.out.println(br.readLine());\n\t\t}\n\t\tfinally {\n\
    \t\t\tif(br != null)\n\t\t\t\tbr.close();  // 'br' is closed\n\t\t}\n\t\t// ...\n\
    \t}\n}\n```\nNote that nested class instance creation expressions of `Reader`s\
    \ or `InputStream`s are not safe to use if the constructor of the outer expression\
    \ may throw an exception. In the following example, the `InputStreamReader` may\
    \ throw an exception, in which case the inner `FileInputStream` is not closed.\n\
    \n\n```java\npublic class CloseReaderNested {\n\tpublic static void main(String[]\
    \ args) throws IOException {\n\t\tInputStreamReader reader = null;\n\t\ttry {\n\
    \t\t\t// InputStreamReader may throw an exception, in which case the ...\n\t\t\
    \treader = new InputStreamReader(\n\t\t\t\t\t// ... FileInputStream is not closed\
    \ by the finally block\n\t\t\t\t\tnew FileInputStream(\"C:\\\\test.txt\"), \"\
    UTF-8\");\n\t\t\tSystem.out.println(reader.read());\n\t\t}\n\t\tfinally {\n\t\t\
    \tif (reader != null)\n\t\t\t\treader.close();\n\t\t}\n\t}\n}\n```\nIn this case,\
    \ the inner expression needs to be assigned to a local variable and closed separately,\
    \ as shown below.\n\n\n```java\npublic class CloseReaderNestedFix {\n\tpublic\
    \ static void main(String[] args) throws IOException {\n\t\tFileInputStream fis\
    \ = null;\n\t\tInputStreamReader reader = null;\n\t\ttry {\n\t\t\tfis = new FileInputStream(\"\
    C:\\\\test.txt\");\n\t\t\treader = new InputStreamReader(fis);\n\t\t\tSystem.out.println(reader.read());\n\
    \t\t}\n\t\tfinally {\n\t\t\tif (reader != null)\n\t\t\t\treader.close();  // 'reader'\
    \ is closed\n\t\t\tif (fis != null)\n\t\t\t\tfis.close();  // 'fis' is closed\n\
    \t\t}\n\t}\n}\n```\n\n## References\n* IBM developerWorks: [Java theory and practice:\
    \ Good housekeeping practices](https://web.archive.org/web/20201109041839/http://www.ibm.com/developerworks/java/library/j-jtp03216/index.html).\n\
    * The Java Tutorials: [The try-with-resources Statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).\n\
    * Common Weakness Enumeration: [CWE-404](https://cwe.mitre.org/data/definitions/404.html).\n\
    * Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Resource Leaks/CloseSql.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Resource Leaks/CloseSql.bqrs
  metadata:
    name: Potential database resource leak
    description: A database resource that is opened but not closed may cause a resource
      leak.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/database-resource-leak
    tags: |-
      correctness
             resources
             external/cwe/cwe-404
             external/cwe/cwe-772
  queryHelp: "# Potential database resource leak\nA database resource in the `java.sql`\
    \ package that is opened but not closed may cause a resource leak and ultimately\
    \ resource exhaustion.\n\n\n## Recommendation\nEnsure that the resource is always\
    \ closed to avoid a resource leak. Note that, because of exceptions, it is safest\
    \ to close a resource in a `finally` block.\n\nFor Java 7 or later, the recommended\
    \ way to close resources that implement `java.lang.AutoCloseable` is to declare\
    \ them within a `try-with-resources` statement, so that they are closed implicitly.\n\
    \n\n## Example\nIn the following example, the resources `stmt` and `rs` are opened\
    \ but not closed.\n\n\n```java\npublic class CloseSql {\n\tpublic static void\
    \ runQuery(Connection con, String query) throws SQLException {\n\t\tStatement\
    \ stmt = con.createStatement();\n\t\tResultSet rs = stmt.executeQuery(query);\n\
    \t\twhile (rs.next()) {\n\t\t\t// process result set\n\t\t}\n\t}\n}\n```\nIn the\
    \ following example, the resources `stmt` and `rs` are declared within a `try-with-resources`\
    \ block and are thus closed implicitly.\n\n\n```java\npublic class CloseSqlGood\
    \ {\n\tpublic static void runQuery(Connection con, String query) throws SQLException\
    \ {\n\t\ttry (Statement stmt = con.createStatement();\n\t\t\t\tResultSet rs =\
    \ stmt.executeQuery(query)) {\n\t\t\twhile (rs.next()) {\n\t\t\t\t// process result\
    \ set\n\t\t\t}\n\t\t}\n\t}\n}\n```\nNote that the `Connection` that is passed\
    \ into the method is a long-lived object that was created elsewhere and therefore\
    \ need not be closed locally. It should instead be closed by the code that created\
    \ it or by a server shutdown procedure, as appropriate.\n\n\n## References\n*\
    \ IBM developerWorks: [Java theory and practice: Good housekeeping practices](https://web.archive.org/web/20201109041839/http://www.ibm.com/developerworks/java/library/j-jtp03216/index.html).\n\
    * The Java Tutorials: [The try-with-resources Statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).\n\
    * Common Weakness Enumeration: [CWE-404](https://cwe.mitre.org/data/definitions/404.html).\n\
    * Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Resource Leaks/CloseWriter.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Resource Leaks/CloseWriter.bqrs
  metadata:
    name: Potential output resource leak
    description: |-
      A resource that is opened for writing but not closed may cause a resource
                    leak.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/output-resource-leak
    tags: |-
      efficiency
             correctness
             resources
             external/cwe/cwe-404
             external/cwe/cwe-772
  queryHelp: "# Potential output resource leak\nA subclass of `Writer` or `OutputStream`\
    \ that is opened for writing but not properly closed later may cause a resource\
    \ leak.\n\n\n## Recommendation\nEnsure that the resource is always closed to avoid\
    \ a resource leak. Note that, because of exceptions, it is safest to close a resource\
    \ properly in a `finally` block. (However, this is unnecessary for subclasses\
    \ of `CharArrayWriter`, `StringWriter` and `ByteArrayOutputStream`.)\n\nFor Java\
    \ 7 or later, the recommended way to close resources that implement `java.lang.AutoCloseable`\
    \ is to declare them within a `try-with-resources` statement, so that they are\
    \ closed implicitly.\n\n\n## Example\nIn the following example, the resource `bw`\
    \ is opened but not closed.\n\n\n```java\npublic class CloseWriter {\n\tpublic\
    \ static void main(String[] args) throws IOException {\n\t\tBufferedWriter bw\
    \ = new BufferedWriter(new FileWriter(\"C:\\\\test.txt\"));\n\t\tbw.write(\"Hello\
    \ world!\");\n\t\t// ...\n\t}\n}\n```\nIn the following example, the resource\
    \ `bw` is opened in a `try` block and later closed in a `finally` block.\n\n\n\
    ```java\npublic class CloseWriterFix {\n\tpublic static void main(String[] args)\
    \ throws IOException {\n\t\tBufferedWriter bw = null;\n\t\ttry {\n\t\t\tbw = new\
    \ BufferedWriter(new FileWriter(\"C:\\\\test.txt\"));\n\t\t\tbw.write(\"Hello\
    \ world!\");\n\t\t}\n\t\tfinally {\n\t\t\tif(bw != null)\n\t\t\t\tbw.close();\
    \  // 'bw' is closed\n\t\t}\n\t\t// ...\n\t}\n}\n```\nNote that nested class instance\
    \ creation expressions of `Writer`s or `OutputStream`s are not safe to use if\
    \ the constructor of the outer expression may throw an exception. In the following\
    \ example, the `OutputStreamWriter` may throw an exception, in which case the\
    \ inner `FileOutputStream` is not closed.\n\n\n```java\npublic class CloseWriterNested\
    \ {\n\tpublic static void main(String[] args) throws IOException {\n\t\tOutputStreamWriter\
    \ writer = null;\n\t\ttry {\n\t\t\t// OutputStreamWriter may throw an exception,\
    \ in which case the ...\n\t\t\twriter = new OutputStreamWriter(\n\t\t\t\t\t//\
    \ ... FileOutputStream is not closed by the finally block\n\t\t\t\t\tnew FileOutputStream(\"\
    C:\\\\test.txt\"), \"UTF-8\");\n\t\t\twriter.write(\"Hello world!\");\n\t\t}\n\
    \t\tfinally {\n\t\t\tif (writer != null)\n\t\t\t\twriter.close();\n\t\t}\n\t}\n\
    }\n```\nIn this case, the inner expression needs to be assigned to a local variable\
    \ and closed separately, as shown below.\n\n\n```java\npublic class CloseWriterNestedFix\
    \ {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFileOutputStream\
    \ fos = null;\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\tfos = new\
    \ FileOutputStream(\"C:\\\\test.txt\");\n\t\t\twriter = new OutputStreamWriter(fos);\n\
    \t\t\twriter.write(\"Hello world!\");\n\t\t}\n\t\tfinally {\n\t\t\tif (writer\
    \ != null)\n\t\t\t\twriter.close();  // 'writer' is closed\n\t\t\tif (fos != null)\n\
    \t\t\t\tfos.close();  // 'fos' is closed\n\t\t}\n\t}\n}\n```\n\n## References\n\
    * IBM developerWorks: [Java theory and practice: Good housekeeping practices](https://web.archive.org/web/20201109041839/http://www.ibm.com/developerworks/java/library/j-jtp03216/index.html).\n\
    * The Java Tutorials: [The try-with-resources Statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).\n\
    * Common Weakness Enumeration: [CWE-404](https://cwe.mitre.org/data/definitions/404.html).\n\
    * Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/IncorrectSerializableMethods.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/IncorrectSerializableMethods.bqrs
  metadata:
    name: Serialization methods do not match required signature
    description: |-
      A serialized class that implements 'readObject', 'readObjectNoData' or 'writeObject' but
                    does not use the correct signatures causes the default serialization mechanism to be used.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/wrong-object-serialization-signature
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: "# Serialization methods do not match required signature\nA serializable\
    \ object that defines its own serialization protocol using the methods `readObject`,\
    \ `readObjectNoData` or `writeObject` must use the signature that is expected\
    \ by the Java serialization framework. Otherwise, the default serialization mechanism\
    \ is used.\n\n\n## Recommendation\nMake sure that the signatures of `readObject`,\
    \ `readObjectNoData` and `writeObject` on serializable classes match these expected\
    \ signatures:\n\n\n```java\nprivate void readObject(java.io.ObjectInputStream\
    \ in)\n     throws IOException, ClassNotFoundException;\nprivate void readObjectNoData()\n\
    \     throws ObjectStreamException;\nprivate void writeObject(java.io.ObjectOutputStream\
    \ out)\n     throws IOException;\n```\n\n## Example\nIn the following example,\
    \ `WrongNetRequest` defines `readObject`, `readObjectNoData` and `writeObject`\
    \ using the wrong signatures. However, `NetRequest` defines them correctly.\n\n\
    \n```java\nclass WrongNetRequest implements Serializable {\n\t// BAD: Does not\
    \ match the exact signature required for a custom \n\t// deserialization protocol.\
    \ Will not be called during deserialization.\n\tvoid readObject(ObjectInputStream\
    \ in) {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required\
    \ for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\
    \tvoid readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the\
    \ exact signature required for a custom \n\t// serialization protocol. Will not\
    \ be called during serialization.\n\tprotected void writeObject(ObjectOutputStream\
    \ out) {\n\t\t//...\n\t}\n}\n\nclass NetRequest implements Serializable {\n\t\
    // GOOD: Signature for a custom deserialization implementation.\n\tprivate void\
    \ readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature\
    \ for a custom deserialization implementation.\n\tprivate void readObjectNoData()\
    \ {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom serialization implementation.\n\
    \tprivate void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n```\n\
    \n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n\
    * Oracle Technology Network: [Discover the secrets of the Java Serialization API](https://www.oracle.com/technical-resources/articles/java/serializationapi.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/IncorrectSerialVersionUID.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/IncorrectSerialVersionUID.bqrs
  metadata:
    name: Incorrect serialVersionUID field
    description: |-
      A 'serialVersionUID' field that is declared in a serializable class but is of the
                    wrong type cannot be used by the serialization framework.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/incorrect-serial-version-uid
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: "# Incorrect serialVersionUID field\nA serializable class that uses the\
    \ `serialVersionUID` field to act as an object version number must declare the\
    \ field to be `final`, `static`, and of type `long` for it to be used by the Java\
    \ serialization framework.\n\n\n## Recommendation\nMake sure that the `serialVersionUID`\
    \ field in a serialized class is final, static, and of type `long`.\n\n\n## Example\n\
    In the following example, `WrongNote` defines `serialVersionUID` using the wrong\
    \ type, so that it is not used by the Java serialization framework. However, `Note`\
    \ defines it correctly so that it is used by the framework.\n\n\n```java\nclass\
    \ WrongNote implements Serializable {\n\t// BAD: serialVersionUID must be static,\
    \ final, and 'long'\n\tprivate static final int serialVersionUID = 1;\n\t\n\t\
    //...\n}\n\nclass Note implements Serializable {\n\t// GOOD: serialVersionUID\
    \ is of the correct type\n\tprivate static final long serialVersionUID = 1L;\n\
    }\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n\
    * JavaWorld: [Ensure proper version control for serialized objects](https://www.infoworld.com/article/2071731/ensure-proper-version-control-for-serialized-objects.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/MissingVoidConstructorOnExternalizable.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/MissingVoidConstructorOnExternalizable.bqrs
  metadata:
    name: Externalizable but no public no-argument constructor
    description: |-
      A class that implements 'Externalizable' but does not have a public no-argument
                    constructor causes an 'InvalidClassException' to be thrown.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/missing-no-arg-constructor-on-externalizable
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: |
    # Externalizable but no public no-argument constructor
    A class that implements `java.io.Externalizable` must have a public no-argument constructor. The constructor is used by the Java serialization framework when it creates the object during deserialization. If the class does not define such a constructor, the Java serialization framework throws an `InvalidClassException`.

    The Java Development Kit API documentation for `Externalizable` states:

    > When an `Externalizable` object is reconstructed, an instance is created using the public no-arg constructor, then the `readExternal` method called.


    ## Recommendation
    Make sure that externalizable classes always have a no-argument constructor.


    ## Example
    In the following example, `WrongMemo` does not declare a public no-argument constructor. When the Java serialization framework tries to deserialize the object, an `InvalidClassException` is thrown. However, `Memo` does declare a public no-argument constructor, so that the object is deserialized successfully.


    ```java
    class WrongMemo implements Externalizable {
        private String memo;

        // BAD: No public no-argument constructor is defined. Deserializing this object
        // causes an 'InvalidClassException'.

        public WrongMemo(String memo) {
            this.memo = memo;
        }

        public void writeExternal(ObjectOutput arg0) throws IOException {
            //...
        }
        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
            //...
        }
    }

    class Memo implements Externalizable {
        private String memo;

        // GOOD: Declare a public no-argument constructor, which is used by the
        // serialization framework when the object is deserialized.
        public Memo() {
        }

        public Memo(String memo) {
            this.memo = memo;
        }

        public void writeExternal(ObjectOutput out) throws IOException {
            //...
        }
        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
            //...
        }
    }

    ```

    ## References
    * Java API Specification: [Externalizable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Externalizable.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/MissingVoidConstructorsOnSerializable.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/MissingVoidConstructorsOnSerializable.bqrs
  metadata:
    name: Serializable but no void constructor
    description: |-
      A non-serializable, immediate superclass of a serializable class that does not
                    itself declare an accessible, no-argument constructor causes deserialization to
                    fail.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/missing-no-arg-constructor-on-serializable
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: "# Serializable but no void constructor\nA serializable class that is\
    \ a subclass of a non-serializable class cannot be deserialized if its superclass\
    \ does not declare a no-argument constructor. The Java serialization framework\
    \ uses the no-argument constructor when it initializes the object instance that\
    \ is created during deserialization. Deserialization fails with an `InvalidClassException`\
    \ if its superclass does not declare a no-argument constructor.\n\nThe Java Development\
    \ Kit API documentation states:\n\n> To allow subtypes of non-serializable classes\
    \ to be serialized, the subtype may assume responsibility for saving and restoring\
    \ the state of the supertype's public, protected, and (if accessible) package\
    \ fields. The subtype may assume this responsibility only if the class it extends\
    \ has an accessible no-arg constructor to initialize the class's state. It is\
    \ an error to declare a class `Serializable` if this is not the case. The error\
    \ will be detected at runtime.\n\n\n## Recommendation\nMake sure that every non-serializable\
    \ class that is extended by a serializable class has a no-argument constructor.\n\
    \n\n## Example\nIn the following example, the class `WrongSubItem` cannot be deserialized\
    \ because its superclass `WrongItem` does not declare a no-argument constructor.\
    \ However, the class `SubItem` *can* be serialized because it declares a no-argument\
    \ constructor.\n\n\n```java\nclass WrongItem {\n    private String name;\n\n \
    \   // BAD: This class does not have a no-argument constructor, and throws an\n\
    \    // 'InvalidClassException' at runtime.\n\n    public WrongItem(String name)\
    \ {\n        this.name = name;\n    }\n}\n\nclass WrongSubItem extends WrongItem\
    \ implements Serializable {\n    public WrongSubItem() {\n        super(null);\n\
    \    }\n\n    public WrongSubItem(String name) {\n        super(name);\n    }\n\
    }\n\nclass Item {\n    private String name;\n\n    // GOOD: This class declares\
    \ a no-argument constructor, which allows serializable \n    // subclasses to\
    \ be deserialized without error.\n    public Item() {}\n\n    public Item(String\
    \ name) {\n        this.name = name;\n    }\n}\n\nclass SubItem extends Item implements\
    \ Serializable {\n    public SubItem() { \n        super(null); \n    }\n\n  \
    \  public SubItem(String name) {\n        super(name);\n    }\n}\n```\n\n## References\n\
    * Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n\
    * J. Bloch, *Effective Java (second edition)*, Item 74. Addison-Wesley, 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/NonSerializableInnerClass.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/NonSerializableInnerClass.bqrs
  metadata:
    name: Serializable inner class of non-serializable class
    description: |-
      A class that is serializable with an enclosing class that is not serializable
                    causes serialization to fail.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/non-serializable-inner-class
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: "# Serializable inner class of non-serializable class\nNon-static nested\
    \ classes that implement `Serializable` must be defined in an enclosing class\
    \ that is also serializable. Non-static nested classes retain an implicit reference\
    \ to an instance of their enclosing class. If the enclosing class is not serializable,\
    \ the Java serialization mechanism fails with a `java.io.NotSerializableException`.\n\
    \n\n## Recommendation\nTo avoid causing a `NotSerializableException`, do one of\
    \ the following:\n\n* **Declare the nested class as `static` :** If the nested\
    \ class does not use any of the non-static fields or methods of the enclosing\
    \ class, it is best to declare it `static`. This removes the implicit reference\
    \ to an instance of the enclosing class, and has the additional effect of breaking\
    \ an unnecessary dependency between the two classes. A similar solution is to\
    \ turn the nested class into a separate top-level class.\n* **Make the enclosing\
    \ class implement `Serializable` :** However, this is not recommended because\
    \ the implementation of inner classes may be compiler-specific, and serializing\
    \ an inner class can result in non-portability across compilers. The Java Serialization\
    \ Specification states: <blockquote><p> Serialization of inner classes (i.e.,\
    \ nested classes that are not static member classes), including local and anonymous\
    \ classes, is strongly discouraged for several reasons. Because inner classes\
    \ declared in non-static contexts contain implicit non-transient references to\
    \ enclosing class instances, serializing such an inner class instance will result\
    \ in serialization of its associated outer class instance as well. Synthetic fields\
    \ generated by javac (or other Java(TM) compilers) to implement inner classes\
    \ are implementation dependent and may vary between compilers; differences in\
    \ such fields can disrupt compatibility as well as result in conflicting default\
    \ serialVersionUID values. The names assigned to local and anonymous inner classes\
    \ are also implementation dependent and may differ between compilers. </p> </blockquote>\n\
    \n## Example\nIn the following example, the class `WrongSession` cannot be serialized\
    \ without causing a `NotSerializableException`, because it is enclosed by a non-serializable\
    \ class. However, the class `Session` can be serialized because it is declared\
    \ as `static`.\n\n\n```java\nclass NonSerializableServer {\n\n    // BAD: The\
    \ following class is serializable, but the enclosing class\n    // 'NonSerializableServer'\
    \ is not. Serializing an instance of 'WrongSession' \n    // causes a 'java.io.NotSerializableException'.\n\
    \    class WrongSession implements Serializable {\n        private static final\
    \ long serialVersionUID = 8970783971992397218L;\n        private int id;\n   \
    \     private String user;\n        \n        WrongSession(int id, String user)\
    \ { /*...*/ }\n    }\n    \n    public WrongSession getNewSession(String user)\
    \ {\n        return new WrongSession(newId(), user);\n    }\n}\n\nclass Server\
    \ {\n\n    // GOOD: The following class can be correctly serialized because it\
    \ is static.\n    static class Session implements Serializable {\n        private\
    \ static final long serialVersionUID = 1065454318648105638L;\n        private\
    \ int id;\n        private String user;\n        \n        Session(int id, String\
    \ user) { /*...*/ }\n    }\n    \n    public Session getNewSession(String user)\
    \ {\n        return new Session(newId(), user);\n    }\n}\n```\n\n## References\n\
    * Java Object Serialization Specification: [1.10 The Serializable Interface](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#the-serializable-interface),\
    \ [2.1 The ObjectOutputStream Class](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/output.html#the-objectoutputstream-class).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Serialization/ReadResolveObject.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Serialization/ReadResolveObject.bqrs
  metadata:
    name: "ReadResolve must have Object return type, not void"
    description: |-
      An implementation of 'readResolve' that does not have the signature that is expected
                    by the Java serialization framework is not recognized by the serialization
                    mechanism.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/wrong-readresolve-signature
    tags: |-
      reliability
             maintainability
             language-features
  queryHelp: "# ReadResolve must have Object return type, not void\nIf a class uses\
    \ the `readResolve` method to specify a replacement object instance when the object\
    \ is read from a stream, ensure that the signature of `readResolve` is *exactly*\
    \ what the Java serialization mechanism expects.\n\n\n## Recommendation\nEnsure\
    \ that the signature of the `readResolve` method in the class matches the expected\
    \ signature:\n\n` ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;\
    \ `\n\nNote that the method *must* return a `java.lang.Object`.\n\nIf `readResolve`\
    \ is used for instance control of a serializable singleton, (that is, to make\
    \ sure that deserializing a singleton class does not result in another instance\
    \ of the singleton) it may be possible to use an `enum` with a single element\
    \ instead. The Java serialization specification explicitly ensures that deserializing\
    \ an `enum` does not create a new instance. (For details about this technique,\
    \ see \\[Bloch\\].)\n\n\n## Example\nIn the following example, `FalseSingleton.readResolve`\
    \ has the wrong signature, which causes deserialization to create a new instance\
    \ of the singleton. However, `Singleton.readResolve` has the correct signature,\
    \ which means that deserialization does not result in another instance of the\
    \ singleton.\n\n\n```java\nclass FalseSingleton implements Serializable {\n\t\
    private static final long serialVersionUID = -7480651116825504381L;\n\tprivate\
    \ static FalseSingleton instance;\n\t\n\tprivate FalseSingleton() {}\n\t\n\tpublic\
    \ static FalseSingleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance\
    \ = new FalseSingleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// BAD: Signature\
    \ of 'readResolve' does not match the exact signature that is expected\n\t// (that\
    \ is, it does not return 'java.lang.Object').\n\tpublic FalseSingleton readResolve()\
    \ throws ObjectStreamException {\n\t\treturn FalseSingleton.getInstance();\n\t\
    }\n}\n\nclass Singleton implements Serializable {\n\tprivate static final long\
    \ serialVersionUID = -7480651116825504381L;\n\tprivate static Singleton instance;\n\
    \t\n\tprivate Singleton() {}\n\t\n\tpublic static Singleton getInstance() {\n\t\
    \tif (instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn\
    \ instance;\n\t}\n\t\n\t// GOOD: Signature of 'readResolve' matches the exact\
    \ signature that is expected.\n\t// It replaces the singleton that is read from\
    \ a stream with an instance of 'Singleton',\n\t// instead of creating a new singleton.\n\
    \tprivate Object readResolve() throws ObjectStreamException {\n\t\treturn Singleton.getInstance();\n\
    \t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n\
    * Java Object Serialization Specification: [3.7 The readResolve Method](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/input.html#the-readresolve-method),\
    \ [1.12 Serialization of Enum Constants](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#serialization-of-enum-constants).\n\
    * J. Bloch, *Effective Java (second edition)*, Item 77. Addison-Wesley, 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/ContinueInFalseLoop.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/ContinueInFalseLoop.bqrs
  metadata:
    name: Continue statement that does not continue
    description: |-
      A 'continue' statement only re-runs the loop if the
                    loop-condition is true. Therefore using 'continue' in a loop
                    with a constant false condition is misleading and usually a
                    bug.
    kind: problem
    id: java/continue-in-false-loop
    problem.severity: warning
    precision: high
    tags: correctness
  queryHelp: |
    # Continue statement that does not continue
    A `continue` statement only re-runs the loop if the loop condition is true. Therefore using `continue` in a loop with a constant false condition will never cause the loop body to be re-run, which is misleading.


    ## Recommendation
    Replace the `continue` statement with a `break` statement if the intent is to break from the loop.


    ## References
    * Java Language Specification: [14.13 The do Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.13).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/MissingEnumInSwitch.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/MissingEnumInSwitch.bqrs
  metadata:
    name: Missing enum case in switch
    description: |-
      A 'switch' statement that is based on an 'enum' type and does not have cases for all
                    the 'enum' constants is usually a coding mistake.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/missing-case-in-switch
    tags: |-
      reliability
             readability
             external/cwe/cwe-478
  queryHelp: "# Missing enum case in switch\nA `switch` statement that is based on\
    \ a variable with an `enum` type should either have a default case or handle all\
    \ possible constants of that `enum` type. Handling all but one or two `enum` constants\
    \ is usually a coding mistake.\n\n\n## Recommendation\nIf there are only a handful\
    \ of missing cases, add them to the end of the `switch` statement. If there are\
    \ many cases that do not need to be handled individually, add a default case to\
    \ handle them.\n\nIf there are some `enum` constants that should never occur in\
    \ this particular part of the code, then program defensively by adding cases for\
    \ those constants and explicitly throwing an exception (rather than just having\
    \ no cases for those constants).\n\n\n## Example\nIn the following example, the\
    \ case for 'YES' is missing. Therefore, if `answer` is 'YES', an exception is\
    \ thrown at run time. To fix this, a case for 'YES' should be added.\n\n\n```java\n\
    enum Answer { YES, NO, MAYBE }\n\nclass Optimist\n{\n\tAnswer interpret(Answer\
    \ answer) {\n\t\tswitch (answer) {\n\t\t\tcase MAYBE:\n\t\t\t\treturn Answer.YES;\n\
    \t\t\tcase NO:\n\t\t\t\treturn Answer.MAYBE;\n\t\t\t// Missing case for 'YES'\n\
    \t\t}\n\t\tthrow new RuntimeException(\"uncaught case: \" + answer);\n\t}\n}\n\
    \n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings\
    \ Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [8.9 Enum Types](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.9),\
    \ [14.11 The switch Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.11).\n\
    * Common Weakness Enumeration: [CWE-478](https://cwe.mitre.org/data/definitions/478.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/PartiallyMaskedCatch.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/PartiallyMaskedCatch.bqrs
  metadata:
    name: Unreachable catch clause
    description: |-
      An unreachable 'catch' clause may indicate a mistake in exception handling or may
                    be unnecessary.
    kind: problem
    problem.severity: warning
    precision: high
    id: java/unreachable-catch-clause
    tags: |-
      reliability
             correctness
             exceptions
             external/cwe/cwe-561
  queryHelp: "# Unreachable catch clause\nAn unreachable `catch` clause may indicate\
    \ a logical mistake in the exception handling code or may simply be unnecessary.\n\
    \nAlthough certain unreachable `catch` clauses cause a compiler error, there are\
    \ also unreachable `catch` clauses that do not cause a compiler error. A `catch`\
    \ clause `C` is considered reachable by the compiler if both of the following\
    \ conditions are true:\n\n* A checked exception that is thrown in the `try` block\
    \ is assignable to the parameter of `C`.\n* There is no previous `catch` clause\
    \ whose parameter type is equal to, or a supertype of, the parameter type of `C`.\n\
    However, a `catch` clause that is considered reachable by the compiler can be\
    \ unreachable if both of the following conditions are true:\n\n* The `catch` clause's\
    \ parameter type `E` does not include any unchecked exceptions.\n* All exceptions\
    \ that are thrown in the `try` block whose type is a (strict) subtype of `E` are\
    \ already handled by previous `catch` clauses.\n\n## Recommendation\nEnsure that\
    \ unreachable `catch` clauses are removed or that further corrections are made\
    \ to make them reachable.\n\nNote that if a `try-catch` statement contains multiple\
    \ `catch` clauses, and an exception that is thrown in the `try` block matches\
    \ more than one of the `catch` clauses, only the first matching clause is executed.\n\
    \n\n## Example\nIn the following example, the second `catch` clause is unreachable.\
    \ The code is incomplete because a `FileOutputStream` is opened but no methods\
    \ are called to write to the stream. Such methods typically throw `IOException`s,\
    \ which would make the second `catch` clause reachable.\n\n\n```java\nFileOutputStream\
    \ fos = null;\ntry {\n\tfos = new FileOutputStream(new File(\"may_not_exist.txt\"\
    ));\n} catch (FileNotFoundException e) {\n\t// ask the user and try again\n} catch\
    \ (IOException e) {\n\t// more serious, abort\n} finally {\n\tif (fos!=null) {\
    \ try { fos.close(); } catch (IOException e) { /*ignore*/ } }\n}\n```\n\n## References\n\
    * Java Language Specification: [Execution of try-catch](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.20.1),\
    \ [Unreachable Statements](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.21).\n\
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Statements/UseBraces.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Statements/UseBraces.bqrs
  metadata:
    name: Misleading indentation
    description: |-
      If a control structure does not use braces, misleading indentation makes it
                    difficult to see which statements are within its scope.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/misleading-indentation
    tags: |-
      maintainability
             correctness
             logic
  queryHelp: |
    # Misleading indentation
    A control structure (an `if` statement or a loop) has a body that is either a block of statements surrounded by curly braces or a single statement.

    If you omit braces, it is particularly important to ensure that the indentation of the code matches the control flow of the code.


    ## Recommendation
    It is usually considered good practice to include braces for all control structures in Java. This is because it makes it easier to maintain the code later. For example, it's easy to see at a glance which part of the code is in the scope of an `if` statement, and adding more statements to the body of the `if` statement is less error-prone.

    You should also ensure that the indentation of the code is consistent with the actual flow of control, so that it does not confuse programmers.


    ## Example
    In the example below, the original version of `Cart` is missing braces. This means that the code triggers a `NullPointerException` at runtime if `i` is `null`.


    ```java
    class Cart {
        Map<Integer, Integer> items = ...
        public void addItem(Item i) {
            // No braces and misleading indentation.
            if (i != null)
                log("Adding item: " + i);
                // Indentation suggests that the following statements
                // are in the body of the 'if'.
                Integer curQuantity = items.get(i.getID());
                if (curQuantity == null) curQuantity = 0;
                items.put(i.getID(), curQuantity+1);
        }
    }
    ```
    The corrected version of `Cart` does include braces, so that the code executes as the indentation suggests.


    ```java
    class Cart {
        Map<Integer, Integer> items = ...
        public void addItem(Item i) {
            // Braces included.
            if (i != null) {
                log("Adding item: " + i);
                Integer curQuantity = items.get(i.getID());
                if (curQuantity == null) curQuantity = 0;
                items.put(i.getID(), curQuantity+1);
            }
        }
    }
    ```
    In the following example the indentation may or may not be misleading depending on your tab width settings. As such, mixing tabs and spaces in this way is not recommended, since what looks fine in one context can be very misleading in another.


    ```java
    // Tab width 8
            if (b)       // Indentation: 1 tab
                    f(); // Indentation: 2 tabs
            g();         // Indentation: 8 spaces

    // Tab width 4
        if (b)   // Indentation: 1 tab
            f(); // Indentation: 2 tabs
            g(); // Indentation: 8 spaces
    ```
    If you mix tabs and spaces in this way, then you might get seemingly false positives, since your tab width settings cannot be taken into account.


    ## References
    * Java SE Documentation: [Compound Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#15395).
    * Wikipedia: [Indentation style](https://en.wikipedia.org/wiki/Indentation_style).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Termination/ConstantLoopCondition.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Termination/ConstantLoopCondition.bqrs
  metadata:
    name: Constant loop condition
    description: |-
      A loop condition that remains constant throughout the iteration
                    indicates faulty logic and is likely to cause infinite
                    looping.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/constant-loop-condition
    tags: |-
      correctness
             external/cwe/cwe-835
  queryHelp: |
    # Constant loop condition
    Loops can contain multiple exit conditions, either directly in the loop condition or as guards around `break` or `return` statements. If none of the exit conditions can ever be satisfied, then the loop will never terminate.


    ## Recommendation
    When writing a loop that is intended to terminate, make sure that all the necessary exit conditions can be satisfied and that loop termination is clear.


    ## Example
    The following example searches for a field of a given name, and intends to throw an exception if the field cannot be found. However, if the field cannot be found, the double loop structure means that the exit conditions will never be met, resulting in an infinite loop.


    ```java
    Object getField(Object obj, String name) throws NoSuchFieldError {
      Class clazz = obj.getClass();
      while (clazz != null) {
        for (Field f : clazz.getDeclaredFields()) {
          if (f.getName().equals(name)) {
            f.setAccessible(true);
            return f.get(obj);
          }
        }
      }
      throw new NoSuchFieldError(name);
    }

    ```
    The solution is to rewrite the code as follows using an `if`-statement.


    ```java
    Object getField(Object obj, String name) throws NoSuchFieldError {
      Class clazz = obj.getClass();
      if (clazz != null) {
        for (Field f : clazz.getDeclaredFields()) {
          if (f.getName().equals(name)) {
            f.setAccessible(true);
            return f.get(obj);
          }
        }
      }
      throw new NoSuchFieldError(name);
    }

    ```

    ## References
    * Java Language Specification: [Blocks and Statements](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html).
    * Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Likely Bugs/Termination/SpinOnField.ql
  relativeBqrsPath: codeql/java-queries/Likely Bugs/Termination/SpinOnField.bqrs
  metadata:
    name: Spin on field
    description: |-
      Repeatedly reading a non-volatile field within the condition of an empty loop may
                    result in an infinite loop.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/spin-on-field
    tags: |-
      efficiency
             correctness
             concurrency
  queryHelp: |
    # Spin on field
    Repeatedly reading a non-volatile field within the condition of an empty loop statement may result in an infinite loop, since a compiler optimization may move this field access out of the loop.


    ## Example
    In the following example, the method `spin` repeatedly tests the field `done` in a loop. The method repeats the while-loop until the value of the field `done` is set by another thread. However, the compiler could optimize the code as shown in the second code snippet, because the field `done` is not marked as `volatile` and there are no statements in the body of the loop that could change the value of `done`. The optimized version of `spin` loops forever, even when another thread would set `done` to `true`.


    ```java
    class Spin {
        public boolean done = false;

        public void spin() {
            while(!done){
            }
        }
    }

    class Spin { // optimized
        public boolean done = false;

        public void spin() {
            boolean cond = done;
            while(!cond){
            }
        }
    }

    ```

    ## Recommendation
    Ensure that access to this field is properly synchronized. Alternatively, avoid spinning on the field and instead use the `wait` and `notifyAll` methods or the `java.util.concurrent` library to communicate between threads.


    ## References
    * Java Language Specification: [Threads and Locks](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Summaries/LinesOfCode.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Summaries/LinesOfCode.bqrs
  metadata:
    id: java/summary/lines-of-code
    name: Total lines of Java/Kotlin code in the database
    description: |-
      The total number of lines of code across all Java and Kotlin files. This is a useful metric of the size of a database.
                    For all source files that were seen during the build, this query counts the lines of code, excluding whitespace
                    or comments.
    kind: metric
    tags: |-
      summary
             lines-of-code
             debug
  queryHelp: null
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Summaries/LinesOfCodeJava.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Summaries/LinesOfCodeJava.bqrs
  metadata:
    id: java/summary/lines-of-code-java
    name: Total lines of Java code in the database
    description: |-
      The total number of lines of code across all Java files. This is a useful metric of the size of a database.
                    For all Java files that were seen during the build, this query counts the lines of code, excluding whitespace
                    or comments.
    kind: metric
    tags: summary
  queryHelp: null
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Metrics/Summaries/LinesOfCodeKotlin.ql
  relativeBqrsPath: codeql/java-queries/Metrics/Summaries/LinesOfCodeKotlin.bqrs
  metadata:
    id: java/summary/lines-of-code-kotlin
    name: Total lines of Kotlin code in the database
    description: |-
      The total number of lines of code across all Kotlin files. This is a useful metric of the size of a database.
                    For all Kotlin files that were seen during the build, this query counts the lines of code, excluding whitespace
                    or comments.
    kind: metric
    tags: summary
  queryHelp: null
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Performance/InefficientEmptyStringTest.ql
  relativeBqrsPath: codeql/java-queries/Performance/InefficientEmptyStringTest.bqrs
  metadata:
    name: Inefficient empty string test
    description: Checking a string for equality with an empty string is inefficient.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/inefficient-empty-string-test
    tags: |-
      efficiency
             maintainability
  queryHelp: "# Inefficient empty string test\nWhen checking whether a string `s`\
    \ is empty, perhaps the most obvious solution is to write something like `s.equals(\"\
    \")` (or `\"\".equals(s)`). However, this actually carries a fairly significant\
    \ overhead, because `String.equals` performs a number of type tests and conversions\
    \ before starting to compare the content of the strings.\n\n\n## Recommendation\n\
    The preferred way of checking whether a string `s` is empty is to check if its\
    \ length is equal to zero. Thus, the condition is `s.length() == 0`. The `length`\
    \ method is implemented as a simple field access, and so should be noticeably\
    \ faster than calling `equals`.\n\nNote that in Java 6 and later, the `String`\
    \ class has an `isEmpty` method that checks whether a string is empty. If the\
    \ codebase does not need to support Java 5, it may be better to use that method\
    \ instead.\n\n\n## Example\nIn the following example, class `InefficientDBClient`\
    \ uses `equals` to test whether the strings `user` and `pw` are empty. Note that\
    \ the test `\"\".equals(pw)` guards against `NullPointerException`, but the test\
    \ `user.equals(\"\")` throws a `NullPointerException` if `user` is `null`.\n\n\
    In contrast, the class `EfficientDBClient` uses `length` instead of `equals`.\
    \ The class preserves the behavior of `InefficientDBClient` by guarding `pw.length()\
    \ == 0` but not `user.length() == 0` with an explicit test for `null`. Whether\
    \ or not this guard is desirable depends on the intended behavior of the program.\n\
    \n\n```java\n// Inefficient version\nclass InefficientDBClient {\n\tpublic void\
    \ connect(String user, String pw) {\n\t\tif (user.equals(\"\") || \"\".equals(pw))\n\
    \t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n// More efficient version\n\
    class EfficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\
    \tif (user.length() == 0 || (pw != null && pw.length() == 0))\n\t\t\tthrow new\
    \ RuntimeException();\n\t\t...\n\t}\n}\n\n```\n\n## References\n* Java API Specification:\
    \ [String.length()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#length()),\
    \ [String.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#isEmpty()),\
    \ [String.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#equals(java.lang.Object)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Performance/InefficientKeySetIterator.ql
  relativeBqrsPath: codeql/java-queries/Performance/InefficientKeySetIterator.bqrs
  metadata:
    name: Inefficient use of key set iterator
    description: Iterating through the values of a map using the key set is inefficient.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/inefficient-key-set-iterator
    tags: |-
      efficiency
             maintainability
  queryHelp: "# Inefficient use of key set iterator\nJava's Collections Framework\
    \ provides several different ways of iterating the contents of a map. You can\
    \ retrieve the set of keys, the collection of values, or the set of \"entries\"\
    \ (which are, in effect, key/value pairs).\n\nThe choice of iterator can affect\
    \ performance. For example, it is considered bad practice to iterate the key set\
    \ of a map if the body of the loop performs a map lookup on each retrieved key\
    \ anyway.\n\n\n## Recommendation\nEvaluate the requirements of the loop body.\
    \ If it does not actually need the key apart from looking it up in the map, iterate\
    \ the map's values (obtained by a call to `values`) instead. If the loop genuinely\
    \ needs both key and value for each mapping in the map, iterate the entry set\
    \ (obtained by a call to `entrySet`) and retrieve the key and value from each\
    \ entry. This saves a more expensive map lookup each time.\n\n\n## Example\nIn\
    \ the following example, the first version of the method `findId` iterates the\
    \ map `people` using the key set. This is inefficient because the body of the\
    \ loop needs to access the value for each key. In contrast, the second version\
    \ iterates the map using the entry set because the loop body needs both the key\
    \ and the value for each mapping.\n\n\n```java\n// AVOID: Iterate the map using\
    \ the key set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\
    \tpublic String findId(String first, String last) {\n\t\tfor (String id : people.keySet())\
    \ {\n\t\t\tPerson p = people.get(id);\n\t\t\tif (first.equals(p.firstName()) &&\
    \ last.equals(p.lastName()))\n\t\t\t\treturn id;\n\t\t}\n\t\treturn null;\n\t\
    }\n}\n\n// GOOD: Iterate the map using the entry set.\nclass AddressBook {\n\t\
    private Map<String, Person> people = ...;\n\tpublic String findId(String first,\
    \ String last) {\n\t\tfor (Entry<String, Person> entry: people.entrySet()) {\n\
    \t\t\tPerson p = entry.getValue();\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\
    \t\t\t\treturn entry.getKey();\n\t\t}\n\t\treturn null;\n\t}\n}\n```\n\n## References\n\
    * Java API Specification: [Map.entrySet()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#entrySet()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Performance/InefficientOutputStream.ql
  relativeBqrsPath: codeql/java-queries/Performance/InefficientOutputStream.bqrs
  metadata:
    name: Inefficient output stream
    description: |-
      Using the default implementation of 'write(byte[],int,int)'
                    provided by 'java.io.OutputStream' is very inefficient.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/inefficient-output-stream
    tags: efficiency
  queryHelp: "# Inefficient output stream\nThe classes `java.io.OutputStream` and\
    \ `java.io.FilterOutputStream` only require subclasses to implement the method\
    \ `write(byte b)`. Typically, uses of `OutputStream`s will not write single bytes,\
    \ but an array via the `write(byte[] b, int off, int len)` method. The default\
    \ implementation of this method, which you are not required to override, calls\
    \ `write(byte b)` for each byte in the array. If this method involves I/O, such\
    \ as accessing the network or disk, this is likely to incur significant overhead.\n\
    \n\n## Recommendation\nAlways provide an implementation of the `write(byte[] b,\
    \ int off, int len)` method.\n\n\n## Example\nThe following example shows a subclass\
    \ of `OutputStream` that simply wraps a `DigestOutputStream` to confirm that the\
    \ data it writes to a file has the expected MD5 hash. Without an implementation\
    \ of `write(byte[] b, int off, int len)` this will be very slow, because it makes\
    \ a call to `DigestOutputStream.write(byte b)` and `FileOutputStream.write(byte\
    \ b)` for each byte written.\n\n\n```java\npublic class DigestCheckingFileOutputStream\
    \ extends OutputStream {\n\tprivate DigestOutputStream digest;\n\tprivate byte[]\
    \ expectedMD5;\n\n\tpublic DigestCheckingFileOutputStream(File file, byte[] expectedMD5)\n\
    \t\tthrows IOException, NoSuchAlgorithmException {\n\t\t\tthis.expectedMD5 = expectedMD5;\n\
    \t\t\tdigest = new DigestOutputStream(new FileOutputStream(file),\n\t\t\t\t\t\t\
    \t\t\t\t\tMessageDigest.getInstance(\"MD5\"));\n\t\t}\n\n\t@Override\n\tpublic\
    \ void write(int b) throws IOException {\n\t\tdigest.write(b);\n\t}\n\n\t@Override\n\
    \tpublic void close() throws IOException {\n\t\tsuper.close();\n\n\t\tdigest.close();\n\
    \t\tbyte[] md5 = digest.getMessageDigest().digest();\n\t\tif (expectedMD5 != null\
    \ && !Arrays.equals(expectedMD5, md5)) {\n\t\t\tthrow new InternalError();\n\t\
    \t}\n\t}\n}\n\n```\nThe example can be updated to use a more efficient method.\
    \ In this case, calls to `write(byte[] b, int off, int len)` are simply forwarded\
    \ to `DigestOutputStream.write(byte[] b, int off, int len)`.\n\n\n```java\npublic\
    \ class DigestCheckingFileOutputStream extends OutputStream {\n\tprivate DigestOutputStream\
    \ digest;\n\tprivate byte[] expectedMD5;\n\n\tpublic DigestCheckingFileOutputStream(File\
    \ file, byte[] expectedMD5)\n\t\tthrows IOException, NoSuchAlgorithmException\
    \ {\n\t\t\tthis.expectedMD5 = expectedMD5;\n\t\t\tdigest = new DigestOutputStream(new\
    \ FileOutputStream(file),\n\t\t\t\t\t\t\t\t\t\t\tMessageDigest.getInstance(\"\
    MD5\"));\n\t\t}\n\n\t@Override\n\tpublic void write(int b) throws IOException\
    \ {\n\t\tdigest.write(b);\n\t}\n\n\t@Override\n\tpublic void write(byte[] b, int\
    \ off, int len) throws IOException {\n\t\tdigest.write(b, off, len);\n\t}\n\n\t\
    @Override\n\tpublic void close() throws IOException {\n\t\tsuper.close();\n\n\t\
    \tdigest.close();\n\t\tbyte[] md5 = digest.getMessageDigest().digest();\n\t\t\
    if (expectedMD5 != null && !Arrays.equals(expectedMD5, md5)) {\n\t\t\tthrow new\
    \ InternalError();\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Java API Specification:\
    \ [OutputStream.write(byte\\[\\] b, int off, int len)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/OutputStream.html#write(byte[],int,int)),\
    \ [FilterOutputStream.write(byte\\[\\] b, int off, int len)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FilterOutputStream.html#write(byte[],int,int)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Performance/InefficientPrimConstructor.ql
  relativeBqrsPath: codeql/java-queries/Performance/InefficientPrimConstructor.bqrs
  metadata:
    name: Inefficient primitive constructor
    description: Calling the constructor of a boxed type is inefficient.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/inefficient-boxed-constructor
    tags: |-
      efficiency
             maintainability
  queryHelp: "# Inefficient primitive constructor\nPrimitive values (for example `int`,\
    \ `float`, `boolean`) all have corresponding reference types known as *boxed types*\
    \ (for example `Integer`, `Float`, `Boolean`). These boxed types can be used when\
    \ an actual object is required. While they all provide constructors that take\
    \ a primitive value of the appropriate type, it is usually considered bad practice\
    \ to call those constructors directly.\n\nEach boxed type provides a static `valueOf`\
    \ method that takes an argument of the appropriate primitive type and returns\
    \ an object representing it. The advantage of calling `valueOf` over calling a\
    \ constructor is that it allows for some caching of instances. By reusing these\
    \ cached instances instead of constructing new heap objects all the time, a significant\
    \ amount of garbage collector effort can be saved.\n\n\n## Recommendation\nIn\
    \ almost all circumstances, a call of, for example, `Integer.valueOf(42)` can\
    \ be used instead of `new Integer(42)`.\n\nNote that sometimes you can rely on\
    \ Java's *autoboxing* feature, which implicitly calls `valueOf`. For details,\
    \ see the example.\n\n\n## Example\nThe following example shows the three ways\
    \ of creating a new integer. In the autoboxing example, the zero is autoboxed\
    \ to an `Integer` because the constructor `Account` takes an argument of this\
    \ type.\n\n\n```java\npublic class Account {\n\tprivate Integer balance;\n\tpublic\
    \ Account(Integer startingBalance) {\n\t\tthis.balance = startingBalance;\n\t\
    }\n}\n\npublic class BankManager {\n\tpublic void openAccount(Customer c) {\n\t\
    \t...\n\t\t// AVOID: Inefficient primitive constructor\n\t\taccounts.add(new Account(new\
    \ Integer(0)));\n\t\t// GOOD: Use 'valueOf'\n\t\taccounts.add(new Account(Integer.valueOf(0)));\n\
    \t\t// GOOD: Rely on autoboxing\n\t\taccounts.add(new Account(0));\n\t}\n}\n```\n\
    \n## References\n* J. Bloch, *Effective Java (second edition)*, Items 1 and 5.\
    \ Addison-Wesley, 2008.\n* Java API Specification: [Boolean.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Boolean.html#valueOf(boolean)),\
    \ [Byte.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Byte.html#valueOf(byte)),\
    \ [Short.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Short.html#valueOf(short)),\
    \ [Character.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#valueOf(char)),\
    \ [Integer.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#valueOf(int)),\
    \ [Long.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html#valueOf(long)),\
    \ [Float.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Float.html#valueOf(float)),\
    \ [Double.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#valueOf(double)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Performance/InnerClassCouldBeStatic.ql
  relativeBqrsPath: codeql/java-queries/Performance/InnerClassCouldBeStatic.bqrs
  metadata:
    name: Inner class could be static
    description: |-
      A non-static nested class keeps a reference to the enclosing object,
                    which makes the nested class bigger and may cause a memory leak.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/non-static-nested-class
    tags: |-
      efficiency
             maintainability
  queryHelp: |
    # Inner class could be static
    Nested classes allow logical grouping of related concerns, increasing encapsulation and readability. However, there is a potential disadvantage when using them that you should be aware of.

    Any non-static nested class implicitly holds onto its "enclosing instance". This means that:

    * The nested class has an implicitly defined field. The field holds a reference to the instance of the enclosing class that constructed the nested class.
    * The nested class's constructors have an implicit parameter. The parameter is used for passing in the instance of the enclosing class. A reference to the instance is then stored in the field mentioned above.
    Often, this is useful and necessary, because non-static nested class instances have access to instance state on their enclosing classes. However, if this instance state is not needed by the nested class, this makes nested class instances larger than necessary, and hidden references to the enclosing classes are often the source of subtle memory leaks.


    ## Recommendation
    When a nested class does not need the enclosing instance, it is better to declare the nested class `static`, avoiding the implicit field. As a result, instances of the nested class become smaller, and hidden references to the enclosing class are made explicit.

    If a reference to the enclosing class instance is required during construction of the nested class instance (but not subsequently), the constructor of the nested class should be refactored so that it is explicitly given a reference to the enclosing instance.

    If the nested class refers to a type variable of an enclosing class instance, consider parameterizing the nested class by that type variable.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 22. Addison-Wesley, 2008.
    * Java Language Specification: [8.1.3. Inner Classes and Enclosing Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.3).
    * The Java Tutorials: [Nested Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Performance/NewStringString.ql
  relativeBqrsPath: codeql/java-queries/Performance/NewStringString.bqrs
  metadata:
    name: Inefficient String constructor
    description: |-
      Using the 'String(String)' constructor is less memory efficient than using the
                    constructor argument directly.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/inefficient-string-constructor
    tags: |-
      efficiency
             maintainability
  queryHelp: "# Inefficient String constructor\nThe `String` class is immutable, which\
    \ means that there is no way to change the string that it represents. Consequently,\
    \ there is rarely a need to copy a `String` object or construct a new instance\
    \ based on an existing string, for example by writing something like `String hello\
    \ = new String(\"hello\")`. Furthermore, this practice is not memory efficient.\n\
    \n\n## Recommendation\nThe copied string is functionally indistinguishable from\
    \ the argument that was passed into the `String` constructor, so you can simply\
    \ omit the constructor call and use the argument passed into it directly. Unless\
    \ an explicit copy of the argument string is needed, this is a safe transformation.\n\
    \n\n## Example\nThe following example shows three cases of copying a string using\
    \ the `String` constructor, which is inefficient. In each case, simply removing\
    \ the constructor call `new String` and leaving the argument results in better\
    \ code and less memory churn.\n\n\n```java\npublic void sayHello(String world)\
    \ {\n\t// AVOID: Inefficient 'String' constructor\n\tString message = new String(\"\
    hello \");\n\n\t// AVOID: Inefficient 'String' constructor\n\tmessage = new String(message\
    \ + world);\n\n\t// AVOID: Inefficient 'String' constructor\n\tSystem.out.println(new\
    \ String(message));\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second\
    \ edition)*, Item 5. Addison-Wesley, 2008.\n* Java API Specification: [String(String)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#%3Cinit%3E(java.lang.String)).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-020/OverlyLargeRange.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-020/OverlyLargeRange.bqrs
  metadata:
    name: Overly permissive regular expression range
    description: |-
      Overly permissive regular expression ranges match a wider range of characters than intended.
                    This may allow an attacker to bypass a filter or sanitizer.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: high
    id: java/overly-large-range
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Overly permissive regular expression range
    It's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \ ] ^ _ ` ``.

    Another common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.


    ## Recommendation
    Avoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.


    ## Example
    The following example code is intended to check whether a string is a valid 6 digit hex color.

    ```java

    import java.util.regex.Pattern
    public class Tester {
        public static boolean is_valid_hex_color(String color) {
            return Pattern.matches("#[0-9a-fA-f]{6}", color);
        }
    }

    ```
    However, the `A-f` range is overly large and matches every uppercase character. It would parse a "color" like `#XXYYZZ` as valid.

    The fix is to use an uppercase `A-F` range instead.

    ```javascript

    import java.util.regex.Pattern
    public class Tester {
        public static boolean is_valid_hex_color(String color) {
            return Pattern.matches("#[0-9a-fA-F]{6}", color);
        }
    }

    ```

    ## References
    * GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)
    * wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)
    * Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)
    * Paul Boyd: [The regex \[,-.\]](https://pboyd.io/posts/comma-dash-dot/)
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-022/TaintedPath.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-022/TaintedPath.bqrs
  metadata:
    name: Uncontrolled data used in path expression
    description: Accessing paths influenced by users can allow an attacker to access
      unexpected resources.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/path-injection
    tags: |-
      security
             external/cwe/cwe-022
             external/cwe/cwe-023
             external/cwe/cwe-036
             external/cwe/cwe-073
  queryHelp: "# Uncontrolled data used in path expression\nAccessing paths controlled\
    \ by users can allow an attacker to access unexpected resources. This can result\
    \ in sensitive information being revealed or deleted, or an attacker being able\
    \ to influence behavior by modifying unexpected files.\n\nPaths that are naively\
    \ constructed from data controlled by a user may be absolute paths, or may contain\
    \ unexpected special characters such as \"..\". Such a path could point anywhere\
    \ on the file system.\n\n\n## Recommendation\nValidate user input before using\
    \ it to construct a file path.\n\nCommon validation methods include checking that\
    \ the normalized path is relative and does not contain any \"..\" components,\
    \ or checking that the path is contained within a safe folder. The method you\
    \ should use depends on how the path is used in the application, and whether the\
    \ path should be a single path component.\n\nIf the path should be a single path\
    \ component (such as a file name), you can check for the existence of any path\
    \ separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject\
    \ the input if any are found.\n\nNote that removing \"../\" sequences is *not*\
    \ sufficient, since the input could still contain a path separator followed by\
    \ \"..\". For example, the input \".../...//\" would still result in the string\
    \ \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but\
    \ most restrictive) option is to use an allow list of safe patterns and make sure\
    \ that the user input matches one of these patterns.\n\n\n## Example\nIn this\
    \ example, a file name is read from a `java.net.Socket` and then used to access\
    \ a file and send it back over the socket. However, a malicious user could enter\
    \ a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\"\
    .\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader\
    \ filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(),\
    \ \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read\
    \ from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new\
    \ FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine\
    \ != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine\
    \ = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file\
    \ name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\
    \n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader\
    \ filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(),\
    \ \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure\
    \ that the filename has no path separators or parent directory references\n\t\
    if (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\
    \\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t\
    }\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\
    \tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\t\
    sock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\
    \t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check\
    \ that the resolved path is still contained within that directory.\n\n\n```java\n\
    public void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader\
    \ = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"\
    UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder\
    \ = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\
    \tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\
    \n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder\
    \ + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\"\
    );\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\
    \tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\t\
    sock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\
    \t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n\
    * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n\
    * Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n\
    * Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n\
    * Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-022/ZipSlip.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-022/ZipSlip.bqrs
  metadata:
    name: Arbitrary file access during archive extraction ("Zip Slip")
    description: |-
      Extracting files from a malicious ZIP file, or similar type of archive, without
                    validating that the destination file path is within the destination directory
                    can allow an attacker to unexpectedly gain access to resources.
    kind: path-problem
    id: java/zipslip
    problem.severity: error
    security-severity: 7.5
    precision: high
    tags: |-
      security
             external/cwe/cwe-022
  queryHelp: |
    # Arbitrary file access during archive extraction ("Zip Slip")
    Extracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated.

    Zip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.

    For example, if a zip file contains a file entry `..\sneaky-file`, and the zip file is extracted to the directory `c:\output`, then naively combining the paths would result in an output file path of `c:\output\..\sneaky-file`, which would cause the file to be written to `c:\sneaky-file`.


    ## Recommendation
    Ensure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.

    The recommended way of writing an output file from a zip archive entry is to verify that the normalized full path of the output file starts with a prefix that matches the destination directory. Path normalization can be done with either `java.io.File.getCanonicalFile()` or `java.nio.file.Path.normalize()`. Prefix checking can be done with `String.startsWith(..)`, but it is better to use `java.nio.file.Path.startsWith(..)`, as the latter works on complete path segments.

    Another alternative is to validate archive entries against a whitelist of expected files.


    ## Example
    In this example, a file path taken from a zip archive item entry is combined with a destination directory. The result is used as the destination file path without verifying that the result is within the destination directory. If provided with a zip file containing an archive path like `..\sneaky-file`, then this file would be written outside the destination directory.


    ```java
    void writeZipEntry(ZipEntry entry, File destinationDir) {
        File file = new File(destinationDir, entry.getName());
        FileOutputStream fos = new FileOutputStream(file); // BAD
        // ... write entry to fos ...
    }

    ```
    To fix this vulnerability, we need to verify that the normalized `file` still has `destinationDir` as its prefix, and throw an exception if this is not the case.


    ```java
    void writeZipEntry(ZipEntry entry, File destinationDir) {
        File file = new File(destinationDir, entry.getName());
        if (!file.toPath().normalize().startsWith(destinationDir.toPath()))
            throw new Exception("Bad zip entry");
        FileOutputStream fos = new FileOutputStream(file); // OK
        // ... write entry to fos ...
    }

    ```

    ## References
    * Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).
    * OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-023/PartialPathTraversal.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-023/PartialPathTraversal.bqrs
  metadata:
    name: Partial path traversal vulnerability
    description: A prefix used to check that a canonicalised path falls within another
      must be slash-terminated.
    kind: problem
    problem.severity: error
    security-severity: 9.3
    precision: medium
    id: java/partial-path-traversal
    tags: |-
      security
             external/cwe/cwe-023
  queryHelp: |
    # Partial path traversal vulnerability
    A common way to check that a user-supplied path `SUBDIR` falls inside a directory `DIR` is to use `getCanonicalPath()` to remove any path-traversal elements and then check that `DIR` is a prefix. However, if `DIR` is not slash-terminated, this can unexpectedly allow access to siblings of `DIR`.

    See also `java/partial-path-traversal-from-remote`, which is similar to this query but only flags instances with evidence of remote exploitability.


    ## Recommendation
    If the user should only access items within a certain directory `DIR`, ensure that `DIR` is slash-terminated before checking that `DIR` is a prefix of the user-provided path, `SUBDIR`. Note, Java's `getCanonicalPath()` returns a **non**-slash-terminated path string, so a slash must be added to `DIR` if that method is used.


    ## Example
    In this example, the `if` statement checks if `parent.getCanonicalPath()` is a prefix of `dir.getCanonicalPath()`. However, `parent.getCanonicalPath()` is not slash-terminated. This means that users that supply `dir` may be also allowed to access siblings of `parent` and not just children of `parent`, which is a security issue.


    ```java
    public class PartialPathTraversalBad {
        public void example(File dir, File parent) throws IOException {
            if (!dir.getCanonicalPath().startsWith(parent.getCanonicalPath())) {
                throw new IOException("Path traversal attempt: " + dir.getCanonicalPath());
            }
        }
    }

    ```
    In this example, the `if` statement checks if `parent.toPath()` is a prefix of `dir.normalize()`. Because `Path#startsWith` does the correct check that `dir` is a child of `parent`, users will not be able to access siblings of `parent`, as desired.


    ```java
    import java.io.File;

    public class PartialPathTraversalGood {
        public void example(File dir, File parent) throws IOException {
            if (!dir.toPath().normalize().startsWith(parent.toPath())) {
                throw new IOException("Path traversal attempt: " + dir.getCanonicalPath());
            }
        }
    }

    ```

    ## References
    * OWASP: [Partial Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * CVE-2022-23457: [ ESAPI Vulnerability Report](https://github.com/ESAPI/esapi-java-legacy/blob/develop/documentation/GHSL-2022-008_The_OWASP_Enterprise_Security_API.md).
    * Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-023/PartialPathTraversalFromRemote.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-023/PartialPathTraversalFromRemote.bqrs
  metadata:
    name: Partial path traversal vulnerability from remote
    description: A prefix used to check that a canonicalised path falls within another
      must be slash-terminated.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/partial-path-traversal-from-remote
    tags: |-
      security
             external/cwe/cwe-023
  queryHelp: |
    # Partial path traversal vulnerability from remote
    A common way to check that a user-supplied path `SUBDIR` falls inside a directory `DIR` is to use `getCanonicalPath()` to remove any path-traversal elements and then check that `DIR` is a prefix. However, if `DIR` is not slash-terminated, this can unexpectedly allow accessing siblings of `DIR`.

    See also `java/partial-path-traversal`, which is similar to this query, but may also flag non-remotely-exploitable instances of partial path traversal vulnerabilities.


    ## Recommendation
    If the user should only access items within a certain directory `DIR`, ensure that `DIR` is slash-terminated before checking that `DIR` is a prefix of the user-provided path, `SUBDIR`. Note, Java's `getCanonicalPath()` returns a **non**-slash-terminated path string, so a slash must be added to `DIR` if that method is used.


    ## Example
    In this example, the `if` statement checks if `parent.getCanonicalPath()` is a prefix of `dir.getCanonicalPath()`. However, `parent.getCanonicalPath()` is not slash-terminated. This means that users that supply `dir` may be also allowed to access siblings of `parent` and not just children of `parent`, which is a security issue.


    ```java
    public class PartialPathTraversalBad {
        public void example(File dir, File parent) throws IOException {
            if (!dir.getCanonicalPath().startsWith(parent.getCanonicalPath())) {
                throw new IOException("Path traversal attempt: " + dir.getCanonicalPath());
            }
        }
    }

    ```
    In this example, the `if` statement checks if `parent.toPath()` is a prefix of `dir.normalize()`. Because `Path#startsWith` does the correct check that `dir` is a child of `parent`, users will not be able to access siblings of `parent`, as desired.


    ```java
    import java.io.File;

    public class PartialPathTraversalGood {
        public void example(File dir, File parent) throws IOException {
            if (!dir.toPath().normalize().startsWith(parent.toPath())) {
                throw new IOException("Path traversal attempt: " + dir.getCanonicalPath());
            }
        }
    }

    ```

    ## References
    * OWASP: [Partial Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * CVE-2022-23457: [ ESAPI Vulnerability Report](https://github.com/ESAPI/esapi-java-legacy/blob/develop/documentation/GHSL-2022-008_The_OWASP_Enterprise_Security_API.md).
    * Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-074/JndiInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-074/JndiInjection.bqrs
  metadata:
    name: JNDI lookup with user-controlled name
    description: |-
      Performing a JNDI lookup with a user-controlled name can lead to the download of an untrusted
                    object and to execution of arbitrary code.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/jndi-injection
    tags: |-
      security
             external/cwe/cwe-074
  queryHelp: |
    # JNDI lookup with user-controlled name
    The Java Naming and Directory Interface (JNDI) is a Java API for a directory service that allows Java software clients to discover and look up data and resources (in the form of Java objects) via a name. If the name being used to look up the data is controlled by the user, it can point to a malicious server, which can return an arbitrary object. In the worst case, this can allow remote code execution.


    ## Recommendation
    The general recommendation is to avoid passing untrusted data to the `InitialContext.lookup ` method. If the name being used to look up the object must be provided by the user, make sure that it's not in the form of an absolute URL or that it's the URL pointing to a trusted server.


    ## Example
    In the following examples, the code accepts a name from the user, which it uses to look up an object.

    In the first example, the user provided name is used to look up an object.

    The second example validates the name before using it to look up an object.


    ```java
    import javax.naming.Context;
    import javax.naming.InitialContext;

    public void jndiLookup(HttpServletRequest request) throws NamingException {
      String name = request.getParameter("name");

      Hashtable<String, String> env = new Hashtable<String, String>();
      env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.rmi.registry.RegistryContextFactory");
      env.put(Context.PROVIDER_URL, "rmi://trusted-server:1099");
      InitialContext ctx = new InitialContext(env);

      // BAD: User input used in lookup
      ctx.lookup(name);

      // GOOD: The name is validated before being used in lookup
      if (isValid(name)) {
        ctx.lookup(name);
      } else {
        // Reject the request
      }
    }
    ```

    ## References
    * Oracle: [Java Naming and Directory Interface (JNDI)](https://docs.oracle.com/javase/8/docs/technotes/guides/jndi/).
    * Black Hat materials: [A Journey from JNDI/LDAP Manipulation to Remote Code Execution Dream Land](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf).
    * Veracode: [Exploiting JNDI Injections in Java](https://www.veracode.com/blog/research/exploiting-jndi-injections-java).
    * Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-074/XsltInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-074/XsltInjection.bqrs
  metadata:
    name: XSLT transformation with user-controlled stylesheet
    description: |-
      Performing an XSLT transformation with user-controlled stylesheets can lead to
                    information disclosure or execution of arbitrary code.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/xslt-injection
    tags: |-
      security
             external/cwe/cwe-074
  queryHelp: "# XSLT transformation with user-controlled stylesheet\nXSLT (Extensible\
    \ Stylesheet Language Transformations) is a language for transforming XML documents\
    \ into other XML documents or other formats. Processing unvalidated XSLT stylesheets\
    \ can allow attackers to read arbitrary files from the filesystem or to execute\
    \ arbitrary code.\n\n\n## Recommendation\nThe general recommendation is to not\
    \ process untrusted XSLT stylesheets. If user-provided stylesheets must be processed,\
    \ enable the secure processing mode.\n\n\n## Example\nIn the following examples,\
    \ the code accepts an XSLT stylesheet from the user and processes it.\n\nIn the\
    \ first example, the user-provided XSLT stylesheet is parsed and processed.\n\n\
    In the second example, secure processing mode is enabled.\n\n\n```java\nimport\
    \ javax.xml.XMLConstants;\nimport javax.xml.transform.TransformerFactory;\nimport\
    \ javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\
    \npublic void transform(Socket socket, String inputXml) throws Exception {\n \
    \ StreamSource xslt = new StreamSource(socket.getInputStream());\n  StreamSource\
    \ xml = new StreamSource(new StringReader(inputXml));\n  StringWriter result =\
    \ new StringWriter();\n  TransformerFactory factory = TransformerFactory.newInstance();\n\
    \n  // BAD: User provided XSLT stylesheet is processed\n  factory.newTransformer(xslt).transform(xml,\
    \ new StreamResult(result));\n\n  // GOOD: The secure processing mode is enabled\n\
    \  factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n  factory.newTransformer(xslt).transform(xml,\
    \ new StreamResult(result));\n}  \n```\n\n## References\n* Wikipedia: [XSLT](https://en.wikipedia.org/wiki/XSLT).\n\
    * The Java Tutorials: [Transforming XML Data with XSLT](https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html).\n\
    * [XSLT Injection Basics](https://blog.hunniccyber.com/ektron-cms-remote-code-execution-xslt-transform-injection-java/).\n\
    * Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-078/ExecRelative.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-078/ExecRelative.bqrs
  metadata:
    name: Executing a command with a relative path
    description: |-
      Executing a command with a relative path is vulnerable to
                    malicious changes in the PATH environment variable.
    kind: problem
    problem.severity: warning
    security-severity: 5.4
    precision: medium
    id: java/relative-path-command
    tags: |-
      security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: "# Executing a command with a relative path\nWhen a command is executed\
    \ with a relative path, the runtime uses the PATH environment variable to find\
    \ which executable to run. Therefore, any user who can change the PATH environment\
    \ variable can cause the software to run a different, malicious executable.\n\n\
    \n## Recommendation\nIn most cases, simply use a command that has an absolute\
    \ path instead of a relative path.\n\nIn some cases, the location of the executable\
    \ might be different on different installations. In such cases, consider specifying\
    \ the location of key executables with some form of configuration. When using\
    \ this approach, be careful that the configuration system is not itself vulnerable\
    \ to malicious modifications.\n\n\n## Example\n\n```java\nclass Test {\n    public\
    \ static void main(String[] args) {\n        // BAD: relative path\n        Runtime.getRuntime().exec(\"\
    make\");\n        \n        // GOOD: absolute path\n        Runtime.getRuntime().exec(\"\
    /usr/bin/make\");\n\n        // GOOD: build an absolute path from known values\n\
    \        Runtime.getRuntime().exec(Paths.MAKE_PREFIX + \"/bin/make\");\n    }\n\
    }\n```\n\n## References\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n\
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-078/ExecTainted.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-078/ExecTainted.bqrs
  metadata:
    name: Uncontrolled command line
    description: |-
      Using externally controlled strings in a command line is vulnerable to malicious
                    changes in the strings.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/command-line-injection
    tags: |-
      security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Uncontrolled command line
    Code that passes user input directly to `Runtime.exec`, or some other library routine that executes a command, allows the user to execute malicious code.


    ## Recommendation
    If possible, use hard-coded string literals to specify the command to run or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.

    If the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.


    ## Example
    The following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to `Runtime.exec` without examining it first.


    ```java
    class Test {
        public static void main(String[] args) {
            String script = System.getenv("SCRIPTNAME");
            if (script != null) {
                // BAD: The script to be executed is controlled by the user.
                Runtime.getRuntime().exec(script);
            }
        }
    }
    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-078/ExecTaintedEnvironment.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-078/ExecTaintedEnvironment.bqrs
  metadata:
    name: Building a command with an injected environment variable
    description: |-
      Passing environment variables containing externally controlled
                    strings to a command line is vulnerable to malicious changes to the
                    environment of a subprocess.
    problem.severity: error
    kind: path-problem
    security-severity: 9.8
    precision: medium
    id: java/exec-tainted-environment
    tags: |-
      security
          external/cwe/cwe-078
          external/cwe/cwe-088
          external/cwe/cwe-454
  queryHelp: |
    # Building a command with an injected environment variable
    Passing unvalidated user input into the environment variables of a subprocess can allow an attacker to execute malicious code.


    ## Recommendation
    If possible, use hard-coded string literals to specify the environment variable or its value. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.

    If the applicable environment variables cannot be determined at compile time, then add code to verify that the user input string is safe before using it.


    ## Example
    In the following (BAD) example, the environment variable `PATH` is set to the value of the user input `path` without validation.


    ```java
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        String path = request.getParameter("path");

        Map<String, String> env = processBuilder.environment();
        // BAD: path is tainted and being added to the environment
        env.put("PATH", path);

        processBuilder.start();
    }
    ```
    In the following (BAD) example, an environment variable is set with a name that is derived from the user input `var` without validation.


    ```java
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        String attr = request.getParameter("attribute");
        String value = request.getParameter("value");

        Map<String, String> env = processBuilder.environment();
        // BAD: attr and value are tainted and being added to the environment
        env.put(attr, value);

        processBuilder.start();
    }
    ```
    In the following (GOOD) example, the user's input is validated before being used to set the environment variable.


    ```java
    String opt = request.getParameter("opt");
    String value = request.getParameter("value");

    Map<String, String> env = processBuilder.environment();

    // GOOD: opt and value are checked before being added to the environment
    if (permittedJavaOptions.contains(opt) && validOption(opt, value)) {
        env.put(opt, value);
    }
    ```
    In the following (GOOD) example, the user's input is checked and used to determine an environment variable to add.


    ```java
    Map<String, String> env = builder.environment();
    String debug = request.getParameter("debug");

    // GOOD: Checking the value and not tainting the variable added to the environment
    if (debug != null) {
        env.put("PYTHONDEBUG", "1");
    }

    ```

    ## References
    * The Java Tutorials: [Environment Variables](https://docs.oracle.com/javase/tutorial/essential/environment/env.html).
    * OWASP: [Command injection](https://owasp.org/www-community/attacks/Command_Injection).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
    * Common Weakness Enumeration: [CWE-454](https://cwe.mitre.org/data/definitions/454.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-078/ExecUnescaped.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-078/ExecUnescaped.bqrs
  metadata:
    name: Building a command line with string concatenation
    description: |-
      Using concatenated strings in a command line is vulnerable to malicious
                    insertion of special characters in the strings.
    kind: problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/concatenated-command-line
    tags: |-
      security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Building a command line with string concatenation
    Code that builds a command line by concatenating strings that have been entered by a user allows the user to execute malicious code.


    ## Recommendation
    Execute external commands using an array of strings rather than a single string. By using an array, many possible vulnerabilities in the formatting of the string are avoided.


    ## Example
    In the following example, `latlonCoords` contains a string that has been entered by a user but not validated by the program. This allows the user to, for example, append an ampersand (&amp;) followed by the command for a malicious program to the end of the string. The ampersand instructs Windows to execute another program. In the block marked 'BAD', `latlonCoords` is passed to `exec` as part of a concatenated string, which allows more than one command to be executed. However, in the block marked 'GOOD', `latlonCoords` is passed as part of an array, which means that `exec` treats it only as an argument.


    ```java
    class Test {
        public static void main(String[] args) {
            // BAD: user input might include special characters such as ampersands
            {
                String latlonCoords = args[1];
                Runtime rt = Runtime.getRuntime();
                Process exec = rt.exec("cmd.exe /C latlon2utm.exe " + latlonCoords);
            }

            // GOOD: use an array of arguments instead of executing a string
            {
                String latlonCoords = args[1];
                Runtime rt = Runtime.getRuntime();
                Process exec = rt.exec(new String[] {
                        "c:\\path\to\latlon2utm.exe",
                        latlonCoords });
            }
        }
    }

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-079/AndroidWebViewAddJavascriptInterface.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-079/AndroidWebViewAddJavascriptInterface.bqrs
  metadata:
    name: Access Java object methods through JavaScript exposure
    id: java/android/webview-addjavascriptinterface
    description: Exposing a Java object in a WebView with a JavaScript interface can
      lead to malicious JavaScript controlling the application.
    kind: problem
    problem.severity: warning
    security-severity: 6.1
    precision: medium
    tags: |-
      security
             external/cwe/cwe-079
  queryHelp: |
    # Access Java object methods through JavaScript exposure
    Calling the `addJavascriptInterface` method of the `android.webkit.WebView` class allows the web pages of a WebView to access a Java object's methods via JavaScript.

    Objects exposed to JavaScript are available in all frames of the WebView.


    ## Recommendation
    If you need to expose Java objects to JavaScript, guarantee that no untrusted third-party content is loaded into the WebView.


    ## Example
    In the following (bad) example, a Java object is exposed to JavaScript.


    ```java
    import android.webkit.JavascriptInterface;
    import android.database.sqlite.SQLiteOpenHelper;

    class ExposedObject extends SQLiteOpenHelper {
        @JavascriptInterface
        public String studentEmail(String studentName) {
            // SQL injection
            String query = "SELECT email FROM students WHERE studentname = '" + studentName + "'";

            Cursor cursor = db.rawQuery(query, null);
            cursor.moveToFirst();
            String email = cursor.getString(0);

            return email;
        }
    }

    webview.getSettings().setJavaScriptEnabled(true);
    webview.addJavaScriptInterface(new ExposedObject(), "exposedObject");
    webview.loadData("", "text/html", null);

    String name = "Robert'; DROP TABLE students; --";
    webview.loadUrl("javascript:alert(exposedObject.studentEmail(\""+ name +"\"))");

    ```

    ## References
    * Android Documentation: [addJavascriptInterface](https://developer.android.com/reference/android/webkit/WebView#addJavascriptInterface(java.lang.Object,%20java.lang.String))
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-079/AndroidWebViewSettingsEnabledJavaScript.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-079/AndroidWebViewSettingsEnabledJavaScript.bqrs
  metadata:
    name: Android WebView JavaScript settings
    description: Enabling JavaScript execution in a WebView can result in cross-site
      scripting attacks.
    kind: problem
    id: java/android/websettings-javascript-enabled
    problem.severity: warning
    security-severity: 6.1
    precision: medium
    tags: |-
      security
             external/cwe/cwe-079
  queryHelp: |
    # Android WebView JavaScript settings
    Enabling JavaScript in an Android WebView allows the execution of JavaScript code in the context of the running application. This creates a cross-site scripting vulnerability.

    For example, if your application's WebView allows for visiting web pages that you do not trust, it is possible for an attacker to lead the user to a page which loads malicious JavaScript.

    You can enable or disable Javascript execution using the `setJavaScriptEnabled` method of the settings of a WebView.


    ## Recommendation
    JavaScript execution is disabled by default. You can explicitly disable it by calling `setJavaScriptEnabled(false)` on the settings of the WebView.

    If JavaScript is necessary, only load content from trusted servers using encrypted channels, such as HTTPS with certificate verification.


    ## Example
    In the following (bad) example, a WebView has JavaScript enabled in its settings:


    ```java
    WebSettings settings = webview.getSettings();
    settings.setJavaScriptEnabled(true);

    ```
    In the following (good) example, a WebView explicitly disallows JavaScript execution:


    ```java
    WebSettings settings = webview.getSettings();
    settings.setJavaScriptEnabled(false);

    ```

    ## References
    * Android documentation: [setJavaScriptEnabled](https://developer.android.com/reference/android/webkit/WebSettings#setJavaScriptEnabled(boolean))
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-079/XSS.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-079/XSS.bqrs
  metadata:
    name: Cross-site scripting
    description: |-
      Writing user input directly to a web page
                    allows for a cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: java/xss
    tags: |-
      security
             external/cwe/cwe-079
  queryHelp: "# Cross-site scripting\nDirectly writing user input (for example, an\
    \ HTTP request parameter) to a web page, without properly sanitizing the input\
    \ first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\n\
    To guard against cross-site scripting, consider using contextual output encoding/escaping\
    \ before writing user input to the page, or one of the other solutions that are\
    \ mentioned in the reference.\n\n\n## Example\nThe following example shows the\
    \ `page` parameter being written directly to the page, leaving the website vulnerable\
    \ to cross-site scripting.\n\n\n```java\npublic class XSS extends HttpServlet\
    \ {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\
    \tthrows ServletException, IOException {\n\t\t// BAD: a request parameter is written\
    \ directly to the Servlet response stream\n\t\tresponse.getWriter().print(\n\t\
    \t\t\t\"The page \\\"\" + request.getParameter(\"page\") + \"\\\" was not found.\"\
    );\n\n\t}\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention\
    \ Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-089/SqlConcatenated.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-089/SqlConcatenated.bqrs
  metadata:
    name: Query built by concatenation with a possibly-untrusted string
    description: |-
      Building a SQL or Java Persistence query by concatenating a possibly-untrusted string
                    is vulnerable to insertion of malicious code.
    kind: problem
    problem.severity: error
    security-severity: 8.8
    precision: medium
    id: java/concatenated-sql-query
    tags: |-
      security
             external/cwe/cwe-089
             external/cwe/cwe-564
  queryHelp: |
    # Query built by concatenation with a possibly-untrusted string
    Even when the components of a SQL query are not fully controlled by a user, it is a vulnerability to build the query by directly concatenating those components. Perhaps a separate vulnerability will allow the user to gain control of the component. As well, a user who cannot gain full control of an input might influence it enough to cause the SQL query to fail to run.


    ## Recommendation
    Usually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.

    In the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.

    It is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.


    ## Example
    In the following example, the code runs a simple SQL query in two different ways.

    The first way involves building a query, `query1`, by concatenating the result of `getCategory` with some string literals. The result of `getCategory` can include special characters, or it might be refactored later so that it may return something that contains special characters.

    The second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the result of `getCategory` are not given any special treatment.


    ```java
    {
        // BAD: the category might have SQL special characters in it
        String category = getCategory();
        Statement statement = connection.createStatement();
        String query1 = "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='"
            + category + "' ORDER BY PRICE";
        ResultSet results = statement.executeQuery(query1);
    }

    {
        // GOOD: use a prepared query
        String category = getCategory();
        String query2 = "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE";
        PreparedStatement statement = connection.prepareStatement(query2);
        statement.setString(1, category);
        ResultSet results = statement.executeQuery();
    }
    ```

    ## References
    * OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).
    * SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).
    * The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).
    * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).
    * Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-089/SqlTainted.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-089/SqlTainted.bqrs
  metadata:
    name: Query built from user-controlled sources
    description: |-
      Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of
                    malicious code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 8.8
    precision: high
    id: java/sql-injection
    tags: |-
      security
             external/cwe/cwe-089
             external/cwe/cwe-564
  queryHelp: |
    # Query built from user-controlled sources
    If a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.


    ## Recommendation
    Usually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.

    In the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.

    It is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.


    ## Example
    In the following example, the code runs a simple SQL query in two different ways.

    The first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.

    The second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.


    ```java
    {
        // BAD: the category might have SQL special characters in it
        String category = System.getenv("ITEM_CATEGORY");
        Statement statement = connection.createStatement();
        String query1 = "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='"
            + category + "' ORDER BY PRICE";
        ResultSet results = statement.executeQuery(query1);
    }

    {
        // GOOD: use a prepared query
        String category = System.getenv("ITEM_CATEGORY");
        String query2 = "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE";
        PreparedStatement statement = connection.prepareStatement(query2);
        statement.setString(1, category);
        ResultSet results = statement.executeQuery();
    }
    ```

    ## Example
    The following code shows several different ways to run a Java Persistence query.

    The first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.

    The remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:

    1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).
    1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).
    1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).
    1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).
    The parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.


    ```java
    {
        // BAD: the category might have Java Persistence Query Language special characters in it
        String category = System.getenv("ITEM_CATEGORY");
        Statement statement = connection.createStatement();
        String query1 = "SELECT p FROM Product p WHERE p.category LIKE '"
            + category + "' ORDER BY p.price";
        Query q = entityManager.createQuery(query1);
    }

    {
        // GOOD: use a named parameter and set its value
        String category = System.getenv("ITEM_CATEGORY");
        String query2 = "SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price"
        Query q = entityManager.createQuery(query2);
        q.setParameter("category", category);
    }

    {
        // GOOD: use a positional parameter and set its value
        String category = System.getenv("ITEM_CATEGORY");
        String query3 = "SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price"
        Query q = entityManager.createQuery(query3);
        q.setParameter(1, category);
    }

    {
        // GOOD: use a named query with a named parameter and set its value
        @NamedQuery(
                name="lookupByCategory",
                query="SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price")
        private static class NQ {}
        ...
        String category = System.getenv("ITEM_CATEGORY");
        Query namedQuery1 = entityManager.createNamedQuery("lookupByCategory");
        namedQuery1.setParameter("category", category);
    }

    {
        // GOOD: use a named query with a positional parameter and set its value
        @NamedQuery(
                name="lookupByCategory",
                query="SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price")
        private static class NQ {}
        ...
        String category = System.getenv("ITEM_CATEGORY");
        Query namedQuery2 = entityManager.createNamedQuery("lookupByCategory");
        namedQuery2.setParameter(1, category);
    }
    ```

    ## References
    * OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).
    * SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).
    * The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).
    * The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).
    * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).
    * Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-090/LdapInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-090/LdapInjection.bqrs
  metadata:
    name: LDAP query built from user-controlled sources
    description: |-
      Building an LDAP query from user-controlled sources is vulnerable to insertion of
                    malicious LDAP code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/ldap-injection
    tags: |-
      security
             external/cwe/cwe-090
  queryHelp: "# LDAP query built from user-controlled sources\nIf an LDAP query is\
    \ built using string concatenation, and the components of the concatenation include\
    \ user input, a user is likely to be able to run malicious LDAP queries.\n\n\n\
    ## Recommendation\nIf user input must be included in an LDAP query, it should\
    \ be escaped to avoid a malicious user providing special characters that change\
    \ the meaning of the query. If possible build the LDAP query using framework helper\
    \ methods, for example from Spring's `LdapQueryBuilder` and `LdapNameBuilder`,\
    \ instead of string concatenation. Alternatively, escape user input using an appropriate\
    \ LDAP encoding method, for example: `encodeForLDAP` or `encodeForDN` from OWASP\
    \ ESAPI, `LdapEncoder.filterEncode` or `LdapEncoder.nameEncode` from Spring LDAP,\
    \ or `Filter.encodeValue` from UnboundID library.\n\n\n## Example\nIn the following\
    \ examples, the code accepts an \"organization name\" and a \"username\" from\
    \ the user, which it uses to query LDAP.\n\nThe first example concatenates the\
    \ unvalidated and unencoded user input directly into both the DN (Distinguished\
    \ Name) and the search filter used for the LDAP query. A malicious user could\
    \ provide special characters to change the meaning of these queries, and search\
    \ for a completely different set of values. The LDAP query is executed using Java\
    \ JNDI API.\n\nThe second example uses the OWASP ESAPI library to encode the user\
    \ values before they are included in the DN and search filters. This ensures the\
    \ meaning of the query cannot be changed by a malicious user.\n\n\n```java\nimport\
    \ javax.naming.directory.DirContext;\nimport org.owasp.esapi.Encoder;\nimport\
    \ org.owasp.esapi.reference.DefaultEncoder;\n\npublic void ldapQueryBad(HttpServletRequest\
    \ request, DirContext ctx) throws NamingException {\n  String organizationName\
    \ = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"\
    username\");\n\n  // BAD: User input used in DN (Distinguished Name) without encoding\n\
    \  String dn = \"OU=People,O=\" + organizationName;\n\n  // BAD: User input used\
    \ in search filter without encoding\n  String filter = \"username=\" + userName;\n\
    \n  ctx.search(dn, filter, new SearchControls());\n}\n\npublic void ldapQueryGood(HttpServletRequest\
    \ request, DirContext ctx) throws NamingException {\n  String organizationName\
    \ = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"\
    username\");\n\n  // ESAPI encoder\n  Encoder encoder = DefaultEncoder.getInstance();\n\
    \n  // GOOD: Organization name is encoded before being used in DN\n  String safeOrganizationName\
    \ = encoder.encodeForDN(organizationName);\n  String safeDn = \"OU=People,O=\"\
    \ + safeOrganizationName;\n\n  // GOOD: User input is encoded before being used\
    \ in search filter\n  String safeUsername = encoder.encodeForLDAP(username);\n\
    \  String safeFilter = \"username=\" + safeUsername;\n  \n  ctx.search(safeDn,\
    \ safeFilter, new SearchControls());\n}\n```\nThe third example uses Spring `LdapQueryBuilder`\
    \ to build an LDAP query. In addition to simplifying the building of complex search\
    \ parameters, it also provides proper escaping of any unsafe characters in search\
    \ filters. The DN is built using `LdapNameBuilder`, which also provides proper\
    \ escaping.\n\n\n```java\nimport static org.springframework.ldap.query.LdapQueryBuilder.query;\n\
    import org.springframework.ldap.support.LdapNameBuilder;\n\npublic void ldapQueryGood(@RequestParam\
    \ String organizationName, @RequestParam String username) {\n  // GOOD: Organization\
    \ name is encoded before being used in DN\n  String safeDn = LdapNameBuilder.newInstance()\n\
    \    .add(\"O\", organizationName)\n    .add(\"OU=People\")\n    .build().toString();\n\
    \n  // GOOD: User input is encoded before being used in search filter\n  LdapQuery\
    \ query = query()\n    .base(safeDn)\n    .where(\"username\").is(username);\n\
    \n  ldapTemplate.search(query, new AttributeCheckAttributesMapper());\n}\n```\n\
    The fourth example uses `UnboundID` classes, `Filter` and `DN`, to construct a\
    \ safe filter and base DN.\n\n\n```java\nimport com.unboundid.ldap.sdk.LDAPConnection;\n\
    import com.unboundid.ldap.sdk.DN;\nimport com.unboundid.ldap.sdk.RDN;\nimport\
    \ com.unboundid.ldap.sdk.Filter;\n\npublic void ldapQueryGood(HttpServletRequest\
    \ request, LDAPConnection c) {\n  String organizationName = request.getParameter(\"\
    organization_name\");\n  String username = request.getParameter(\"username\");\n\
    \n  // GOOD: Organization name is encoded before being used in DN\n  DN safeDn\
    \ = new DN(new RDN(\"OU\", \"People\"), new RDN(\"O\", organizationName));\n\n\
    \  // GOOD: User input is encoded before being used in search filter\n  Filter\
    \ safeFilter = Filter.createEqualityFilter(\"username\", username);\n  \n  c.search(safeDn.toString(),\
    \ SearchScope.ONE, safeFilter);\n}\n```\nThe fifth example shows how to build\
    \ a safe filter and DN using the Apache LDAP API.\n\n\n```java\nimport org.apache.directory.ldap.client.api.LdapConnection;\n\
    import org.apache.directory.api.ldap.model.name.Dn;\nimport org.apache.directory.api.ldap.model.name.Rdn;\n\
    import org.apache.directory.api.ldap.model.message.SearchRequest;\nimport org.apache.directory.api.ldap.model.message.SearchRequestImpl;\n\
    import static org.apache.directory.ldap.client.api.search.FilterBuilder.equal;\n\
    \npublic void ldapQueryGood(HttpServletRequest request, LdapConnection c) {\n\
    \  String organizationName = request.getParameter(\"organization_name\");\n  String\
    \ username = request.getParameter(\"username\");\n\n  // GOOD: Organization name\
    \ is encoded before being used in DN\n  Dn safeDn = new Dn(new Rdn(\"OU\", \"\
    People\"), new Rdn(\"O\", organizationName));\n\n  // GOOD: User input is encoded\
    \ before being used in search filter\n  String safeFilter = equal(\"username\"\
    , username);\n  \n  SearchRequest searchRequest = new SearchRequestImpl();\n \
    \ searchRequest.setBase(safeDn);\n  searchRequest.setFilter(safeFilter);\n  c.search(searchRequest);\n\
    }\n```\n\n## References\n* OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).\n\
    * OWASP ESAPI: [OWASP ESAPI](https://owasp.org/www-project-enterprise-security-api/).\n\
    * Spring LdapQueryBuilder doc: [LdapQueryBuilder](https://docs.spring.io/spring-ldap/docs/current/apidocs/org/springframework/ldap/query/LdapQueryBuilder.html).\n\
    * Spring LdapNameBuilder doc: [LdapNameBuilder](https://docs.spring.io/spring-ldap/docs/current/apidocs/org/springframework/ldap/support/LdapNameBuilder.html).\n\
    * UnboundID: [Understanding and Defending Against LDAP Injection Attacks](https://ldap.com/2018/05/04/understanding-and-defending-against-ldap-injection-attacks/).\n\
    * Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/ArbitraryApkInstallation.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/ArbitraryApkInstallation.bqrs
  metadata:
    id: java/android/arbitrary-apk-installation
    name: Android APK installation
    description: Creating an intent with a URI pointing to a untrusted file can lead
      to the installation of an untrusted application.
    kind: path-problem
    security-severity: 9.3
    problem.severity: error
    precision: medium
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: |
    # Android APK installation
    Android allows an application to install an Android Package Kit (APK) using an `Intent` with the `"application/vnd.android.package-archive"` MIME type. If the file used in the `Intent` is from a location that is not controlled by the application (for example, an SD card that is universally writable), this can result in the unintended installation of untrusted applications.


    ## Recommendation
    You should install packages using the `PackageInstaller` class.

    If you need to install from a file, you should use a `FileProvider`. Content providers can provide more specific permissions than file system permissions can.

    When your application does not require package installations, do not add the `REQUEST_INSTALL_PACKAGES` permission in the manifest file.


    ## Example
    In the following (bad) example, the package is installed from a file which may be altered by another application:


    ```java
    import android.app.Activity;
    import android.content.Intent;
    import android.net.Uri;
    import android.os.Environment;

    import java.io.File;

    /* Get a file from external storage */
    File file = new File(Environment.getExternalStorageDirectory(), "myapp.apk");
    Intent intent = new Intent(Intent.ACTION_VIEW);
    /* Set the mimetype to APK */
    intent.setDataAndType(Uri.fromFile(file), "application/vnd.android.package-archive");

    startActivity(intent);

    ```
    In the following (good) example, the package is installed by using a `FileProvider`:


    ```java
    import android.app.Activity;
    import android.content.Context;
    import android.content.Intent;
    import android.net.Uri;
    import androidx.core.content.FileProvider;

    import java.io.File;
    import java.io.FileOutputStream;

    String tempFilename = "temporary.apk";
    byte[] buffer = new byte[16384];

    /* Copy application asset into temporary file */
    try (InputStream is = getAssets().open(assetName);
         FileOutputStream fout = openFileOutput(tempFilename, Context.MODE_PRIVATE)) {
        int n;
        while ((n=is.read(buffer)) >= 0) {
            fout.write(buffer, 0, n);
        }
    }

    /* Expose temporary file with FileProvider */
    File toInstall = new File(this.getFilesDir(), tempFilename);
    Uri applicationUri = FileProvider.getUriForFile(this, "com.example.apkprovider", toInstall);

    /* Create Intent and set data to APK file. */
    Intent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE);
    intent.setData(applicationUri);
    intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

    startActivity(intent);

    ```
    In the following (good) example, the package is installed using an instance of the `android.content.pm.PackageInstaller` class:


    ```java
    import android.content.Context;
    import android.content.Intent;
    import android.content.pm.PackageInstaller;

    private static final String PACKAGE_INSTALLED_ACTION =
        "com.example.SESSION_API_PACKAGE_INSTALLED";

    /* Create the package installer and session */
    PackageInstaller packageInstaller = getPackageManager().getPackageInstaller();
    PackageInstaller.SessionParams params =
        new PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL);
    int sessionId = packageInstaller.createSession(params);
    session = packageInstaller.openSession(sessionId);

    /* Load asset into session */
    try (OutputStream packageInSession = session.openWrite("package", 0, -1);
         InputStream is = getAssets().open(assetName)) {
        byte[] buffer = new byte[16384];
        int n;
        while ((n = is.read(buffer)) >= 0) {
            packageInSession.write(buffer, 0, n);
        }
    }

    /* Create status receiver */
    Intent intent = new Intent(this, InstallApkSessionApi.class);
    intent.setAction(PACKAGE_INSTALLED_ACTION);
    PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);
    IntentSender statusReceiver = pendingIntent.getIntentSender();

    /* Commit the session */
    session.commit(statusReceiver);

    ```

    ## References
    * Android Developers: [Intent.ACTION_INSTALL_PACKAGE](https://developer.android.com/reference/android/content/Intent#ACTION_INSTALL_PACKAGE).
    * Android Developers: [Manifest.permission.REQUEST_INSTALL_PACKAGES](https://developer.android.com/reference/android/Manifest.permission#REQUEST_INSTALL_PACKAGES).
    * Android Developers: [PackageInstaller](https://developer.android.com/reference/android/content/pm/PackageInstaller).
    * Android Developers: [FileProvider](https://developer.android.com/reference/androidx/core/content/FileProvider).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/GroovyInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/GroovyInjection.bqrs
  metadata:
    name: Groovy Language injection
    description: |-
      Evaluation of a user-controlled Groovy script
                    may lead to arbitrary code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/groovy-injection
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: "# Groovy Language injection\nApache Groovy is a powerful, optionally\
    \ typed and dynamic language, with static-typing and static compilation capabilities.\
    \ It integrates smoothly with any Java program, and immediately delivers to your\
    \ application powerful features, including scripting capabilities, Domain-Specific\
    \ Language authoring, runtime and compile-time meta-programming and functional\
    \ programming. If a Groovy script is built using attacker-controlled data, and\
    \ then evaluated, then it may allow the attacker to achieve RCE.\n\n\n## Recommendation\n\
    It is generally recommended to avoid using untrusted input in a Groovy evaluation.\
    \ If this is not possible, use a sandbox solution. Developers must also take care\
    \ that Groovy compile-time metaprogramming can also lead to RCE: it is possible\
    \ to achieve RCE by compiling a Groovy script (see the article \"Abusing Meta\
    \ Programming for Unauthenticated RCE!\" linked below). Groovy's `SecureASTCustomizer`\
    \ allows securing source code by controlling what code constructs are permitted.\
    \ This is typically done when using Groovy for its scripting or domain specific\
    \ language (DSL) features. The fundamental problem is that Groovy is a dynamic\
    \ language, yet `SecureASTCustomizer` works by looking at Groovy AST statically.\
    \ This makes it very easy for an attacker to bypass many of the intended checks\
    \ (see \\[Groovy SecureASTCustomizer is harmful\\](https://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful/)).\
    \ Therefore, besides `SecureASTCustomizer`, runtime checks are also necessary\
    \ before calling Groovy methods (see \\[Improved sandboxing of Groovy scripts\\\
    ](https://melix.github.io/blog/2015/03/sandboxing.html)). It is also possible\
    \ to use a block-list method, excluding unwanted classes from being loaded by\
    \ the JVM. This method is not always recommended, because block-lists can be bypassed\
    \ by unexpected values.\n\n\n## Example\nThe following example uses untrusted\
    \ data to evaluate a Groovy script.\n\n\n```java\npublic class GroovyInjection\
    \ {\n    void injectionViaClassLoader(HttpServletRequest request) {    \n    \
    \    String script = request.getParameter(\"script\");\n        final GroovyClassLoader\
    \ classLoader = new GroovyClassLoader();\n        Class groovy = classLoader.parseClass(script);\n\
    \        GroovyObject groovyObj = (GroovyObject) groovy.newInstance();\n    }\n\
    \n    void injectionViaEval(HttpServletRequest request) {\n        String script\
    \ = request.getParameter(\"script\");\n        Eval.me(script);\n    }\n\n   \
    \ void injectionViaGroovyShell(HttpServletRequest request) {\n        GroovyShell\
    \ shell = new GroovyShell();\n        String script = request.getParameter(\"\
    script\");\n        shell.evaluate(script);\n    }\n\n    void injectionViaGroovyShellGroovyCodeSource(HttpServletRequest\
    \ request) {\n        GroovyShell shell = new GroovyShell();\n        String script\
    \ = request.getParameter(\"script\");\n        GroovyCodeSource gcs = new GroovyCodeSource(script,\
    \ \"test\", \"Test\");\n        shell.evaluate(gcs);\n    }\n}\n\n\n```\nThe following\
    \ example uses classloader block-list approach to exclude loading dangerous classes.\n\
    \n\n```java\npublic class SandboxGroovyClassLoader extends ClassLoader {\n   \
    \ public SandboxGroovyClassLoader(ClassLoader parent) {\n        super(parent);\n\
    \    }\n\n    /* override `loadClass` here to prevent loading sensitive classes,\
    \ such as `java.lang.Runtime`, `java.lang.ProcessBuilder`, `java.lang.System`,\
    \ etc.  */\n    /* Note we must also block `groovy.transform.ASTTest`, `groovy.lang.GrabConfig`\
    \ and `org.buildobjects.process.ProcBuilder` to prevent compile-time RCE. */\n\
    \n    static void runWithSandboxGroovyClassLoader() throws Exception {\n     \
    \   // GOOD: route all class-loading via sand-boxing classloader.\n        SandboxGroovyClassLoader\
    \ classLoader = new GroovyClassLoader(new SandboxGroovyClassLoader());\n     \
    \   \n        Class<?> scriptClass = classLoader.parseClass(untrusted.getQueryString());\n\
    \        Object scriptInstance = scriptClass.newInstance();\n        Object result\
    \ = scriptClass.getDeclaredMethod(\"bar\", new Class[]{}).invoke(scriptInstance,\
    \ new Object[]{});\n    }\n}\n```\n\n## References\n* Orange Tsai: [Abusing Meta\
    \ Programming for Unauthenticated RCE!](https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html).\n\
    * Cédric Champeau: [Improved sandboxing of Groovy scripts](https://melix.github.io/blog/2015/03/sandboxing.html).\n\
    * Kohsuke Kawaguchi: [Groovy SecureASTCustomizer is harmful](https://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful/).\n\
    * Welk1n: [Groovy Injection payloads](https://github.com/welk1n/exploiting-groovy-in-Java/).\n\
    * Charles Chan: [Secure Groovy Script Execution in a Sandbox](https://levelup.gitconnected.com/secure-groovy-script-execution-in-a-sandbox-ea39f80ee87/).\n\
    * Eugene: [Scripting and sandboxing in a JVM environment](https://stringconcat.com/en/scripting-and-sandboxing/).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/InsecureBeanValidation.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/InsecureBeanValidation.bqrs
  metadata:
    name: Insecure Bean Validation
    description: "User-controlled data may be evaluated as a Java EL expression, leading\
      \ to arbitrary code execution."
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/insecure-bean-validation
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: "# Insecure Bean Validation\nCustom error messages for constraint validators\
    \ support different types of interpolation, including [Java EL expressions](https://docs.jboss.org/hibernate/validator/5.1/reference/en-US/html/chapter-message-interpolation.html#section-interpolation-with-message-expressions).\
    \ Controlling part of the message template being passed to `ConstraintValidatorContext.buildConstraintViolationWithTemplate()`\
    \ argument can lead to arbitrary Java code execution. Unfortunately, it is common\
    \ that validated (and therefore, normally untrusted) bean properties flow into\
    \ the custom error message.\n\n\n## Recommendation\nThere are different approaches\
    \ to remediate the issue:\n\n* Do not include validated bean properties in the\
    \ custom error message.\n* Use parameterized messages instead of string concatenation.\
    \ For example:\n```\nHibernateConstraintValidatorContext context =\n   constraintValidatorContext.unwrap(HibernateConstraintValidatorContext.class);\n\
    context.addMessageParameter(\"foo\", \"bar\");\ncontext.buildConstraintViolationWithTemplate(\"\
    My violation message contains a parameter {foo}\")\n   .addConstraintViolation();\n\
    ```\n* Sanitize the validated bean properties to make sure that there are no EL\
    \ expressions. An example of valid sanitization logic can be found [here](https://github.com/hibernate/hibernate-validator/blob/master/engine/src/main/java/org/hibernate/validator/internal/engine/messageinterpolation/util/InterpolationHelper.java#L17).\n\
    * Disable the EL interpolation and only use `ParameterMessageInterpolator`:\n\
    ```\nValidator validator = Validation.byDefaultProvider()\n   .configure()\n \
    \  .messageInterpolator(new ParameterMessageInterpolator())\n   .buildValidatorFactory()\n\
    \   .getValidator();\n```\n* Replace Hibernate Validator with Apache BVal, which\
    \ in its latest version does not interpolate EL expressions by default. Note that\
    \ this replacement may not be a simple drop-in replacement.\n\n## Example\nThe\
    \ following validator could result in arbitrary Java code execution:\n\n\n```java\n\
    import javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\n\
    import org.hibernate.validator.constraintvalidation.HibernateConstraintValidatorContext;\n\
    import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class\
    \ TestValidator implements ConstraintValidator<Object, String> {\n\n    public\
    \ static class InterpolationHelper {\n\n        public static final char BEGIN_TERM\
    \ = '{';\n        public static final char END_TERM = '}';\n        public static\
    \ final char EL_DESIGNATOR = '$';\n        public static final char ESCAPE_CHARACTER\
    \ = '\\\\';\n\n        private static final Pattern ESCAPE_MESSAGE_PARAMETER_PATTERN\
    \ = Pattern.compile( \"([\\\\\" + ESCAPE_CHARACTER + BEGIN_TERM + END_TERM + EL_DESIGNATOR\
    \ + \"])\" );\n\n        private InterpolationHelper() {\n        }\n\n      \
    \  public static String escapeMessageParameter(String messageParameter) {\n  \
    \          if ( messageParameter == null ) {\n                return null;\n \
    \           }\n            return ESCAPE_MESSAGE_PARAMETER_PATTERN.matcher( messageParameter\
    \ ).replaceAll( Matcher.quoteReplacement( String.valueOf( ESCAPE_CHARACTER ) )\
    \ + \"$1\" );\n        }\n\n    }\n\n    @Override\n    public boolean isValid(String\
    \ object, ConstraintValidatorContext constraintContext) {\n        String value\
    \ = object + \" is invalid\";\n\n        // Bad: Bean properties (normally user-controlled)\
    \ are passed directly to `buildConstraintViolationWithTemplate`\n        constraintContext.buildConstraintViolationWithTemplate(value).addConstraintViolation().disableDefaultConstraintViolation();\n\
    \n        // Good: Bean properties (normally user-controlled) are escaped \n \
    \       String escaped = InterpolationHelper.escapeMessageParameter(value);\n\
    \        constraintContext.buildConstraintViolationWithTemplate(escaped).addConstraintViolation().disableDefaultConstraintViolation();\n\
    \n        // Good: Bean properties (normally user-controlled) are parameterized\n\
    \        HibernateConstraintValidatorContext context = constraintContext.unwrap(\
    \ HibernateConstraintValidatorContext.class );\n        context.addMessageParameter(\
    \ \"prop\", object );\n        context.buildConstraintViolationWithTemplate( \"\
    {prop} is invalid\").addConstraintViolation();\n        return false;\n    }\n\
    \n}\n\n```\n\n## References\n* Hibernate Reference Guide: [ConstraintValidatorContext](https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#_the_code_constraintvalidatorcontext_code).\n\
    * GitHub Security Lab research: [Bean validation](https://securitylab.github.com/research/bean-validation-RCE).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/JexlInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/JexlInjection.bqrs
  metadata:
    name: Expression language injection (JEXL)
    description: |-
      Evaluation of a user-controlled JEXL expression
                    may lead to arbitrary code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/jexl-expression-injection
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: "# Expression language injection (JEXL)\nJava EXpression Language (JEXL)\
    \ is a simple expression language provided by the Apache Commons JEXL library.\
    \ The syntax is close to a mix of ECMAScript and shell-script. The language allows\
    \ invocation of methods available in the JVM. If a JEXL expression is built using\
    \ attacker-controlled data, and then evaluated, then it may allow the attacker\
    \ to run arbitrary code.\n\n\n## Recommendation\nIt is generally recommended to\
    \ avoid using untrusted input in a JEXL expression. If it is not possible, JEXL\
    \ expressions should be run in a sandbox that allows accessing only explicitly\
    \ allowed classes.\n\n\n## Example\nThe following example uses untrusted data\
    \ to build and run a JEXL expression.\n\n\n```java\npublic void evaluate(Socket\
    \ socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n\
    \        new InputStreamReader(socket.getInputStream()))) {\n    \n    String\
    \ input = reader.readLine();\n    JexlEngine jexl = new JexlBuilder().create();\n\
    \    JexlExpression expression = jexl.createExpression(input);\n    JexlContext\
    \ context = new MapContext();\n    expression.evaluate(context);\n  }\n}\n```\n\
    The next example shows how an untrusted JEXL expression can be run in a sandbox\
    \ that allows accessing only methods in the `java.lang.Math` class. The sandbox\
    \ is implemented using `JexlSandbox` class that is provided by Apache Commons\
    \ JEXL 3.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException\
    \ {\n  try (BufferedReader reader = new BufferedReader(\n        new InputStreamReader(socket.getInputStream())))\
    \ {\n    \n    JexlSandbox onlyMath = new JexlSandbox(false);\n    onlyMath.white(\"\
    java.lang.Math\");\n    JexlEngine jexl = new JexlBuilder().sandbox(onlyMath).create();\n\
    \      \n    String input = reader.readLine();\n    JexlExpression expression\
    \ = jexl.createExpression(input);\n    JexlContext context = new MapContext();\n\
    \    expression.evaluate(context);\n  }\n}\n```\nThe next example shows another\
    \ way how a sandbox can be implemented. It uses a custom implementation of `JexlUberspect`\
    \ that checks if callees are instances of allowed classes.\n\n\n```java\npublic\
    \ void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader\
    \ = new BufferedReader(\n        new InputStreamReader(socket.getInputStream())))\
    \ {\n    \n    JexlUberspect sandbox = new JexlUberspectSandbox();\n    JexlEngine\
    \ jexl = new JexlBuilder().uberspect(sandbox).create();\n      \n    String input\
    \ = reader.readLine();\n    JexlExpression expression = jexl.createExpression(input);\n\
    \    JexlContext context = new MapContext();\n    expression.evaluate(context);\n\
    \  }\n\n  private static class JexlUberspectSandbox implements JexlUberspect {\n\
    \n    private static final List<String> ALLOWED_CLASSES =\n              Arrays.asList(\"\
    java.lang.Math\", \"java.util.Random\");\n\n    private final JexlUberspect uberspect\
    \ = new JexlBuilder().create().getUberspect();\n\n    private void checkAccess(Object\
    \ obj) {\n      if (!ALLOWED_CLASSES.contains(obj.getClass().getCanonicalName()))\
    \ {\n        throw new AccessControlException(\"Not allowed\");\n      }\n   \
    \ }\n\n    @Override\n    public JexlMethod getMethod(Object obj, String method,\
    \ Object... args) {\n      checkAccess(obj);\n      return uberspect.getMethod(obj,\
    \ method, args);\n    }\n\n    @Override\n    public List<PropertyResolver> getResolvers(JexlOperator\
    \ op, Object obj) {\n      checkAccess(obj);\n      return uberspect.getResolvers(op,\
    \ obj);\n    }\n\n    @Override\n    public void setClassLoader(ClassLoader loader)\
    \ {\n      uberspect.setClassLoader(loader);\n    }\n\n    @Override\n    public\
    \ int getVersion() {\n      return uberspect.getVersion();\n    }\n\n    @Override\n\
    \    public JexlMethod getConstructor(Object obj, Object... args) {\n      checkAccess(obj);\n\
    \      return uberspect.getConstructor(obj, args);\n    }\n\n    @Override\n \
    \   public JexlPropertyGet getPropertyGet(Object obj, Object identifier) {\n \
    \     checkAccess(obj);\n      return uberspect.getPropertyGet(obj, identifier);\n\
    \    }\n\n    @Override\n    public JexlPropertyGet getPropertyGet(List<PropertyResolver>\
    \ resolvers, Object obj, Object identifier) {\n      checkAccess(obj);\n     \
    \ return uberspect.getPropertyGet(resolvers, obj, identifier);\n    }\n\n    @Override\n\
    \    public JexlPropertySet getPropertySet(Object obj, Object identifier, Object\
    \ arg) {\n      checkAccess(obj);\n      return uberspect.getPropertySet(obj,\
    \ identifier, arg);\n    }\n\n    @Override\n    public JexlPropertySet getPropertySet(List<PropertyResolver>\
    \ resolvers, Object obj, Object identifier, Object arg) {\n      checkAccess(obj);\n\
    \      return uberspect.getPropertySet(resolvers, obj, identifier, arg);\n   \
    \ }\n\n    @Override\n    public Iterator<?> getIterator(Object obj) {\n     \
    \ checkAccess(obj);\n      return uberspect.getIterator(obj);\n    }\n\n    @Override\n\
    \    public JexlArithmetic.Uberspect getArithmetic(JexlArithmetic arithmetic)\
    \ {\n      return uberspect.getArithmetic(arithmetic);\n    } \n  }\n}\n```\n\n\
    ## References\n* Apache Commons JEXL: [Project page](https://commons.apache.org/proper/commons-jexl/).\n\
    * Apache Commons JEXL documentation: [JEXL 2.1.1 API](https://commons.apache.org/proper/commons-jexl/javadocs/apidocs-2.1.1/).\n\
    * Apache Commons JEXL documentation: [JEXL 3.1 API](https://commons.apache.org/proper/commons-jexl/apidocs/index.html).\n\
    * OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/MvelInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/MvelInjection.bqrs
  metadata:
    name: Expression language injection (MVEL)
    description: |-
      Evaluation of a user-controlled MVEL expression
                    may lead to remote code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/mvel-expression-injection
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: "# Expression language injection (MVEL)\nMVEL is an expression language\
    \ based on Java-syntax, which offers many features including invocation of methods\
    \ available in the JVM. If a MVEL expression is built using attacker-controlled\
    \ data, and then evaluated, then it may allow attackers to run arbitrary code.\n\
    \n\n## Recommendation\nIncluding user input in a MVEL expression should be avoided.\n\
    \n\n## Example\nIn the following sample, the first example uses untrusted data\
    \ to build a MVEL expression and then runs it in the default context. In the second\
    \ example, the untrusted data is validated with a custom method that checks that\
    \ the expression does not contain unexpected code before evaluating it.\n\n\n\
    ```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader\
    \ reader = new BufferedReader(\n    new InputStreamReader(socket.getInputStream())))\
    \ {\n  \n    String expression = reader.readLine();\n    // BAD: the user-provided\
    \ expression is directly evaluated\n    MVEL.eval(expression);\n  }\n}\n\npublic\
    \ void safeEvaluate(Socket socket) throws IOException {\n  try (BufferedReader\
    \ reader = new BufferedReader(\n    new InputStreamReader(socket.getInputStream())))\
    \ {\n  \n    String expression = reader.readLine();\n    // GOOD: the user-provided\
    \ expression is validated before evaluation\n    validateExpression(expression);\n\
    \    MVEL.eval(expression);\n  }\n}\n\nprivate void validateExpression(String\
    \ expression) {\n  // Validate that the expression does not contain unexpected\
    \ code.\n  // For instance, this can be done with allow-lists or deny-lists of\
    \ code patterns.\n}\n```\n\n## References\n* MVEL Documentation: [Language Guide\
    \ for 2.0](http://mvel.documentnode.com/).\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/SpelInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/SpelInjection.bqrs
  metadata:
    name: Expression language injection (Spring)
    description: |-
      Evaluation of a user-controlled Spring Expression Language (SpEL) expression
                    may lead to remote code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/spel-expression-injection
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: "# Expression language injection (Spring)\nThe Spring Expression Language\
    \ (SpEL) is a powerful expression language provided by the Spring Framework. The\
    \ language offers many features including invocation of methods available in the\
    \ JVM. If a SpEL expression is built using attacker-controlled data, and then\
    \ evaluated in a powerful context, then it may allow the attacker to run arbitrary\
    \ code.\n\nThe `SpelExpressionParser` class parses a SpEL expression string and\
    \ returns an `Expression` instance that can be then evaluated by calling one of\
    \ its methods. By default, an expression is evaluated in a powerful `StandardEvaluationContext`\
    \ that allows the expression to access other methods available in the JVM.\n\n\
    \n## Recommendation\nIn general, including user input in a SpEL expression should\
    \ be avoided. If user input must be included in the expression, it should be then\
    \ evaluated in a limited context that doesn't allow arbitrary method invocation.\n\
    \n\n## Example\nThe following example uses untrusted data to build a SpEL expression\
    \ and then runs it in the default powerful context.\n\n\n```java\npublic Object\
    \ evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader =\
    \ new BufferedReader(\n      new InputStreamReader(socket.getInputStream())))\
    \ {\n\n    String string = reader.readLine();\n    ExpressionParser parser = new\
    \ SpelExpressionParser();\n    Expression expression = parser.parseExpression(string);\n\
    \    return expression.getValue();\n  }\n}\n```\nThe next example shows how an\
    \ untrusted SpEL expression can be run in `SimpleEvaluationContext` that doesn't\
    \ allow accessing arbitrary methods. However, it's recommended to avoid using\
    \ untrusted input in SpEL expressions.\n\n\n```java\npublic Object evaluate(Socket\
    \ socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n\
    \      new InputStreamReader(socket.getInputStream()))) {\n\n    String string\
    \ = reader.readLine();\n    ExpressionParser parser = new SpelExpressionParser();\n\
    \    Expression expression = parser.parseExpression(string);\n    SimpleEvaluationContext\
    \ context \n        = SimpleEvaluationContext.forReadWriteDataBinding().build();\n\
    \    return expression.getValue(context);\n  }\n}\n```\n\n## References\n* Spring\
    \ Framework Reference Documentation: [Spring Expression Language (SpEL)](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html).\n\
    * OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-094/TemplateInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-094/TemplateInjection.bqrs
  metadata:
    name: Server-side template injection
    description: Untrusted input interpreted as a template can lead to remote code
      execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/server-side-template-injection
    tags: |-
      security
             external/cwe/cwe-1336
             external/cwe/cwe-094
  queryHelp: "# Server-side template injection\nTemplate injection occurs when user\
    \ input is embedded in a template's code in an unsafe manner. An attacker can\
    \ use native template syntax to inject a malicious payload into a template, which\
    \ is then executed server-side. This permits the attacker to run arbitrary code\
    \ in the server's context.\n\n\n## Recommendation\nTo fix this, ensure that untrusted\
    \ input is not used as part of a template's code. If the application requirements\
    \ do not allow this, use a sandboxed environment where access to unsafe attributes\
    \ and methods is prohibited.\n\n\n## Example\nIn the example given below, an untrusted\
    \ HTTP parameter `code` is used as a Velocity template string. This can lead to\
    \ remote code execution.\n\n\n```java\n@Controller\npublic class VelocitySSTI\
    \ {\n\n\t@GetMapping(value = \"bad\")\n\tpublic void bad(HttpServletRequest request)\
    \ {\n\t\tVelocity.init();\n\n\t\tString code = request.getParameter(\"code\");\n\
    \n\t\tVelocityContext context = new VelocityContext();\n\n\t\tcontext.put(\"name\"\
    , \"Velocity\");\n\t\tcontext.put(\"project\", \"Jakarta\");\n\n\t\tStringWriter\
    \ w = new StringWriter();\n\t\t// evaluate( Context context, Writer out, String\
    \ logTag, String instring )\n\t\tVelocity.evaluate(context, w, \"mystring\", code);\n\
    \t}\n}\n\n```\nIn the next example, the problem is avoided by using a fixed template\
    \ string `s`. Since the template's code is not attacker-controlled in this case,\
    \ this solution prevents the execution of untrusted code.\n\n\n```java\n@Controller\n\
    public class VelocitySSTI {\n\n\t@GetMapping(value = \"good\")\n\tpublic void\
    \ good(HttpServletRequest request) {\n\t\tVelocity.init();\n\t\tVelocityContext\
    \ context = new VelocityContext();\n\n\t\tcontext.put(\"name\", \"Velocity\");\n\
    \t\tcontext.put(\"project\", \"Jakarta\");\n\n\t\tString s = \"We are using $project\
    \ $name to render this.\";\n\t\tStringWriter w = new StringWriter();\n\t\tVelocity.evaluate(context,\
    \ w, \"mystring\", s);\n\t\tSystem.out.println(\" string : \" + w);\n\t}\n}\n\n\
    ```\n\n## References\n* Portswigger: [Server Side Template Injection](https://portswigger.net/web-security/server-side-template-injection).\n\
    * Common Weakness Enumeration: [CWE-1336](https://cwe.mitre.org/data/definitions/1336.html).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-1104/MavenPomDependsOnBintray.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-1104/MavenPomDependsOnBintray.bqrs
  metadata:
    name: Depending upon JCenter/Bintray as an artifact repository
    description: Using a deprecated artifact repository may eventually give attackers
      access for a supply chain attack.
    kind: problem
    problem.severity: error
    security-severity: 6.5
    precision: very-high
    id: java/maven/dependency-upon-bintray
    tags: |-
      security
             external/cwe/cwe-1104
  queryHelp: |
    # Depending upon JCenter/Bintray as an artifact repository
    [Bintray and JCenter are shutting down on February 1st, 2022](https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/). Relying upon repositories that are deprecated or scheduled to be shutdown can have unintended consequences; for example, artifacts being resolved from a different artifact server or a total failure of the CI build.

    When artifact repositories are left unmaintained for a long period of time, vulnerabilities may emerge. Theoretically, this could allow attackers to inject malicious code into the artifacts that you are resolving and infect build artifacts that are being produced. This can be used by attackers to perform a [supply chain attack](https://en.wikipedia.org/wiki/Supply_chain_attack) against your project's users.


    ## Recommendation
    Always use the canonical repository for resolving your dependencies.


    ## Example
    The following example shows locations in a Maven POM file where artifact repository upload/download is configured. The use of Bintray in any of these locations is not advised.


    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

        <modelVersion>4.0.0</modelVersion>

        <groupId>com.semmle</groupId>
        <artifactId>parent</artifactId>
        <version>1.0</version>
        <packaging>pom</packaging>

        <name>Bintray Usage</name>
        <description>An example of using bintray to download and upload dependencies</description>

        <distributionManagement>
            <repository>
                <id>jcenter</id>
                <name>JCenter</name>
                <!-- BAD! Don't use JCenter -->
                <url>https://jcenter.bintray.com</url>
            </repository>
            <snapshotRepository>
                <id>jcenter-snapshots</id>
                <name>JCenter</name>
                <!-- BAD! Don't use JCenter -->
                <url>https://jcenter.bintray.com</url>
            </snapshotRepository>
        </distributionManagement>
        <repositories>
            <repository>
                <id>jcenter</id>
                <name>JCenter</name>
                <!-- BAD! Don't use JCenter -->
                <url>https://jcenter.bintray.com</url>
            </repository>
        </repositories>
        <repositories>
            <repository>
                <id>jcenter</id>
                <name>JCenter</name>
                <!-- BAD! Don't use Bintray -->
                <url>https://dl.bintray.com/groovy/maven</url>
            </repository>
        </repositories>
        <pluginRepositories>
            <pluginRepository>
                <id>jcenter-plugins</id>
                <name>JCenter</name>
                <!-- BAD! Don't use JCenter -->
                <url>https://jcenter.bintray.com</url>
            </pluginRepository>
        </pluginRepositories>
    </project>

    ```

    ## References
    * JFrog blog: [ Into the Sunset on May 1st: Bintray, JCenter, GoCenter, and ChartCenter ](https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/)
    * Common Weakness Enumeration: [CWE-1104](https://cwe.mitre.org/data/definitions/1104.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-113/NettyResponseSplitting.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-113/NettyResponseSplitting.bqrs
  metadata:
    name: Disabled Netty HTTP header validation
    description: |-
      Disabling HTTP header validation makes code vulnerable to
                    attack by header splitting if user input is written directly to
                    an HTTP header.
    kind: problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: java/netty-http-request-or-response-splitting
    tags: |-
      security
             external/cwe/cwe-93
             external/cwe/cwe-113
  queryHelp: "# Disabled Netty HTTP header validation\nDirectly writing user input\
    \ (for example, an HTTP request parameter) to an HTTP header can lead to an HTTP\
    \ request-splitting or response-splitting vulnerability.\n\nHTTP response splitting\
    \ can lead to vulnerabilities such as XSS and cache poisoning.\n\nHTTP request\
    \ splitting can allow an attacker to inject an additional HTTP request into a\
    \ client's outgoing socket connection. This can allow an attacker to perform an\
    \ SSRF-like attack.\n\nIn the context of a servlet container, if the user input\
    \ includes blank lines and the servlet container does not escape the blank lines,\
    \ then a remote user can cause the response to turn into two separate responses.\
    \ The remote user can then control one or more responses, which is also HTTP response\
    \ splitting.\n\n\n## Recommendation\nGuard against HTTP header splitting in the\
    \ same way as guarding against cross-site scripting. Before passing any data into\
    \ HTTP headers, either check the data for special characters, or escape any special\
    \ characters that are present.\n\nIf the code calls Netty API's directly, ensure\
    \ that the `validateHeaders` parameter is set to `true`.\n\n\n## Example\nThe\
    \ following example shows the 'name' parameter being written to a cookie in two\
    \ different ways. The first way writes it directly to the cookie, and thus is\
    \ vulnerable to response-splitting attacks. The second way first removes all special\
    \ characters, thus avoiding the potential problem.\n\n\n```java\npublic class\
    \ ResponseSplitting extends HttpServlet {\n\tprotected void doGet(HttpServletRequest\
    \ request, HttpServletResponse response)\n\tthrows ServletException, IOException\
    \ {\n\t\t// BAD: setting a cookie with an unvalidated parameter\n\t\tCookie cookie\
    \ = new Cookie(\"name\", request.getParameter(\"name\"));\n\t\tresponse.addCookie(cookie);\n\
    \n\t\t// GOOD: remove special characters before putting them in the header\n\t\
    \tString name = removeSpecial(request.getParameter(\"name\"));\n\t\tCookie cookie2\
    \ = new Cookie(\"name\", name);\n\t\tresponse.addCookie(cookie2);\n\t}\n\n\tprivate\
    \ static String removeSpecial(String str) {\n\t\treturn str.replaceAll(\"[^a-zA-Z\
    \ ]\", \"\");\n\t}\n}\n\n```\n\n## Example\nThe following example shows the use\
    \ of the library 'netty' with HTTP response-splitting verification configurations.\
    \ The second way will verify the parameters before using them to build the HTTP\
    \ response.\n\n\n```java\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\n\
    \npublic class ResponseSplitting {\n    // BAD: Disables the internal response\
    \ splitting verification\n    private final DefaultHttpHeaders badHeaders = new\
    \ DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain\
    \ CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\
    \n    // BAD: Disables the internal response splitting verification\n    private\
    \ final DefaultHttpResponse badResponse = new DefaultHttpResponse(version, httpResponseStatus,\
    \ false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n\
    \    private final DefaultHttpResponse goodResponse = new DefaultHttpResponse(version,\
    \ httpResponseStatus);\n}\n\n```\n\n## Example\nThe following example shows the\
    \ use of the netty library with configurations for verification of HTTP request\
    \ splitting. The second recommended approach in the example verifies the parameters\
    \ before using them to build the HTTP request.\n\n\n```java\npublic class NettyRequestSplitting\
    \ {\n    // BAD: Disables the internal request splitting verification\n    private\
    \ final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n   \
    \ // GOOD: Verifies headers passed don't contain CRLF characters\n    private\
    \ final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD:\
    \ Disables the internal request splitting verification\n    private final DefaultHttpRequest\
    \ badRequest = new DefaultHttpRequest(httpVersion, method, uri, false);\n\n  \
    \  // GOOD: Verifies headers passed don't contain CRLF characters\n    private\
    \ final DefaultHttpRequest goodResponse = new DefaultHttpRequest(httpVersion,\
    \ method, uri);\n}\n\n```\n\n## References\n* SecLists.org: [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n\
    * OWASP: [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n\
    * Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n\
    * CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n\
    * Common Weakness Enumeration: [CWE-93](https://cwe.mitre.org/data/definitions/93.html).\n\
    * Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-113/ResponseSplitting.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-113/ResponseSplitting.bqrs
  metadata:
    name: HTTP response splitting
    description: |-
      Writing user input directly to an HTTP header
                    makes code vulnerable to attack by header splitting.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: java/http-response-splitting
    tags: |-
      security
             external/cwe/cwe-113
  queryHelp: "# HTTP response splitting\nDirectly writing user input (for example,\
    \ an HTTP request parameter) to an HTTP header can lead to an HTTP request-splitting\
    \ or response-splitting vulnerability.\n\nHTTP response splitting can lead to\
    \ vulnerabilities such as XSS and cache poisoning.\n\nHTTP request splitting can\
    \ allow an attacker to inject an additional HTTP request into a client's outgoing\
    \ socket connection. This can allow an attacker to perform an SSRF-like attack.\n\
    \nIn the context of a servlet container, if the user input includes blank lines\
    \ and the servlet container does not escape the blank lines, then a remote user\
    \ can cause the response to turn into two separate responses. The remote user\
    \ can then control one or more responses, which is also HTTP response splitting.\n\
    \n\n## Recommendation\nGuard against HTTP header splitting in the same way as\
    \ guarding against cross-site scripting. Before passing any data into HTTP headers,\
    \ either check the data for special characters, or escape any special characters\
    \ that are present.\n\nIf the code calls Netty API's directly, ensure that the\
    \ `validateHeaders` parameter is set to `true`.\n\n\n## Example\nThe following\
    \ example shows the 'name' parameter being written to a cookie in two different\
    \ ways. The first way writes it directly to the cookie, and thus is vulnerable\
    \ to response-splitting attacks. The second way first removes all special characters,\
    \ thus avoiding the potential problem.\n\n\n```java\npublic class ResponseSplitting\
    \ extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse\
    \ response)\n\tthrows ServletException, IOException {\n\t\t// BAD: setting a cookie\
    \ with an unvalidated parameter\n\t\tCookie cookie = new Cookie(\"name\", request.getParameter(\"\
    name\"));\n\t\tresponse.addCookie(cookie);\n\n\t\t// GOOD: remove special characters\
    \ before putting them in the header\n\t\tString name = removeSpecial(request.getParameter(\"\
    name\"));\n\t\tCookie cookie2 = new Cookie(\"name\", name);\n\t\tresponse.addCookie(cookie2);\n\
    \t}\n\n\tprivate static String removeSpecial(String str) {\n\t\treturn str.replaceAll(\"\
    [^a-zA-Z ]\", \"\");\n\t}\n}\n\n```\n\n## Example\nThe following example shows\
    \ the use of the library 'netty' with HTTP response-splitting verification configurations.\
    \ The second way will verify the parameters before using them to build the HTTP\
    \ response.\n\n\n```java\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\n\
    \npublic class ResponseSplitting {\n    // BAD: Disables the internal response\
    \ splitting verification\n    private final DefaultHttpHeaders badHeaders = new\
    \ DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain\
    \ CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\
    \n    // BAD: Disables the internal response splitting verification\n    private\
    \ final DefaultHttpResponse badResponse = new DefaultHttpResponse(version, httpResponseStatus,\
    \ false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n\
    \    private final DefaultHttpResponse goodResponse = new DefaultHttpResponse(version,\
    \ httpResponseStatus);\n}\n\n```\n\n## Example\nThe following example shows the\
    \ use of the netty library with configurations for verification of HTTP request\
    \ splitting. The second recommended approach in the example verifies the parameters\
    \ before using them to build the HTTP request.\n\n\n```java\npublic class NettyRequestSplitting\
    \ {\n    // BAD: Disables the internal request splitting verification\n    private\
    \ final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n   \
    \ // GOOD: Verifies headers passed don't contain CRLF characters\n    private\
    \ final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD:\
    \ Disables the internal request splitting verification\n    private final DefaultHttpRequest\
    \ badRequest = new DefaultHttpRequest(httpVersion, method, uri, false);\n\n  \
    \  // GOOD: Verifies headers passed don't contain CRLF characters\n    private\
    \ final DefaultHttpRequest goodResponse = new DefaultHttpRequest(httpVersion,\
    \ method, uri);\n}\n\n```\n\n## References\n* SecLists.org: [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n\
    * OWASP: [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n\
    * Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n\
    * CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n\
    * Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-117/LogInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-117/LogInjection.bqrs
  metadata:
    name: Log Injection
    description: |-
      Building log entries from user-controlled data may allow
                    insertion of forged log entries by malicious users.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: medium
    id: java/log-injection
    tags: |-
      security
             external/cwe/cwe-117
  queryHelp: |
    # Log Injection
    If unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.

    Forgery can occur if a user provides some input creating the appearance of multiple log entries. This can include unescaped new-line characters, or HTML or other markup.


    ## Recommendation
    User input should be suitably sanitized before it is logged.

    If the log entries are plain text then line breaks should be removed from user input, using for example `String replace(char oldChar, char newChar)` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.

    For log entries that will be displayed in HTML, user input should be HTML encoded before being logged, to prevent forgery and other forms of HTML injection.


    ## Example
    In the first example, a username, provided by the user, is logged using `logger.warn` (from `org.slf4j.Logger`). In the first case (`/bad` endpoint), the username is logged without any sanitization. If a malicious user provides `Guest'%0AUser:'Admin` as a username parameter, the log entry will be split into two separate lines, where the first line will be `User:'Guest'` and the second one will be `User:'Admin'`.


    ```java
    package com.example.restservice;

    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;

    @RestController
    public class LogInjection {

        private final Logger log = LoggerFactory.getLogger(LogInjection.class);

        // /bad?username=Guest'%0AUser:'Admin
        @GetMapping("/bad")
        public String bad(@RequestParam(value = "username", defaultValue = "name") String username) {
            log.warn("User:'{}'", username);
            // The logging call above would result in multiple log entries as shown below:
            // User:'Guest'
            // User:'Admin'
            return username;
        }
    }


    ```
    In the second example (`/good` endpoint), `matches()` is used to ensure the user input only has alphanumeric characters. If a malicious user provides \`Guest'%0AUser:'Admin\` as a username parameter, the log entry will not be logged at all, preventing the injection.


    ```java
    package com.example.restservice;

    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;

    @RestController
    public class LogInjection {

        private final Logger log = LoggerFactory.getLogger(LogInjection.class);

        // /good?username=Guest'%0AUser:'Admin
        @GetMapping("/good")
        public String good(@RequestParam(value = "username", defaultValue = "name") String username) {
            // The regex check here, allows only alphanumeric characters to pass.
            // Hence, does not result in log injection
            if (username.matches("\\w*")) {
                log.warn("User:'{}'", username);

                return username;
            }
        }
    }

    ```

    ## References
    * OWASP: [Log Injection](https://owasp.org/www-community/attacks/Log_Injection).
    * Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-1204/StaticInitializationVector.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-1204/StaticInitializationVector.bqrs
  metadata:
    name: Using a static initialization vector for encryption
    description: "An initialization vector (IV) used for ciphers of certain modes\
      \ (such as CBC or GCM) should be unique and unpredictable, to maximize encryption\
      \ and prevent dictionary attacks."
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: java/static-initialization-vector
    tags: |-
      security
             external/cwe/cwe-329
             external/cwe/cwe-1204
  queryHelp: |
    # Using a static initialization vector for encryption
    When a cipher is used in certain modes such as CBC or GCM, it requires an initialization vector (IV). Under the same secret key, IVs should be unique and ideally unpredictable. If the same IV is used with the same secret key, then the same plaintext results in the same ciphertext. This can let an attacker learn if the same data pieces are transferred or stored, or help the attacker run a dictionary attack.


    ## Recommendation
    Use a random IV generated by `SecureRandom`.


    ## Example
    The following example initializes a cipher with a static IV, which is unsafe:


    ```java
    byte[] iv = new byte[16]; // all zeroes
    GCMParameterSpec params = new GCMParameterSpec(128, iv);
    Cipher cipher = Cipher.getInstance("AES/GCM/PKCS5PADDING");
    cipher.init(Cipher.ENCRYPT_MODE, key, params);
    ```
    The next example initializes a cipher with a random IV:


    ```java
    byte[] iv = new byte[16];
    SecureRandom random = SecureRandom.getInstanceStrong();
    random.nextBytes(iv);
    GCMParameterSpec params = new GCMParameterSpec(128, iv);
    Cipher cipher = Cipher.getInstance("AES/GCM/PKCS5PADDING");
    cipher.init(Cipher.ENCRYPT_MODE, key, params);
    ```

    ## References
    * Wikipedia: [Initialization vector](https://en.wikipedia.org/wiki/Initialization_vector).
    * National Institute of Standards and Technology: [Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf).
    * National Institute of Standards and Technology: [FIPS 140-2: Security Requirements for Cryptographic Modules](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf).
    * Common Weakness Enumeration: [CWE-329](https://cwe.mitre.org/data/definitions/329.html).
    * Common Weakness Enumeration: [CWE-1204](https://cwe.mitre.org/data/definitions/1204.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-129/ImproperValidationOfArrayConstruction.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-129/ImproperValidationOfArrayConstruction.bqrs
  metadata:
    name: Improper validation of user-provided size used for array construction
    description: Using unvalidated external input as the argument to a construction
      of an array can lead to index out of bound exceptions.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.8
    precision: medium
    id: java/improper-validation-of-array-construction
    tags: |-
      security
             external/cwe/cwe-129
  queryHelp: |
    # Improper validation of user-provided size used for array construction
    Using unvalidated input when specifying the size of a newly created array can result in the creation of an array with size zero. If this array is subsequently accessed without further checks, an `ArrayIndexOutOfBoundsException` may be thrown, because there is no guarantee that the array is not empty.

    This problem occurs when user input is used as the size during array initialization, either directly or following one or more calculations. If the user input is unvalidated, it may cause the size of the array to be zero.


    ## Recommendation
    The size used in the array initialization should be verified to be greater than zero before being used. Alternatively, the array access may be protected by a conditional check that ensures it is only accessed if the index is less than the array size.


    ## Example
    The following program constructs an array with the size specified by some user input:


    ```java
    public class ImproperValidationOfArrayIndex extends HttpServlet {

      protected void doGet(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
        try {
          // User provided value
          int numberOfItems = Integer.parseInt(request.getParameter("numberOfItems").trim());

          if (numberOfItems >= 0) {
            /*
             * BAD numberOfItems may be zero, which would cause the array indexing operation to
             * throw an ArrayIndexOutOfBoundsException
             */
            String items = new String[numberOfItems];
            items[0] = "Item 1";
          }

          if (numberOfItems > 0) {
            /*
             * GOOD numberOfItems must be greater than zero, so the indexing succeeds.
             */
            String items = new String[numberOfItems];
            items[0] = "Item 1";
          }

        } catch (NumberFormatException e) { }
      }
    }
    ```
    The first array construction is protected by a condition that checks if the user input is zero or more. However, if the user provides `0` as the `numberOfItems` parameter, then an empty array is created, and any array access would fail with an `ArrayIndexOutOfBoundsException`.

    The second array construction is protected by a condition that checks if the user input is greater than zero. The array will therefore never be empty, and the following array access will not throw an `ArrayIndexOutOfBoundsException`.


    ## References
    * Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).
    * Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-129/ImproperValidationOfArrayIndex.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-129/ImproperValidationOfArrayIndex.bqrs
  metadata:
    name: Improper validation of user-provided array index
    description: "Using external input as an index to an array, without proper validation,\
      \ can lead to index out of bound exceptions."
    kind: path-problem
    problem.severity: warning
    security-severity: 8.8
    precision: medium
    id: java/improper-validation-of-array-index
    tags: |-
      security
             external/cwe/cwe-129
  queryHelp: |
    # Improper validation of user-provided array index
    Using unvalidated input as part of an index into the array can cause the array access to throw an `ArrayIndexOutOfBoundsException`. This is because there is no guarantee that the index provided is within the bounds of the array.

    This problem occurs when user input is used as an array index, either directly or following one or more calculations. If the user input is unsanitized, it may be any value, which could result in either a negative index, or an index which is larger than the size of the array, either of which would result in an `ArrayIndexOutOfBoundsException`.


    ## Recommendation
    The index used in the array access should be checked against the bounds of the array before being used. The index should be smaller than the array size, and it should not be negative.


    ## Example
    The following program accesses an element from a fixed size constant array:


    ```java
    public class ImproperValidationOfArrayIndex extends HttpServlet {

      protected void doGet(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
        String[] productDescriptions = new String[] { "Chocolate bar", "Fizzy drink" };

        // User provided value
        String productID = request.getParameter("productID");
        try {
            int productID = Integer.parseInt(userProperty.trim());

            /*
             * BAD Array is accessed without checking if the user provided value is out of
             * bounds.
             */
            String productDescription = productDescriptions[productID];

            if (productID >= 0 && productID < productDescriptions.length) {
              // GOOD We have checked that the array index is valid first
              productDescription = productDescriptions[productID];
            } else {
              productDescription = "No product for that ID";
            }

            response.getWriter().write(productDescription);

        } catch (NumberFormatException e) { }
      }
    }
    ```
    The first access of the `productDescriptions` array uses the user-provided value as the index without performing any checks. If the user provides a negative value, or a value larger than the size of the array, then an `ArrayIndexOutOfBoundsException` may be thrown.

    The second access of the `productDescriptions` array is contained within a conditional expression that verifies the user-provided value is a valid index into the array. This ensures that the access operation never throws an `ArrayIndexOutOfBoundsException`.


    ## References
    * Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).
    * Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-134/ExternallyControlledFormatString.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-134/ExternallyControlledFormatString.bqrs
  metadata:
    name: Use of externally-controlled format string
    description: Using external input in format strings can lead to exceptions or
      information leaks.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: java/tainted-format-string
    tags: |-
      security
             external/cwe/cwe-134
  queryHelp: "# Use of externally-controlled format string\nThe `String.format` method\
    \ and related methods, like `PrintStream.printf` and `Formatter.format`, all accept\
    \ a format string that is used to format the trailing arguments to the format\
    \ call by providing inline format specifiers. If the format string contains unsanitized\
    \ input from an untrusted source, then that string may contain extra format specifiers\
    \ that cause an exception to be thrown or information to be leaked.\n\nThe Java\
    \ standard library implementation for the format methods throws an exception if\
    \ either the format specifier does not match the type of the argument, or if there\
    \ are too few or too many arguments. If unsanitized input is used in the format\
    \ string, it may contain invalid extra format specifiers which cause an exception\
    \ to be thrown.\n\nPositional format specifiers may be used to access an argument\
    \ to the format call by position. Unsanitized input in the format string may use\
    \ a positional format specifier to access information that was not intended to\
    \ be visible. For example, when formatting a Calendar instance we may intend to\
    \ print only the year, but a user-specified format string may include a specifier\
    \ to access the month and day.\n\n\n## Recommendation\nIf the argument passed\
    \ as a format string is meant to be a plain string rather than a format string,\
    \ then pass `%s` as the format string, and pass the original argument as the sole\
    \ trailing argument.\n\n\n## Example\nThe following program is meant to check\
    \ a card security code for a stored credit card:\n\n\n```java\npublic class ResponseSplitting\
    \ extends HttpServlet {\n  protected void doGet(HttpServletRequest request, HttpServletResponse\
    \ response)\n  throws ServletException, IOException {\n    Calendar expirationDate\
    \ = new GregorianCalendar(2017, GregorianCalendar.SEPTEMBER, 1);\n    // User\
    \ provided value\n    String cardSecurityCode = request.getParameter(\"cardSecurityCode\"\
    );\n    \n    if (notValid(cardSecurityCode)) {\n      \n      /*\n       * BAD:\
    \ user provided value is included in the format string.\n       * A malicious\
    \ user could provide an extra format specifier, which causes an\n       * exception\
    \ to be thrown. Or they could provide a %1$tm or %1$te format specifier to\n \
    \      * access the month or day of the expiration date.\n       */\n      System.out.format(cardSecurityCode\
    \ +\n                          \" is not the right value. Hint: the card expires\
    \ in %1$ty.\",\n                        expirationDate);\n      \n      // GOOD:\
    \ %s is used to include the user-provided cardSecurityCode in the output\n   \
    \   System.out.format(\"%s is not the right value. Hint: the card expires in %2$ty.\"\
    ,\n                        cardSecurityCode,\n                        expirationDate);\n\
    \    }\n\n  }\n}\n```\nHowever, in the first format call it uses the cardSecurityCode\
    \ provided by the user in a format string. If the user includes a format specifier\
    \ in the cardSecurityCode field, they may be able to cause an exception to be\
    \ thrown, or to be able to access extra information about the stored card expiration\
    \ date.\n\nThe second format call shows the correct approach. The user-provided\
    \ value is passed as an argument to the format call. This prevents any format\
    \ specifiers in the user provided value from being evaluated.\n\n\n## References\n\
    * SEI CERT Oracle Coding Standard for Java: [IDS06-J. Exclude unsanitized user\
    \ input from format strings](https://wiki.sei.cmu.edu/confluence/display/java/IDS06-J.+Exclude+unsanitized+user+input+from+format+strings).\n\
    * The Java Tutorials: [Formatting Numeric Print Output](https://docs.oracle.com/javase/tutorial/java/data/numberformat.html).\n\
    * Java API Specification: [Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html).\n\
    * Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-190/ArithmeticTainted.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-190/ArithmeticTainted.bqrs
  metadata:
    name: User-controlled data in arithmetic expression
    description: |-
      Arithmetic operations on user-controlled data that is not validated can cause
                    overflows.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.6
    precision: medium
    id: java/tainted-arithmetic
    tags: |-
      security
             external/cwe/cwe-190
             external/cwe/cwe-191
  queryHelp: "# User-controlled data in arithmetic expression\nPerforming calculations\
    \ on user-controlled data can result in integer overflows unless the input is\
    \ validated.\n\nIf the user is free to enter very large numbers, even arithmetic\
    \ operations that would usually result in a small change in magnitude may result\
    \ in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic\
    \ operations on user-controlled data by doing one of the following:\n\n* Validate\
    \ the user input.\n* Define a guard on the arithmetic expression, so that the\
    \ operation is performed only if the result can be known to be less than, or equal\
    \ to, the maximum value for the type, for example `MAX_VALUE`.\n* Use a wider\
    \ type, so that larger input values do not cause overflow.\n\n## Example\nIn this\
    \ example, a value is read from standard input into an `int`. Because the value\
    \ is a user-controlled value, it could be extremely large. Performing arithmetic\
    \ operations on this value could therefore cause an overflow. To avoid this happening,\
    \ the example shows how to perform a check before performing a multiplication.\n\
    \n\n```java\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t{\n\
    \t\t\tint data;\n\n\t\t\tBufferedReader readerBuffered = new BufferedReader(\n\
    \t\t\t\t\tnew InputStreamReader(System.in, \"UTF-8\"));\n\t\t\tString stringNumber\
    \ = readerBuffered.readLine();\n\t\t\tif (stringNumber != null) {\n\t\t\t\tdata\
    \ = Integer.parseInt(stringNumber.trim());\n\t\t\t} else {\n\t\t\t\tdata = 0;\n\
    \t\t\t}\n\n\t\t\t// BAD: may overflow if input data is very large, for example\n\
    \t\t\t// 'Integer.MAX_VALUE'\n\t\t\tint scaled = data * 10;\n\n\t\t\t//...\n\t\
    \t\t\n\t\t\t// GOOD: use a guard to ensure no overflows occur\n\t\t\tint scaled2;\n\
    \t\t\tif (data < Integer.MAX_VALUE / 10)\n\t\t\t\tscaled2 = data * 10;\n\t\t\t\
    else\n\t\t\t\tscaled2 = Integer.MAX_VALUE;\n\t\t}\n\t}\n}\n```\n\n## References\n\
    * SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer\
    \ overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n\
    * Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n\
    * Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-190/ArithmeticUncontrolled.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-190/ArithmeticUncontrolled.bqrs
  metadata:
    name: Uncontrolled data in arithmetic expression
    description: |-
      Arithmetic operations on uncontrolled data that is not validated can cause
                    overflows.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.6
    precision: medium
    id: java/uncontrolled-arithmetic
    tags: |-
      security
             external/cwe/cwe-190
             external/cwe/cwe-191
  queryHelp: "# Uncontrolled data in arithmetic expression\nPerforming calculations\
    \ on uncontrolled data can result in integer overflows unless the input is validated.\n\
    \nIf the data is not under your control, and can take extremely large values,\
    \ even arithmetic operations that would usually result in a small change in magnitude\
    \ may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow\
    \ in arithmetic operations on uncontrolled data by doing one of the following:\n\
    \n* Validate the data.\n* Define a guard on the arithmetic expression, so that\
    \ the operation is performed only if the result can be known to be less than,\
    \ or equal to, the maximum value for the type, for example `MAX_VALUE`.\n* Use\
    \ a wider type, so that larger input values do not cause overflow.\n\n## Example\n\
    In this example, a random integer is generated. Because the value is not controlled\
    \ by the programmer, it could be extremely large. Performing arithmetic operations\
    \ on this value could therefore cause an overflow. To avoid this happening, the\
    \ example shows how to perform a check before performing a multiplication.\n\n\
    \n```java\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t{\n\t\
    \t\tint data = (new java.security.SecureRandom()).nextInt();\n\n\t\t\t// BAD:\
    \ may overflow if data is large\n\t\t\tint scaled = data * 10;\n\n\t\t\t// ...\n\
    \n\t\t\t// GOOD: use a guard to ensure no overflows occur\n\t\t\tint scaled2;\n\
    \t\t\tif (data < Integer.MAX_VALUE/10)\n\t\t\t\tscaled2 = data * 10;\n\t\t\telse\
    \ \n\t\t\t\tscaled2 = Integer.MAX_VALUE;\n\t\t}\n\t}\n}\n```\n\n## References\n\
    * SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer\
    \ overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n\
    * Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n\
    * Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-190/ComparisonWithWiderType.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-190/ComparisonWithWiderType.bqrs
  metadata:
    name: Comparison of narrow type with wide type in loop condition
    description: |-
      Comparisons between types of different widths in a loop condition can cause the loop
                    to behave unexpectedly.
    kind: problem
    problem.severity: warning
    security-severity: 8.1
    precision: medium
    id: java/comparison-with-wider-type
    tags: |-
      reliability
             security
             external/cwe/cwe-190
             external/cwe/cwe-197
  queryHelp: "# Comparison of narrow type with wide type in loop condition\nIn a loop\
    \ condition, comparison of a value of a narrow type with a value of a wide type\
    \ may always evaluate to `true` if the wider value is sufficiently large (or small).\
    \ This is because the narrower value may overflow. This can lead to an infinite\
    \ loop.\n\n\n## Recommendation\nChange the types of the compared values so that\
    \ the value on the narrower side of the comparison is at least as wide as the\
    \ value it is being compared with.\n\n\n## Example\nIn this example, `bytesReceived`\
    \ is compared against `MAXGET` in a `while` loop. However, `bytesReceived` is\
    \ a `short`, and `MAXGET` is a `long`. Because `MAXGET` is larger than `Short.MAX_VALUE`,\
    \ the loop condition is always `true`, so the loop never terminates.\n\nThis problem\
    \ is avoided in the 'GOOD' case because `bytesReceived2` is a `long`, which is\
    \ as wide as the type of `MAXGET`.\n\n\n```java\nclass Test {\n\tpublic static\
    \ void main(String[] args) {\n\t\t\n\t\t{\t\t\n\t\t\tint BIGNUM = Integer.MAX_VALUE;\n\
    \t\t\tlong MAXGET = Short.MAX_VALUE + 1;\n\t\t\t\n\t\t\tchar[] buf = new char[BIGNUM];\n\
    \n\t\t\tshort bytesReceived = 0;\n\t\t\t\n\t\t\t// BAD: 'bytesReceived' is compared\
    \ with a value of wider type.\n\t\t\t// 'bytesReceived' overflows before reaching\
    \ MAXGET,\n\t\t\t// causing an infinite loop.\n\t\t\twhile (bytesReceived < MAXGET)\
    \ {\n\t\t\t\tbytesReceived += getFromInput(buf, bytesReceived);\n\t\t\t}\n\t\t\
    }\n\t\t\n\t\t{\n\t\t\tlong bytesReceived2 = 0;\n\t\t\t\n\t\t\t// GOOD: 'bytesReceived2'\
    \ has a type at least as wide as MAXGET.\n\t\t\twhile (bytesReceived2 < MAXGET)\
    \ {\n\t\t\t\tbytesReceived2 += getFromInput(buf, bytesReceived2);\n\t\t\t}\n\t\
    \t}\n\t\t\n\t}\n\t\n\tpublic static int getFromInput(char[] buf, short pos) {\n\
    \t\t// write to buf\n\t\t// ...\n\t\treturn 1;\n\t}\n}\n```\n\n## References\n\
    * SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer\
    \ overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n\
    * Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n\
    * Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-200/AndroidSensitiveNotifications.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-200/AndroidSensitiveNotifications.bqrs
  metadata:
    name: Exposure of sensitive information to notifications
    id: java/android/sensitive-notification
    kind: path-problem
    description: Sensitive information exposed in a system notification can be read
      by an unauthorized application.
    problem.severity: error
    precision: medium
    security-severity: 6.5
    tags: |-
      security
             external/cwe/cwe-200
  queryHelp: |
    # Exposure of sensitive information to notifications
    Sensitive information such as passwords or two-factor authentication (2FA) codes should not be exposed in a system notification. Notifications should not be considered secure, as other untrusted applications may be able to use a `NotificationListenerService` to read the contents of notifications.


    ## Recommendation
    Do not expose sensitive data in notifications.


    ## Example
    In the following sample, the `password` is sent as part of a notification. This can allow another application to read this password.


    ```java
    // BAD: `password` is exposed in a notification.
    void confirmPassword(String password) {
        NotificationManager manager = NotificationManager.from(this);
        manager.send(
            new Notification.Builder(this, CHANNEL_ID)
            .setContentText("Your password is: " + password)
            .build());
    }
    ```

    ## References
    * OWASP Mobile Application Security: [Android Data Storage - Application Notifications](https://mas.owasp.org/MASTG/Android/0x05d-Testing-Data-Storage/#app-notifications)
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-200/AndroidSensitiveTextField.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-200/AndroidSensitiveTextField.bqrs
  metadata:
    name: Exposure of sensitive information to UI text views
    id: java/android/sensitive-text
    kind: path-problem
    description: Sensitive information displayed in UI text views should be properly
      masked.
    problem.severity: warning
    precision: medium
    security-severity: 6.5
    tags: |-
      security
             external/cwe/cwe-200
  queryHelp: |
    # Exposure of sensitive information to UI text views
    Sensitive information such as passwords should not be displayed in UI components unless explicitly required, to mitigate shoulder-surfing attacks.


    ## Recommendation
    For editable text fields containing sensitive information, the `inputType` should be set to `textPassword` or similar to ensure it is properly masked. Otherwise, sensitive data that must be displayed should be hidden by default, and only revealed based on an explicit user action.


    ## Example
    In the following (bad) case, sensitive information in `password` is exposed to the `TextView`.


    ```java
    TextView pwView = getViewById(R.id.pw_text);
    pwView.setText("Your password is: " + password);
    ```
    In the following (good) case, the user must press a button to reveal sensitive information.


    ```java
    TextView pwView = findViewById(R.id.pw_text);
    pwView.setVisibility(View.INVISIBLE);
    pwView.setText("Your password is: " + password);

    Button showButton = findViewById(R.id.show_pw_button);
    showButton.setOnClickListener(new View.OnClickListener() {
        public void onClick(View v) {
          pwView.setVisibility(View.VISIBLE);
        }
    });

    ```

    ## References
    * OWASP Mobile Application Security: [Android Data Storage - UI Components](https://mas.owasp.org/MASTG/Android/0x05d-Testing-Data-Storage/#ui-components)
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-200/AndroidWebViewSettingsAllowsContentAccess.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-200/AndroidWebViewSettingsAllowsContentAccess.bqrs
  metadata:
    name: Android WebView settings allows access to content links
    id: java/android/websettings-allow-content-access
    description: Access to content providers in a WebView can allow access to protected
      information by loading content:// links.
    kind: problem
    problem.severity: warning
    precision: medium
    security-severity: 6.5
    tags: |-
      security
            external/cwe/cwe-200
  queryHelp: |
    # Android WebView settings allows access to content links
    Android can provide access to content providers within a WebView using the `setAllowContentAccess` setting.

    Allowing access to content providers via `content://` URLs may allow JavaScript to access protected content.


    ## Recommendation
    If your app does not require access to the `content://` URL functionality, you should explicitly disable the setting by calling `setAllowContentAccess(false)` on the settings of the WebView.


    ## Example
    In the following (bad) example, access to `content://` URLs is explicitly allowed.


    ```java
    WebSettings settings = webview.getSettings();

    settings.setAllowContentAccess(true);

    ```
    In the following (good) example, access to `content://` URLs is explicitly denied.


    ```java
    WebSettings settings = webview.getSettings();

    settings.setAllowContentAccess(false);

    ```

    ## References
    * Android Documentation: [setAllowContentAccess](https://developer.android.com/reference/android/webkit/WebSettings#setAllowContentAccess(boolean)).
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-200/AndroidWebViewSettingsFileAccess.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-200/AndroidWebViewSettingsFileAccess.bqrs
  metadata:
    name: Android WebSettings file access
    kind: problem
    description: Enabling access to the file system in a WebView allows attackers
      to view sensitive information.
    id: java/android/websettings-file-access
    problem.severity: warning
    security-severity: 6.5
    precision: medium
    tags: |-
      security
             external/cwe/cwe-200
  queryHelp: |
    # Android WebSettings file access
    Allowing file access in an Android WebView can expose a device's file system to the JavaScript running in that WebView. If the JavaScript contains vulnerabilities or the WebView loads untrusted content, file access allows an attacker to steal the user's data.


    ## Recommendation
    When possible, do not allow file access. The file access settings are disabled by default. You can explicitly disable file access by setting the following settings to `false`:

    * `setAllowFileAccess`
    * `setAllowFileAccessFromFileURLs`
    * `setAllowUniversalAccessFromFileURLs`
    If your application requires access to the file system, it is best to avoid using `file://` URLs. Instead, use an alternative that loads files via HTTPS, such as `androidx.webkit.WebViewAssetLoader`.


    ## Example
    In the following (bad) example, the WebView is configured with settings that allow local file access.


    ```java
    WebSettings settings = view.getSettings();

    settings.setAllowFileAccess(true);
    settings.setAllowFileAccessFromURLs(true);
    settings.setAllowUniversalAccessFromURLs(true);

    ```
    In the following (good) example, the WebView is configured to disallow file access.


    ```java
    WebSettings settings = view.getSettings();

    settings.setAllowFileAccess(false);
    settings.setAllowFileAccessFromURLs(false);
    settings.setAllowUniversalAccessFromURLs(false);

    ```
    As mentioned previously, asset loaders can load files without file system access. In the following (good) example, an asset loader is configured to load assets over HTTPS.


    ```java
    WebViewAssetLoader loader = new WebViewAssetLoader.Builder()
        // Replace the domain with a domain you control, or use the default
        // appassets.androidplatform.com
        .setDomain("appassets.example.com")
        .addPathHandler("/resources", new AssetsPathHandler(this))
        .build();

    webView.setWebViewClient(new WebViewClientCompat() {
        @Override
        public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {
            return assetLoader.shouldInterceptRequest(request.getUrl());
        }
    });

    webView.loadUrl("https://appassets.example.com/resources/www/index.html");

    ```

    ## References
    * Android documentation: [WebSettings.setAllowFileAccess](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccess(boolean)).
    * Android documentation: [WebSettings.setAllowFileAccessFromFileURLs](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccessFromFileURLs(boolean)).
    * Android documentation: [WebSettings.setAllowUniversalAccessFromFileURLs](https://developer.android.com/reference/android/webkit/WebSettings#setAllowUniversalAccessFromFileURLs(boolean)).
    * Android documentation: [WebViewAssetLoader](https://developer.android.com/reference/androidx/webkit/WebViewAssetLoader).
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-200/TempDirLocalInformationDisclosure.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-200/TempDirLocalInformationDisclosure.bqrs
  metadata:
    name: Local information disclosure in a temporary directory
    description: Writing information without explicit permissions to a shared temporary
      directory may disclose it to other users.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.5
    precision: medium
    id: java/local-temp-file-or-directory-information-disclosure
    tags: |-
      security
             external/cwe/cwe-200
             external/cwe/cwe-732
  queryHelp: |
    # Local information disclosure in a temporary directory
    Local information disclosure can occur when files/directories are written into directories that are shared between all users on the system.

    On most [unix-like](https://en.wikipedia.org/wiki/Unix-like) systems, the system temporary directory is shared between local users. If files/directories are created within the system temporary directory without using APIs that explicitly set the correct file permissions, local information disclosure can occur.

    Depending upon the particular file contents exposed, this vulnerability can have a [CVSSv3.1 base score of 6.2/10](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N&version=3.1).


    ## Recommendation
    Use JDK methods that specifically protect against this vulnerability:

    * [java.nio.file.Files.createTempDirectory](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.nio.file.Path-java.lang.String-java.nio.file.attribute.FileAttribute...-)
    * [java.nio.file.Files.createTempFile](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempFile-java.nio.file.Path-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-)
    Otherwise, create the file/directory by manually specifying the expected posix file permissions. For example: `PosixFilePermissions.asFileAttribute(EnumSet.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE))`

    * [java.nio.file.Files.createFile](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)
    * [java.nio.file.Files.createDirectory](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)
    * [java.nio.file.Files.createDirectories](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectories-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)

    ## Example
    In the following example, files and directories are created with file permissions that allow other local users to read their contents.


    ```java
    import java.io.File;

    public class TempDirUsageVulnerable {
        void exampleVulnerable() {
            File temp1 = File.createTempFile("random", ".txt"); // BAD: File has permissions `-rw-r--r--`

            File temp2 = File.createTempFile("random", "file", null); // BAD: File has permissions `-rw-r--r--`

            File systemTempDir = new File(System.getProperty("java.io.tmpdir"));
            File temp3 = File.createTempFile("random", "file", systemTempDir); // BAD: File has permissions `-rw-r--r--`

            File tempDir = com.google.common.io.Files.createTempDir(); // BAD: CVE-2020-8908: Directory has permissions `drwxr-xr-x`

            new File(System.getProperty("java.io.tmpdir"), "/child").mkdir(); // BAD: Directory has permissions `-rw-r--r--`

            File tempDirChildFile = new File(System.getProperty("java.io.tmpdir"), "/child-create-file.txt");
            Files.createFile(tempDirChildFile.toPath()); // BAD: File has permissions `-rw-r--r--`

            File tempDirChildDir = new File(System.getProperty("java.io.tmpdir"), "/child-dir");
            tempDirChildDir.mkdir(); // BAD: Directory has permissions `drwxr-xr-x`
            Files.createDirectory(tempDirChildDir.toPath()); // BAD: Directory has permissions `drwxr-xr-x`
        }
    }

    ```
    In the following example, files and directories are created with file permissions that protect their contents.


    ```java
    import java.io.File;
    import java.io.IOException;
    import java.io.UncheckedIOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.attribute.PosixFilePermission;
    import java.nio.file.attribute.PosixFilePermissions;

    import java.util.EnumSet;


    public class TempDirUsageSafe {
        void exampleSafe() throws IOException {
            Path temp1 = Files.createTempFile("random", ".txt"); // GOOD: File has permissions `-rw-------`

            Path temp2 = Files.createTempDirectory("random-directory"); // GOOD: File has permissions `drwx------`

            // Creating a temporary file with a non-randomly generated name
            File tempChildFile = new File(System.getProperty("java.io.tmpdir"), "/child-create-file.txt");
            // Warning: This will fail on windows as it doesn't support PosixFilePermissions.
            // See `exampleSafeWithWindowsSupportFile` if your code needs to support windows and unix-like systems.
            Files.createFile(
                tempChildFile.toPath(),
                PosixFilePermissions.asFileAttribute(EnumSet.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE))
            ); // GOOD: Good has permissions `-rw-------`
        }

        /*
         * An example of a safe use of createFile or createDirectory if your code must support windows and unix-like systems.
         */
        void exampleSafeWithWindowsSupportFile() {
            // Creating a temporary file with a non-randomly generated name
            File tempChildFile = new File(System.getProperty("java.io.tmpdir"), "/child-create-file.txt");
            createTempFile(tempChildFile.toPath()); // GOOD: Good has permissions `-rw-------`
        }

        static void createTempFile(Path tempDirChild) {
            try {
                if (tempDirChild.getFileSystem().supportedFileAttributeViews().contains("posix")) {
                    // Explicit permissions setting is only required on unix-like systems because
                    // the temporary directory is shared between all users.
                    // This is not necessary on Windows, each user has their own temp directory
                    final EnumSet<PosixFilePermission> posixFilePermissions =
                            EnumSet.of(
                                PosixFilePermission.OWNER_READ,
                                PosixFilePermission.OWNER_WRITE
                            );
                    if (!Files.exists(tempDirChild)) {
                        Files.createFile(
                            tempDirChild,
                            PosixFilePermissions.asFileAttribute(posixFilePermissions)
                        ); // GOOD: Directory has permissions `-rw-------`
                    } else {
                        Files.setPosixFilePermissions(
                                tempDirChild,
                                posixFilePermissions
                        ); // GOOD: Good has permissions `-rw-------`, or will throw an exception if this fails
                    }
                } else if (!Files.exists(tempDirChild)) {
                    // On Windows, we still need to create the directory, when it doesn't already exist.
                    Files.createDirectory(tempDirChild); // GOOD: Windows doesn't share the temp directory between users
                }
            } catch (IOException exception) {
                throw new UncheckedIOException("Failed to create temp file", exception);
            }
        }

        void exampleSafeWithWindowsSupportDirectory() {
            File tempDirChildDir = new File(System.getProperty("java.io.tmpdir"), "/child-dir");
            createTempDirectories(tempDirChildDir.toPath()); // GOOD: Directory has permissions `drwx------`
        }

        static void createTempDirectories(Path tempDirChild) {
            try {
                if (tempDirChild.getFileSystem().supportedFileAttributeViews().contains("posix")) {
                    // Explicit permissions setting is only required on unix-like systems because
                    // the temporary directory is shared between all users.
                    // This is not necessary on Windows, each user has their own temp directory
                    final EnumSet<PosixFilePermission> posixFilePermissions =
                            EnumSet.of(
                                PosixFilePermission.OWNER_READ,
                                PosixFilePermission.OWNER_WRITE,
                                PosixFilePermission.OWNER_EXECUTE
                            );
                    if (!Files.exists(tempDirChild)) {
                        Files.createDirectories(
                            tempDirChild,
                            PosixFilePermissions.asFileAttribute(posixFilePermissions)
                        ); // GOOD: Directory has permissions `drwx------`
                    } else {
                        Files.setPosixFilePermissions(
                                tempDirChild,
                                posixFilePermissions
                        ); // GOOD: Good has permissions `drwx------`, or will throw an exception if this fails
                    }
                } else if (!Files.exists(tempDirChild)) {
                    // On Windows, we still need to create the directory, when it doesn't already exist.
                    Files.createDirectories(tempDirChild); // GOOD: Windows doesn't share the temp directory between users
                }
            } catch (IOException exception) {
                throw new UncheckedIOException("Failed to create temp dir", exception);
            }
        }
    }

    ```

    ## References
    * OWASP: [Insecure Temporary File](https://owasp.org/www-community/vulnerabilities/Insecure_Temporary_File).
    * CERT: [FIO00-J. Do not operate on files in shared directories](https://wiki.sei.cmu.edu/confluence/display/java/FIO00-J.+Do+not+operate+on+files+in+shared+directories).
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
    * Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-209/StackTraceExposure.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-209/StackTraceExposure.bqrs
  metadata:
    name: Information exposure through a stack trace
    description: |-
      Information from a stack trace propagates to an external user.
                    Stack traces can unintentionally reveal implementation details
                    that are useful to an attacker for developing a subsequent exploit.
    kind: problem
    problem.severity: error
    security-severity: 5.4
    precision: high
    id: java/stack-trace-exposure
    tags: |-
      security
             external/cwe/cwe-209
             external/cwe/cwe-497
  queryHelp: "# Information exposure through a stack trace\nSoftware developers often\
    \ add stack traces to error messages, as a debugging aid. Whenever that error\
    \ message occurs for an end user, the developer can use the stack trace to help\
    \ identify how to fix the problem. In particular, stack traces can tell the developer\
    \ more about the sequence of events that led to a failure, as opposed to merely\
    \ the final state of the software when the error occurred.\n\nUnfortunately, the\
    \ same information can be useful to an attacker. The sequence of class names in\
    \ a stack trace can reveal the structure of the application as well as any internal\
    \ components it relies on. Furthermore, the error message at the top of a stack\
    \ trace can include information such as server-side file names and SQL code that\
    \ the application relies on, allowing an attacker to fine-tune a subsequent injection\
    \ attack.\n\n\n## Recommendation\nSend the user a more generic error message that\
    \ reveals less information. Either suppress the stack trace entirely, or log it\
    \ only on the server.\n\n\n## Example\nIn the following example, an exception\
    \ is handled in two different ways. In the first version, labeled BAD, the exception\
    \ is sent back to the remote user using the `sendError()` method. As such, the\
    \ user is able to see a detailed stack trace, which may contain sensitive information.\
    \ In the second version, the error message is logged only on the server. That\
    \ way, the developers can still access and use the error log, but remote users\
    \ will not see the information.\n\n\n```java\nprotected void doGet(HttpServletRequest\
    \ request, HttpServletResponse response) {\n\ttry {\n\t\tdoSomeWork();\n\t} catch\
    \ (NullPointerException ex) {\n\t\t// BAD: printing a stack trace back to the\
    \ response\n\t\tex.printStackTrace(response.getWriter());\n\t\treturn;\n\t}\n\n\
    \ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// GOOD:\
    \ log the stack trace, and send back a non-revealing response\n\t\tlog(\"Exception\
    \ occurred\", ex);\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\
    \t\t\t\"Exception occurred\");\n\t\treturn;\n\t}\n}\n\n```\n\n## References\n\
    * OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n\
    * CERT Java Coding Standard: [ERR01-J. Do not allow exceptions to expose sensitive\
    \ information](https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information).\n\
    * Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n\
    * Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-266/IntentUriPermissionManipulation.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-266/IntentUriPermissionManipulation.bqrs
  metadata:
    name: Intent URI permission manipulation
    description: |-
      Returning an externally provided Intent via 'setResult' may allow a malicious
                    application to access arbitrary content providers of the vulnerable application.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: java/android/intent-uri-permission-manipulation
    tags: |-
      security
             external/cwe/cwe-266
             external/cwe/cwe-926
  queryHelp: |
    # Intent URI permission manipulation
    When an Android component expects a result from an Activity, `startActivityForResult` can be used. The started Activity can then use `setResult` to return the appropriate data to the calling component.

    If an Activity obtains the incoming, user-provided Intent and directly returns it via `setResult` without any checks, the application may be unintentionally giving arbitrary access to its content providers, even if they are not exported, as long as they are configured with the attribute `android:grantUriPermissions="true"`. This happens because the attacker adds the appropriate URI permission flags to the provided Intent, which take effect once the Intent is reflected back.


    ## Recommendation
    Avoid returning user-provided or untrusted Intents via `setResult`. Use a new Intent instead.

    If it is required to use the received Intent, make sure that it does not contain URI permission flags, either by checking them with `Intent.getFlags` or removing them with `Intent.removeFlags`.


    ## Example
    The following sample contains three examples. In the first example, a user-provided Intent is obtained and directly returned back with `setResult`, which is dangerous. In the second example, a new Intent is created to safely return the desired data. The third example shows how the obtained Intent can be sanitized by removing dangerous flags before using it to return data to the calling component.


    ```java
    public class IntentUriPermissionManipulation extends Activity {

        // BAD: the user-provided Intent is returned as-is
        public void dangerous() {
            Intent intent = getIntent();
            intent.putExtra("result", "resultData");
            setResult(intent);
        }

        // GOOD: a new Intent is created and returned
        public void safe() {
            Intent intent = new Intent();
            intent.putExtra("result", "resultData");
            setResult(intent);
        }

        // GOOD: the user-provided Intent is sanitized before being returned
        public void sanitized() {
            Intent intent = getIntent();
            intent.putExtra("result", "resultData");
            intent.removeFlags(
                    Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);
            setResult(intent);
        }
    }

    ```

    ## References
    * Google Help: [Remediation for Intent Redirection Vulnerability](https://support.google.com/faqs/answer/9267555?hl=en).
    * Common Weakness Enumeration: [CWE-266](https://cwe.mitre.org/data/definitions/266.html).
    * Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-273/UnsafeCertTrust.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-273/UnsafeCertTrust.bqrs
  metadata:
    name: Unsafe certificate trust
    description: |-
      SSLSocket/SSLEngine ignores all SSL certificate validation
                    errors when establishing an HTTPS connection, thereby making
                    the app vulnerable to man-in-the-middle attacks.
    kind: problem
    problem.severity: warning
    security-severity: 9.8
    precision: medium
    id: java/unsafe-cert-trust
    tags: |-
      security
             external/cwe/cwe-273
  queryHelp: "# Unsafe certificate trust\nJava offers two mechanisms for SSL authentication\
    \ - trust manager and hostname verifier (the later is checked by the `java/insecure-hostname-verifier`\
    \ query). The trust manager validates the peer's certificate chain while hostname\
    \ verification establishes that the hostname in the URL matches the hostname in\
    \ the server's identification.\n\nWhen `SSLSocket` or `SSLEngine` are created\
    \ without a secure `setEndpointIdentificationAlgorithm`, hostname verification\
    \ is disabled by default.\n\nThis query checks whether `setEndpointIdentificationAlgorithm`\
    \ is missing, thereby making the application vulnerable to man-in-the-middle attacks.\
    \ The query also covers insecure configurations of `com.rabbitmq.client.ConnectionFactory`.\n\
    \n\n## Recommendation\nValidate SSL certificates in SSL authentication.\n\n\n\
    ## Example\nThe following two examples show two ways of configuring SSLSocket/SSLEngine.\
    \ In the 'BAD' case, `setEndpointIdentificationAlgorithm` is not called, thus\
    \ no hostname verification takes place. In the 'GOOD' case, `setEndpointIdentificationAlgorithm`\
    \ is called.\n\n\n```java\npublic static void main(String[] args) {\n\n\t{\n\t\
    \tSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\t\tSSLEngine sslEngine\
    \ = sslContext.createSSLEngine();\n\t\tSSLParameters sslParameters = sslEngine.getSSLParameters();\n\
    \t\tsslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\"); //GOOD: Set a\
    \ valid endpointIdentificationAlgorithm for SSL engine to trigger hostname verification\n\
    \t\tsslEngine.setSSLParameters(sslParameters);\n\t}\n\n\t{\n\t\tSSLContext sslContext\
    \ = SSLContext.getInstance(\"TLS\");\n\t\tSSLEngine sslEngine = sslContext.createSSLEngine();\
    \  //BAD: No endpointIdentificationAlgorithm set\n\t}\n\n\t{\n\t\tSSLContext sslContext\
    \ = SSLContext.getInstance(\"TLS\");\n\t\tfinal SSLSocketFactory socketFactory\
    \ = sslContext.getSocketFactory();\n\t\tSSLSocket socket = (SSLSocket) socketFactory.createSocket(\"\
    www.example.com\", 443); \n\t\tSSLParameters sslParameters = sslEngine.getSSLParameters();\n\
    \t\tsslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\"); //GOOD: Set a\
    \ valid endpointIdentificationAlgorithm for SSL socket to trigger hostname verification\n\
    \t\tsocket.setSSLParameters(sslParameters);\n\t}\n\n\t{\n\t\tcom.rabbitmq.client.ConnectionFactory\
    \ connectionFactory = new com.rabbitmq.client.ConnectionFactory();\n\t\tconnectionFactory.useSslProtocol();\n\
    \t\tconnectionFactory.enableHostnameVerification();  //GOOD: Enable hostname verification\
    \ for rabbitmq ConnectionFactory\n\t}\n\n\t{\n\t\tcom.rabbitmq.client.ConnectionFactory\
    \ connectionFactory = new com.rabbitmq.client.ConnectionFactory();\n\t\tconnectionFactory.useSslProtocol();\
    \ //BAD: Hostname verification for rabbitmq ConnectionFactory is not enabled\n\
    \t}\n}\n```\n\n## References\n* [Testing Endpoint Identify Verification (MSTG-NETWORK-3)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05g-Testing-Network-Communication.md).\n\
    * [SSLParameters.setEndpointIdentificationAlgorithm documentation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLParameters.html#setEndpointIdentificationAlgorithm(java.lang.String)).\n\
    * RabbitMQ: [ConnectionFactory.enableHostnameVerification documentation](https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/ConnectionFactory.html#enableHostnameVerification()).\n\
    * RabbitMQ: [Using TLS in the Java Client](https://www.rabbitmq.com/ssl.html#java-client).\n\
    * [CVE-2018-17187: Apache Qpid Proton-J transport issue with hostname verification](https://github.com/advisories/GHSA-xvch-r4wf-h8w9).\n\
    * [CVE-2018-8034: Apache Tomcat - host name verification when using TLS with the\
    \ WebSocket client](https://github.com/advisories/GHSA-46j3-r4pj-4835).\n* [CVE-2018-11087:\
    \ Pivotal Spring AMQP vulnerability due to lack of hostname validation](https://github.com/advisories/GHSA-w4g2-9hj6-5472).\n\
    * [CVE-2018-11775: TLS hostname verification issue when using the Apache ActiveMQ\
    \ Client](https://github.com/advisories/GHSA-m9w8-v359-9ffr).\n* Common Weakness\
    \ Enumeration: [CWE-273](https://cwe.mitre.org/data/definitions/273.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-287/AndroidInsecureKeys.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-287/AndroidInsecureKeys.bqrs
  metadata:
    name: Insecurely generated keys for local authentication
    description: Generation of keys with insecure parameters for local biometric authentication
      can allow attackers with physical access to bypass authentication checks.
    kind: problem
    problem.severity: warning
    security-severity: 4.4
    precision: medium
    id: java/android/insecure-local-key-gen
    tags: |-
      security
             external/cwe/cwe-287
  queryHelp: "# Insecurely generated keys for local authentication\nBiometric authentication,\
    \ such as fingerprint recognition, can be used alongside cryptographic keys stored\
    \ in the Android `KeyStore` to protect sensitive parts of the application. However,\
    \ when a key generated for this purpose has certain parameters set insecurely,\
    \ an attacker with physical access can bypass the authentication check using application\
    \ hooking tools such as Frida.\n\n\n## Recommendation\nWhen generating a key for\
    \ use with biometric authentication, ensure that the following parameters of `KeyGenParameterSpec.Builder`\
    \ are set:\n\n* `setUserAuthenticationRequired` should be set to `true`; otherwise,\
    \ the key can be used without user authentication.\n* `setInvalidatedByBiometricEnrollment`\
    \ should be set to `true` (the default); otherwise, an attacker can use the key\
    \ by enrolling additional biometrics on the device.\n* `setUserAuthenticationValidityDurationSeconds`,\
    \ if used, should be set to `-1`; otherwise, non-biometric (less secure) credentials\
    \ can be used to access the key. We recommend using `setUserAuthenticationParameters`\
    \ instead to explicitly set both the timeout and the types of credentials that\
    \ may be used.\n\n## Example\nThe following example demonstrates a key that is\
    \ configured with secure paramaters:\n\n\n```java\nprivate void generateSecretKey()\
    \ {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n\
    \        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n\
    \        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n\
    \        // GOOD: Secure parameters are used to generate a key for biometric authentication.\n\
    \        .setUserAuthenticationRequired(true)\n        .setInvalidatedByBiometricEnrollment(true)\n\
    \        .setUserAuthenticationParameters(0, KeyProperties.AUTH_BIOMETRIC_STRONG)\n\
    \        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n\
    \            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n\
    \    keyGenerator.generateKey();\n}\n```\nIn each of the following cases, a parameter\
    \ is set insecurely:\n\n\n```java\nprivate void generateSecretKey() {\n    KeyGenParameterSpec\
    \ keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\"\
    ,\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n  \
    \      .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n\
    \        // BAD: User authentication is not required to use this key.\n      \
    \  .setUserAuthenticationRequired(false)\n        .build();\n    KeyGenerator\
    \ keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES,\
    \ \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n\
    }\n\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec\
    \ = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT\
    \ | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n\
    \        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n    \
    \    .setUserAuthenticationRequired(true)\n        // BAD: An attacker can access\
    \ this key by enrolling additional biometrics.\n        .setInvalidatedByBiometricEnrollment(false)\n\
    \        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n\
    \            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n\
    \    keyGenerator.generateKey();\n}\n\nprivate void generateSecretKey() {\n  \
    \  KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n\
    \        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n\
    \        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n\
    \        .setUserAuthenticationRequired(true)\n        .setInvalidatedByBiometricEnrollment(true)\n\
    \        // BAD: This key can be accessed using non-biometric credentials. \n\
    \        .setUserAuthenticationValidityDurationSeconds(30)\n        .build();\n\
    \    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES,\
    \ \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n\
    }\n```\n\n## References\n* WithSecure: [How Secure is your Android Keystore Authentication?](https://labs.withsecure.com/publications/how-secure-is-your-android-keystore-authentication).\n\
    * Android Developers: [KeyGenParameterSpec.Builder](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder).\n\
    * Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-287/AndroidInsecureLocalAuthentication.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-287/AndroidInsecureLocalAuthentication.bqrs
  metadata:
    name: Insecure local authentication
    description: Local authentication that does not make use of a `CryptoObject` can
      be bypassed.
    kind: problem
    problem.severity: warning
    security-severity: 4.4
    precision: high
    id: java/android/insecure-local-authentication
    tags: |-
      security
             external/cwe/cwe-287
  queryHelp: |
    # Insecure local authentication
    Biometric local authentication such as fingerprint recognition can be used to protect sensitive data or actions within an application. However, if this authentication does not use a `KeyStore`-backed key, it can be bypassed by a privileged malicious application, or by an attacker with physical access using application hooking tools such as Frida.


    ## Recommendation
    Generate a secure key in the Android `KeyStore`. Ensure that the `onAuthenticationSuccess` callback for a biometric prompt uses it in a way that is required for the sensitive parts of the application to function, such as by using it to decrypt sensitive data or credentials.


    ## Example
    In the following (bad) case, no `CryptoObject` is required for the biometric prompt to grant access, so it can be bypassed.


    ```java
    biometricPrompt.authenticate(
        cancellationSignal,
        executor,
        new BiometricPrompt.AuthenticationCallback {
            @Override
            // BAD: This authentication callback does not make use of a `CryptoObject` from the `result`.
            public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {
                grantAccess()
            }
        }
    )
    ```
    In the following (good) case, a secret key is generated in the Android `KeyStore`. The application requires this secret key for access, using it to decrypt data.


    ```java
    private void generateSecretKey() {
        KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(
            "MySecretKey",
            KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
            .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)
            .setUserAuthenticationRequired(true)
            .setInvalidatedByBiometricEnrollment(true)
            .build();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_AES, "AndroidKeyStore");
        keyGenerator.init(keyGenParameterSpec);
        keyGenerator.generateKey();
    }


    private SecretKey getSecretKey() {
        KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);
        return ((SecretKey)keyStore.getKey("MySecretKey", null));
    }

    private Cipher getCipher() {
        return Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + "/"
                + KeyProperties.BLOCK_MODE_CBC + "/"
                + KeyProperties.ENCRYPTION_PADDING_PKCS7);
    }

    public prompt(byte[] encryptedData) {
        Cipher cipher = getCipher();
        SecretKey secretKey = getSecretKey();
        cipher.init(Cipher.DECRYPT_MODE, secretKey);

        biometricPrompt.authenticate(
            new BiometricPrompt.CryptoObject(cipher),
            cancellationSignal,
            executor,
            new BiometricPrompt.AuthenticationCallback() {
                @Override
                // GOOD: This authentication callback uses the result to decrypt some data.
                public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {
                    Cipher cipher = result.getCryptoObject().getCipher();
                    byte[] decryptedData = cipher.doFinal(encryptedData);
                    grantAccessWithData(decryptedData);
                }
            }
        );
    }
    ```

    ## References
    * OWASP Mobile Application Security: [Android Local Authentication](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
    * OWASP Mobile Application Security: [Testing Biometric Authentication](https://mas.owasp.org/MASTG/tests/android/MASVS-AUTH/MASTG-TEST-0018/)
    * WithSecure: [How Secure is your Android Keystore Authentication?](https://labs.withsecure.com/publications/how-secure-is-your-android-keystore-authentication)
    * Android Developers: [Biometric Authentication](https://developer.android.com/training/sign-in/biometric-auth)
    * Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-295/AndroidMissingCertificatePinning.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-295/AndroidMissingCertificatePinning.bqrs
  metadata:
    name: Android missing certificate pinning
    description: Network connections that do not use certificate pinning may allow
      attackers to eavesdrop on communications.
    kind: problem
    problem.severity: warning
    security-severity: 5.9
    precision: medium
    id: java/android/missing-certificate-pinning
    tags: |-
      security
             external/cwe/cwe-295
  queryHelp: "# Android missing certificate pinning\nCertificate pinning is the practice\
    \ of only trusting a specific set of SSL certificates, rather than those that\
    \ the device trusts by default. In Android applications, it is reccomended to\
    \ use certificate pinning when communicating over the network, in order to minimize\
    \ the risk of machine-in-the-middle attacks from a compromised CA.\n\n\n## Recommendation\n\
    The easiest way to implement certificate pinning is to declare your pins in a\
    \ `network-security-config` XML file. This will automatically provide certificate\
    \ pinning for any network connection made by the app.\n\nAnother way to implement\
    \ certificate pinning is to use the \\`CertificatePinner\\` class from the \\\
    `okhttp\\` library.\n\nA final way to implement certificate pinning is to use\
    \ a `TrustManager`, initialized from a `KeyStore` loaded with only the necessary\
    \ certificates.\n\n\n## Example\nIn the first (bad) case below, a network call\
    \ is performed with no certificate pinning implemented. The other (good) cases\
    \ demonstrate the different ways to implement certificate pinning.\n\n\n```java\n\
    // BAD - By default, this network call does not use certificate pinning\nURLConnection\
    \ conn = new URL(\"https://example.com\").openConnection();\n```\n\n```xml\n<!--\
    \ GOOD: Certificate pinning implemented via a Network Security Config file -->\n\
    \n<!-- In AndroidManifest.xml -->\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\
    \n    package=\"com.example.app\">\n\n    <application android:networkSecurityConfig=\"\
    @xml/NetworkSecurityConfig\">\n        ...\n    </application>\n\n</manifest>\n\
    \n<!-- In res/xml/NetworkSecurityConfig.xml -->\n<network-security-config>\n \
    \   <domain-config>\n        <domain>good.example.com</domain>\n        <pin-set\
    \ expiration=\"2038/1/19\">\n            <pin digest=\"SHA-256\">...</pin>\n \
    \       </pin-set>\n    </domain-config>\n</network-security-config>\n```\n\n\
    ```java\n// GOOD: Certificate pinning implemented via okhttp3.CertificatePinner\
    \ \nCertificatePinner certificatePinner = new CertificatePinner.Builder()\n  \
    \  .add(\"example.com\", \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\"\
    )\n    .build();\nOkHttpClient client = new OkHttpClient.Builder()\n    .certificatePinner(certificatePinner)\n\
    \    .build();\n\nclient.newCall(new Request.Builder().url(\"https://example.com\"\
    ).build()).execute();\n\n\n\n// GOOD: Certificate pinning implemented via a TrustManager\n\
    KeyStore keyStore = KeyStore.getInstance(\"BKS\");\nkeyStore.load(resources.openRawResource(R.raw.cert),\
    \ null);\n\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\
    tmf.init(keyStore);\n\nSSLContext sslContext = SSLContext.getInstance(\"TLS\"\
    );\nsslContext.init(null, tmf.getTrustManagers(), null);\n\nURL url = new URL(\"\
    http://www.example.com/\");\nHttpsURLConnection urlConnection = (HttpsURLConnection)\
    \ url.openConnection(); \n\nurlConnection.setSSLSocketFactory(sslContext.getSocketFactory());\n\
    ```\n\n## References\n* OWASP Mobile Security: [Testing Custom Certificate Stores\
    \ and Certificate Pinning (MSTG-NETWORK-4)](https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05g-testing-network-communication#testing-custom-certificate-stores-and-certificate-pinning-mstg-network-4).\n\
    * Android Developers: [Network security configuration](https://developer.android.com/training/articles/security-config).\n\
    * OkHttp: [CertificatePinner](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/).\n\
    * Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-295/ImproperWebViewCertificateValidation.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-295/ImproperWebViewCertificateValidation.bqrs
  metadata:
    name: Android `WebView` that accepts all certificates
    description: Trusting all certificates allows an attacker to perform a machine-in-the-middle
      attack.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/improper-webview-certificate-validation
    tags: |-
      security
             external/cwe/cwe-295
  queryHelp: "# Android `WebView` that accepts all certificates\nIf the `onReceivedSslError`\
    \ method of an Android `WebViewClient` always calls `proceed` on the given `SslErrorHandler`,\
    \ it trusts any certificate. This allows an attacker to perform a machine-in-the-middle\
    \ attack against the application, therefore breaking any security Transport Layer\
    \ Security (TLS) gives.\n\nAn attack might look like this:\n\n1. The vulnerable\
    \ application connects to `https://example.com`.\n1. The attacker intercepts this\
    \ connection and presents a valid, self-signed certificate for `https://example.com`.\n\
    1. The vulnerable application calls the `onReceivedSslError` method to check whether\
    \ it should trust the certificate.\n1. The `onReceivedSslError` method of your\
    \ `WebViewClient` calls `SslErrorHandler.proceed`.\n1. The vulnerable application\
    \ accepts the certificate and proceeds with the connection since your `WevViewClient`\
    \ trusted it by proceeding.\n1. The attacker can now read the data your application\
    \ sends to `https://example.com` and/or alter its replies while the application\
    \ thinks the connection is secure.\n\n## Recommendation\nDo not use a call `SslerrorHandler.proceed`\
    \ unconditionally. If you have to use a self-signed certificate, only accept that\
    \ certificate, not all certificates.\n\n\n## Example\nIn the first (bad) example,\
    \ the `WebViewClient` trusts all certificates by always calling `SslErrorHandler.proceed`.\
    \ In the second (good) example, only certificates signed by a certain public key\
    \ are accepted.\n\n\n```java\nclass Bad extends WebViewClient {\n    // BAD: All\
    \ certificates are trusted.\n    public void onReceivedSslError (WebView view,\
    \ SslErrorHandler handler, SslError error) { // $hasResult\n        handler.proceed();\
    \ \n    }\n}\n\nclass Good extends WebViewClient {\n    PublicKey myPubKey = ...;\n\
    \n    // GOOD: Only certificates signed by a certain public key are trusted.\n\
    \    public void onReceivedSslError (WebView view, SslErrorHandler handler, SslError\
    \ error) { // $hasResult\n        try {\n            X509Certificate cert = error.getCertificate().getX509Certificate();\n\
    \            cert.verify(this.myPubKey);\n            handler.proceed();\n   \
    \     }\n        catch (CertificateException|NoSuchAlgorithmException|InvalidKeyException|NoSuchProviderException|SignatureException\
    \ e) {\n            handler.cancel();\n        }\n    }    \n}\n```\n\n## References\n\
    * [WebViewClient.onReceivedSslError documentation](https://developer.android.com/reference/android/webkit/WebViewClient?hl=en#onReceivedSslError(android.webkit.WebView,%20android.webkit.SslErrorHandler,%20android.net.http.SslError)).\n\
    * Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-295/InsecureTrustManager.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-295/InsecureTrustManager.bqrs
  metadata:
    name: '`TrustManager` that accepts all certificates'
    description: Trusting all certificates allows an attacker to perform a machine-in-the-middle
      attack.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/insecure-trustmanager
    tags: |-
      security
             external/cwe/cwe-295
  queryHelp: "# `TrustManager` that accepts all certificates\nIf the `checkServerTrusted`\
    \ method of a `TrustManager` never throws a `CertificateException`, it trusts\
    \ every certificate. This allows an attacker to perform a machine-in-the-middle\
    \ attack against the application, therefore breaking any security Transport Layer\
    \ Security (TLS) gives.\n\nAn attack might look like this:\n\n1. The vulnerable\
    \ program connects to `https://example.com`.\n1. The attacker intercepts this\
    \ connection and presents a valid, self-signed certificate for `https://example.com`.\n\
    1. The vulnerable program calls the `checkServerTrusted` method to check whether\
    \ it should trust the certificate.\n1. The `checkServerTrusted` method of your\
    \ `TrustManager` does not throw a `CertificateException`.\n1. The vulnerable program\
    \ accepts the certificate and proceeds with the connection since your `TrustManager`\
    \ implicitly trusted it by not throwing an exception.\n1. The attacker can now\
    \ read the data your program sends to `https://example.com` and/or alter its replies\
    \ while the program thinks the connection is secure.\n\n## Recommendation\nDo\
    \ not use a custom `TrustManager` that trusts any certificate. If you have to\
    \ use a self-signed certificate, don't trust every certificate, but instead only\
    \ trust this specific certificate. See below for an example of how to do this.\n\
    \n\n## Example\nIn the first (bad) example, the `TrustManager` never throws a\
    \ `CertificateException` and therefore implicitly trusts any certificate. This\
    \ allows an attacker to perform a machine-in-the-middle attack. In the second\
    \ (good) example, the self-signed certificate that should be trusted is loaded\
    \ into a `KeyStore`. This explicitly defines the certificate as trusted and there\
    \ is no need to create a custom `TrustManager`.\n\n\n```java\npublic static void\
    \ main(String[] args) throws Exception {\n    {\n        class InsecureTrustManager\
    \ implements X509TrustManager {\n            @Override\n            public X509Certificate[]\
    \ getAcceptedIssuers() {\n                return null;\n            }\n\n    \
    \        @Override\n            public void checkServerTrusted(X509Certificate[]\
    \ chain, String authType) throws CertificateException {\n                // BAD:\
    \ Does not verify the certificate chain, allowing any certificate.\n         \
    \   }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[]\
    \ chain, String authType) throws CertificateException {\n\n            }\n   \
    \     }\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n     \
    \   TrustManager[] trustManager = new TrustManager[] { new InsecureTrustManager()\
    \ };\n        context.init(null, trustManager, null);\n    }\n    {\n        SSLContext\
    \ context = SSLContext.getInstance(\"TLS\");\n        File certificateFile = new\
    \ File(\"path/to/self-signed-certificate\");\n        // Create a `KeyStore` with\
    \ default type\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n\
    \        // `keyStore` is initially empty\n        keyStore.load(null, null);\n\
    \        X509Certificate generatedCertificate;\n        try (InputStream cert\
    \ = new FileInputStream(certificateFile)) {\n            generatedCertificate\
    \ = (X509Certificate) CertificateFactory.getInstance(\"X509\")\n             \
    \       .generateCertificate(cert);\n        }\n        // Add the self-signed\
    \ certificate to the key store\n        keyStore.setCertificateEntry(certificateFile.getName(),\
    \ generatedCertificate);\n        // Get default `TrustManagerFactory`\n     \
    \   TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\
    \        // Use it with our key store that trusts our self-signed certificate\n\
    \        tmf.init(keyStore);\n        TrustManager[] trustManagers = tmf.getTrustManagers();\n\
    \        context.init(null, trustManagers, null);\n        // GOOD, we are not\
    \ using a custom `TrustManager` but instead have\n        // added the self-signed\
    \ certificate we want to trust to the key\n        // store. Note, the `trustManagers`\
    \ will **only** trust this one\n        // certificate.\n        \n        URL\
    \ url = new URL(\"https://self-signed.badssl.com/\");\n        HttpsURLConnection\
    \ conn = (HttpsURLConnection) url.openConnection();\n        conn.setSSLSocketFactory(context.getSocketFactory());\n\
    \    }\n}\n\n```\n\n## References\n* Android Developers: [Security with HTTPS\
    \ and SSL](https://developer.android.com/training/articles/security-ssl).\n* Common\
    \ Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-297/InsecureJavaMail.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-297/InsecureJavaMail.bqrs
  metadata:
    name: Insecure JavaMail SSL Configuration
    description: |-
      Configuring a Java application to use authenticated mail session
                    over SSL without certificate validation
                    makes the session susceptible to a man-in-the-middle attack.
    kind: problem
    problem.severity: warning
    security-severity: 5.9
    precision: medium
    id: java/insecure-smtp-ssl
    tags: |-
      security
             external/cwe/cwe-297
  queryHelp: "# Insecure JavaMail SSL Configuration\nJavaMail is commonly used in\
    \ Java applications to send emails. There are popular third-party libraries like\
    \ Apache Commons Email which are built on JavaMail and facilitate integration.\
    \ Authenticated mail sessions require user credentials and mail sessions can require\
    \ SSL/TLS authentication. It is a common security vulnerability that host-specific\
    \ certificate data is not validated or is incorrectly validated. Failing to validate\
    \ the certificate makes the SSL session susceptible to a man-in-the-middle attack.\n\
    \nThis query checks whether the SSL certificate is validated when credentials\
    \ are used and SSL is enabled in email communications.\n\nThe query has code for\
    \ both plain JavaMail invocation and mailing through Apache SimpleMail to make\
    \ it more comprehensive.\n\n\n## Recommendation\nValidate SSL certificate when\
    \ sensitive information is sent in email communications.\n\n\n## Example\nThe\
    \ following two examples show two ways of configuring secure emails through JavaMail\
    \ or Apache SimpleMail. In the 'BAD' case, credentials are sent in an SSL session\
    \ without certificate validation. In the 'GOOD' case, the certificate is validated.\n\
    \n\n```java\nimport java.util.Properties;\n\nimport javax.activation.DataSource;\n\
    import javax.mail.Authenticator;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\n\
    import javax.mail.PasswordAuthentication;\nimport javax.mail.Session;\n\nimport\
    \ org.apache.logging.log4j.util.PropertiesUtil;\n\nclass JavaMail {\n    public\
    \ static void main(String[] args) {\n      // BAD: Don't have server certificate\
    \ check\n      {\n\t\tfinal Properties properties = PropertiesUtil.getSystemProperties();\n\
    \t\tproperties.put(\"mail.transport.protocol\", \"protocol\");\n\t\tproperties.put(\"\
    mail.smtp.host\", \"hostname\");\n\t\tproperties.put(\"mail.smtp.socketFactory.class\"\
    , \"classname\");\n\n\t\tfinal Authenticator authenticator = buildAuthenticator(\"\
    username\", \"password\");\n\t\tif (null != authenticator) {\n\t\t\tproperties.put(\"\
    mail.smtp.auth\", \"true\");\n\t\t}\n\t\tfinal Session session = Session.getInstance(properties,\
    \ authenticator);\n      }\n\n      // GOOD: Have server certificate check\n \
    \     {\n\t\tfinal Properties properties = PropertiesUtil.getSystemProperties();\n\
    \t\tproperties.put(\"mail.transport.protocol\", \"protocol\");\n\t\tproperties.put(\"\
    mail.smtp.host\", \"hostname\");\n\t\tproperties.put(\"mail.smtp.socketFactory.class\"\
    , \"classname\");\n\n\t\tfinal Authenticator authenticator = buildAuthenticator(\"\
    username\", \"password\");\n\t\tif (null != authenticator) {\n\t\t\tproperties.put(\"\
    mail.smtp.auth\", \"true\");\n\t\t\tproperties.put(\"mail.smtp.ssl.checkserveridentity\"\
    , \"true\");\n\t\t}\n\t\tfinal Session session = Session.getInstance(properties,\
    \ authenticator);\n      }\n    }\n}\n```\n\n```java\nimport org.apache.commons.mail.DefaultAuthenticator;\n\
    import org.apache.commons.mail.Email;\nimport org.apache.commons.mail.EmailException;\n\
    import org.apache.commons.mail.SimpleEmail;\n\nclass SimpleMail {\n    public\
    \ static void main(String[] args) throws EmailException {\n      // BAD: Don't\
    \ have setSSLCheckServerIdentity set or set as false    \n      {\n        Email\
    \ email = new SimpleEmail();\n        email.setHostName(\"hostName\");\n     \
    \   email.setSmtpPort(25);\n        email.setAuthenticator(new DefaultAuthenticator(\"\
    username\", \"password\"));\n        email.setSSLOnConnect(true);\n        \n\
    \        //email.setSSLCheckServerIdentity(false);\n        email.setFrom(\"fromAddress\"\
    );\n        email.setSubject(\"subject\");\n        email.setMsg(\"body\");\n\
    \        email.addTo(\"toAddress\");\n        email.send();\n      }\n\n     \
    \ // GOOD: Have setSSLCheckServerIdentity set to true\n      {\n        Email\
    \ email = new SimpleEmail();\n        email.setHostName(\"hostName\");\n     \
    \   email.setSmtpPort(25);\n        email.setAuthenticator(new DefaultAuthenticator(\"\
    username\", \"password\"));\n        email.setSSLOnConnect(true);\n\n        email.setSSLCheckServerIdentity(true);\n\
    \        email.setFrom(\"fromAddress\");\n        email.setSubject(\"subject\"\
    );\n        email.setMsg(\"body\");\n        email.addTo(\"toAddress\");\n   \
    \     email.send();\n      }\n    }\n}\n```\n\n## References\n* Jakarta Mail:\
    \ [SSL Notes](https://eclipse-ee4j.github.io/mail/docs/SSLNOTES.txt).\n* Apache\
    \ Commons: [Email security](https://commons.apache.org/proper/commons-email/userguide.html#Security).\n\
    * Log4j2: [Add support for specifying an SSL configuration for SmtpAppender (CVE-2020-9488)](https://issues.apache.org/jira/browse/LOG4J2-2819).\n\
    * Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-297/UnsafeHostnameVerification.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-297/UnsafeHostnameVerification.bqrs
  metadata:
    name: Unsafe hostname verification
    description: Marking a certificate as valid for a host without checking the certificate
      hostname allows an attacker to perform a machine-in-the-middle attack.
    kind: path-problem
    problem.severity: error
    security-severity: 5.9
    precision: high
    id: java/unsafe-hostname-verification
    tags: |-
      security
             external/cwe/cwe-297
  queryHelp: "# Unsafe hostname verification\nIf a `HostnameVerifier` always returns\
    \ `true` it will not verify the hostname at all. This stops Transport Layer Security\
    \ (TLS) providing any security and allows an attacker to perform a man-in-the-middle\
    \ attack against the application.\n\nAn attack might look like this:\n\n1. The\
    \ program connects to `https://example.com`.\n1. The attacker intercepts this\
    \ connection and presents an apparently-valid certificate of their choosing.\n\
    1. The `TrustManager` of the program verifies that the certificate has been issued\
    \ by a trusted certificate authority.\n1. The Java HTTPS library checks whether\
    \ the certificate has been issued for the host `example.com`. This check fails\
    \ because the certificate has been issued for a domain controlled by the attacker,\
    \ for example: `malicious.domain`.\n1. The HTTPS library wants to reject the certificate\
    \ because the hostname does not match. Before doing this it checks whether a `HostnameVerifier`\
    \ exists.\n1. Your `HostnameVerifier` is called which returns `true` for any certificate\
    \ so also for this one.\n1. The program proceeds with the connection since your\
    \ `HostnameVerifier` accepted it.\n1. The attacker can now read the data your\
    \ program sends to `https://example.com` and/or alter its replies while the program\
    \ thinks the connection is secure.\n\n## Recommendation\nDo not use an open `HostnameVerifier`.\
    \ If you have a configuration problem with TLS/HTTPS, you should always solve\
    \ the configuration problem instead of using an open verifier.\n\n\n## Example\n\
    In the first (bad) example, the `HostnameVerifier` always returns `true`. This\
    \ allows an attacker to perform a man-in-the-middle attack, because any certificate\
    \ is accepted despite an incorrect hostname. In the second (good) example, the\
    \ `HostnameVerifier` only returns `true` when the certificate has been correctly\
    \ checked.\n\n\n```java\npublic static void main(String[] args) {\n\n\t{\n\t\t\
    HostnameVerifier verifier = new HostnameVerifier() {\n\t\t\t@Override\n\t\t\t\
    public boolean verify(String hostname, SSLSession session) {\n\t\t\t\treturn true;\
    \ // BAD: accept even if the hostname doesn't match\n\t\t\t}\n\t\t};\n\t\tHttpsURLConnection.setDefaultHostnameVerifier(verifier);\n\
    \t}\n\n\t{\n\t\tHostnameVerifier verifier = new HostnameVerifier() {\n\t\t\t@Override\n\
    \t\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\t\ttry\
    \ { // GOOD: verify the certificate\n\t\t\t\t\tCertificate[] certs = session.getPeerCertificates();\n\
    \t\t\t\t\tX509Certificate x509 = (X509Certificate) certs[0];\n\t\t\t\t\tcheck(new\
    \ String[]{host}, x509);\n\t\t\t\t\treturn true;\n\t\t\t\t} catch (SSLException\
    \ e) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tHttpsURLConnection.setDefaultHostnameVerifier(verifier);\n\
    \t}\n\n}\n```\n\n## References\n* Android developers: [Security with HTTPS and\
    \ SSL](https://developer.android.com/training/articles/security-ssl).\n* Terse\
    \ systems blog: [Fixing Hostname Verification](https://tersesystems.com/blog/2014/03/23/fixing-hostname-verification/).\n\
    * Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-312/AllowBackupAttributeEnabled.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-312/AllowBackupAttributeEnabled.bqrs
  metadata:
    name: Application backup allowed
    description: Allowing application backups may allow an attacker to extract sensitive
      data.
    kind: problem
    problem.severity: recommendation
    security-severity: 7.5
    id: java/android/backup-enabled
    tags: |-
      security
             external/cwe/cwe-312
    precision: very-high
  queryHelp: |
    # Application backup allowed
    In the Android manifest file, you can use the `android:allowBackup` attribute of the `application` element to define whether the application will have automatic backups or not.

    If your application uses any sensitive data, you should disable automatic backups to prevent attackers from extracting it.


    ## Recommendation
    For Android applications which process sensitive data, set `android:allowBackup` to `false` in the manifest file.

    Note: Since Android 6.0 (Marshmallow), automatic backups for applications are switched on by default.


    ## Example
    In the following two (bad) examples, the `android:allowBackup` setting is enabled:


    ```xml
    <manifest ... >
        <!-- BAD: 'android:allowBackup' set to 'true' -->
        <application
            android:allowBackup="true">
            <activity ... >
            </activity>
        </application>
    </manifest>

    ```

    ```xml
    <manifest ... >
        <!-- BAD: no 'android:allowBackup' set, defaults to 'true' -->
        <application>
            <activity ... >
            </activity>
        </application>
    </manifest>

    ```
    In the following (good) example, `android:allowBackup` is set to `false`:


    ```xml
    <manifest ... >
        <!-- GOOD: 'android:allowBackup' set to 'false' -->
        <application
            android:allowBackup="false">
            <activity ... >
            </activity>
        </application>
    </manifest>

    ```

    ## References
    * Android Documentation: [Back up user data with Auto Backup](https://developer.android.com/guide/topics/data/autobackup#EnablingAutoBackup)
    * OWASP Mobile Security Testing Guide: [ Android Backups ](https://github.com/OWASP/owasp-mstg/blob/b7a93a2e5e0557cc9a12e55fc3f6675f6986bb86/Document/0x05d-Testing-Data-Storage.md#backups)
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-312/CleartextStorageAndroidDatabase.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-312/CleartextStorageAndroidDatabase.bqrs
  metadata:
    name: Cleartext storage of sensitive information using a local database on Android
    description: |-
      Cleartext Storage of Sensitive Information using
                    a local database on Android allows access for users with root
                    privileges or unexpected exposure from chained vulnerabilities.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/android/cleartext-storage-database
    tags: |-
      security
             external/cwe/cwe-312
  queryHelp: "# Cleartext storage of sensitive information using a local database\
    \ on Android\nSQLite is a lightweight database engine commonly used in Android\
    \ devices to store data. By itself, SQLite does not offer any encryption mechanism\
    \ by default and stores all data in cleartext, which introduces a risk if sensitive\
    \ data like credentials, authentication tokens or personal identifiable information\
    \ (PII) are directly stored in a SQLite database. The information could be accessed\
    \ by any process or user in rooted devices, or can be disclosed through chained\
    \ vulnerabilities, like unexpected access to the private storage through exposed\
    \ components.\n\n\n## Recommendation\nUse `SQLCipher` or similar libraries to\
    \ add encryption capabilities to SQLite. Alternatively, encrypt sensitive data\
    \ using cryptographically secure algorithms before storing it in the database.\n\
    \n\n## Example\nIn the first example, sensitive user information is stored in\
    \ cleartext.\n\nIn the second and third examples, the code encrypts sensitive\
    \ information before saving it to the database.\n\n\n```java\npublic void sqliteStorageUnsafe(Context\
    \ ctx, String name, String password) {\n\t// BAD - sensitive information saved\
    \ in cleartext.\n\tSQLiteDatabase db = ctx.openOrCreateDatabase(\"test\", Context.MODE_PRIVATE,\
    \ null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?, ?)\", new String[] {name,\
    \ password});\n}\n\npublic void sqliteStorageSafe(Context ctx, String name, String\
    \ password) {\n\t// GOOD - sensitive information encrypted with a custom method.\n\
    \tSQLiteDatabase db = ctx.openOrCreateDatabase(\"test\", Context.MODE_PRIVATE,\
    \ null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?, ?)\", new String[] {name,\
    \ encrypt(password)});\n}\n\npublic void sqlCipherStorageSafe(String name, String\
    \ password, String databasePassword) {\n\t// GOOD - sensitive information saved\
    \ using SQLCipher.\n\tnet.sqlcipher.database.SQLiteDatabase db = \n\t\tnet.sqlcipher.database.SQLiteDatabase.openOrCreateDatabase(\"\
    test\", databasePassword, null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?,\
    \ ?)\", new String[] {name, password});\n}\n\nprivate static String encrypt(String\
    \ cleartext) {\n    // Use an encryption or strong hashing algorithm in the real\
    \ world.\n    // The example below just returns a SHA-256 hash.\n    MessageDigest\
    \ digest = MessageDigest.getInstance(\"SHA-256\");\n    byte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n\
    \    String encoded = Base64.getEncoder().encodeToString(hash);\n    return encoded;\n\
    }\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n\
    * SQLCipher: [Android Application Integration](https://www.zetetic.net/sqlcipher/sqlcipher-for-android/)\n\
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-312/CleartextStorageAndroidFilesystem.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-312/CleartextStorageAndroidFilesystem.bqrs
  metadata:
    name: Cleartext storage of sensitive information in the Android filesystem
    description: |-
      Cleartext storage of sensitive information in the Android filesystem
                    allows access for users with root privileges or unexpected exposure
                    from chained vulnerabilities.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/android/cleartext-storage-filesystem
    tags: |-
      security
             external/cwe/cwe-312
  queryHelp: "# Cleartext storage of sensitive information in the Android filesystem\n\
    Android applications with the appropriate permissions can write files either to\
    \ the device external storage or the application internal storage, depending on\
    \ the application's needs. However, sensitive information should not be saved\
    \ in cleartext. Otherwise it can be accessed by any process or user in rooted\
    \ devices, or can be disclosed through chained vulnerabilities, like unexpected\
    \ access to the private storage through exposed components.\n\n\n## Recommendation\n\
    Consider using the `EncryptedFile` class to work with files containing sensitive\
    \ data. Alternatively, use encryption algorithms to encrypt the sensitive data\
    \ being stored.\n\n\n## Example\nIn the first example, sensitive user information\
    \ is stored in cleartext using a local file.\n\nIn the second and third examples,\
    \ the code encrypts sensitive information before saving it to the filesystem.\n\
    \n\n```java\npublic void fileSystemStorageUnsafe(String name, String password)\
    \ {\n\t// BAD - sensitive data stored in cleartext\n    FileWriter fw = new FileWriter(\"\
    some_file.txt\");\n    fw.write(name + \":\" + password);\n    fw.close();\n}\n\
    \npublic void filesystemStorageEncryptedFileSafe(Context context, String name,\
    \ String password) {\n\t// GOOD - the whole file is encrypted with androidx.security.crypto.EncryptedFile\n\
    \    File file = new File(\"some_file.txt\");\n    String masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC);\n\
    \    EncryptedFile encryptedFile = new EncryptedFile.Builder(\n        file,\n\
    \        context,\n        masterKeyAlias,\n        EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB\n\
    \    ).build();\n\tFileOutputStream encryptedOutputStream = encryptedFile.openFileOutput();\n\
    \tencryptedOutputStream.write(name + \":\" + password);\n}\n\npublic void fileSystemStorageSafe(String\
    \ name, String password) {\n\t// GOOD - sensitive data is encrypted using a custom\
    \ method\n    FileWriter fw = new FileWriter(\"some_file.txt\");\n    fw.write(name\
    \ + \":\" + encrypt(password));\n    fw.close();\n}\n\nprivate static String encrypt(String\
    \ cleartext) {\n    // Use an encryption or strong hashing algorithm in the real\
    \ world.\n    // The example below just returns a SHA-256 hash.\n    MessageDigest\
    \ digest = MessageDigest.getInstance(\"SHA-256\");\n    byte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n\
    \    String encoded = Base64.getEncoder().encodeToString(hash);\n    return encoded;\n\
    }\n\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n\
    * Android Developers: [EncryptedFile](https://developer.android.com/reference/androidx/security/crypto/EncryptedFile)\n\
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-312/CleartextStorageCookie.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-312/CleartextStorageCookie.bqrs
  metadata:
    name: Cleartext storage of sensitive information in cookie
    description: Storing sensitive information in cleartext can expose it to an attacker.
    kind: problem
    problem.severity: error
    security-severity: 5.0
    precision: high
    id: java/cleartext-storage-in-cookie
    tags: |-
      security
             external/cwe/cwe-315
  queryHelp: "# Cleartext storage of sensitive information in cookie\nSensitive information\
    \ that is stored unencrypted is accessible to an attacker who gains access to\
    \ the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always\
    \ encrypted before being stored. It may be wise to encrypt information before\
    \ it is put into a heap data structure (such as `Java.util.Properties`) that may\
    \ be written to disk later. Objects that are serializable or marshallable should\
    \ also always contain encrypted information unless you are certain that they are\
    \ not ever going to be serialized.\n\nIn general, decrypt sensitive information\
    \ only at the point where it is necessary for it to be used in cleartext.\n\n\n\
    ## Example\nThe following example shows two ways of storing user credentials in\
    \ a cookie. In the 'BAD' case, the credentials are simply stored in cleartext.\
    \ In the 'GOOD' case, the credentials are hashed before storing them.\n\n\n```java\n\
    public static void main(String[] args) {\n\t{\n\t\tString data;\n\t\tPasswordAuthentication\
    \ credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"BP@ssw0rd\".toCharArray());\n\
    \t\tdata = credentials.getUserName() + \":\" + new String(credentials.getPassword());\n\
    \t\n\t\t// BAD: store data in a cookie in cleartext form\n\t\tresponse.addCookie(new\
    \ Cookie(\"auth\", data));\n\t}\n\t\n\t{\n\t\tString data;\n\t\tPasswordAuthentication\
    \ credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"GP@ssw0rd\".toCharArray());\n\
    \t\tString salt = \"ThisIsMySalt\";\n\t\tMessageDigest messageDigest = MessageDigest.getInstance(\"\
    SHA-512\");\n\t\tmessageDigest.reset();\n\t\tString credentialsToHash =\n\t\t\t\
    \tcredentials.getUserName() + \":\" + credentials.getPassword();\n\t\tbyte[] hashedCredsAsBytes\
    \ =\n\t\t\t\tmessageDigest.digest((salt+credentialsToHash).getBytes(\"UTF-8\"\
    ));\n\t\tdata = bytesToString(hashedCredsAsBytes);\n\t\t\n\t\t// GOOD: store data\
    \ in a cookie in encrypted form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\
    \t}\n}\n\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J.\
    \ Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n\
    * M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*,\
    \ 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison\
    \ Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition,\
    \ Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness\
    \ Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-312/CleartextStorageProperties.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-312/CleartextStorageProperties.bqrs
  metadata:
    name: Cleartext storage of sensitive information using 'Properties' class
    description: Storing sensitive information in cleartext can expose it to an attacker.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/cleartext-storage-in-properties
    tags: |-
      security
             external/cwe/cwe-313
  queryHelp: "# Cleartext storage of sensitive information using 'Properties' class\n\
    Sensitive information that is stored unencrypted is accessible to an attacker\
    \ who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive\
    \ information is always encrypted before being stored. It may be wise to encrypt\
    \ information before it is put into a heap data structure (such as `Java.util.Properties`)\
    \ that may be written to disk later. Objects that are serializable or marshallable\
    \ should also always contain encrypted information unless you are certain that\
    \ they are not ever going to be serialized.\n\nIn general, decrypt sensitive information\
    \ only at the point where it is necessary for it to be used in cleartext.\n\n\n\
    ## Example\nThe following example shows two ways of storing user credentials in\
    \ a cookie. In the 'BAD' case, the credentials are simply stored in cleartext.\
    \ In the 'GOOD' case, the credentials are hashed before storing them.\n\n\n```java\n\
    public static void main(String[] args) {\n\t{\n\t\tString data;\n\t\tPasswordAuthentication\
    \ credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"BP@ssw0rd\".toCharArray());\n\
    \t\tdata = credentials.getUserName() + \":\" + new String(credentials.getPassword());\n\
    \t\n\t\t// BAD: store data in a cookie in cleartext form\n\t\tresponse.addCookie(new\
    \ Cookie(\"auth\", data));\n\t}\n\t\n\t{\n\t\tString data;\n\t\tPasswordAuthentication\
    \ credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"GP@ssw0rd\".toCharArray());\n\
    \t\tString salt = \"ThisIsMySalt\";\n\t\tMessageDigest messageDigest = MessageDigest.getInstance(\"\
    SHA-512\");\n\t\tmessageDigest.reset();\n\t\tString credentialsToHash =\n\t\t\t\
    \tcredentials.getUserName() + \":\" + credentials.getPassword();\n\t\tbyte[] hashedCredsAsBytes\
    \ =\n\t\t\t\tmessageDigest.digest((salt+credentialsToHash).getBytes(\"UTF-8\"\
    ));\n\t\tdata = bytesToString(hashedCredsAsBytes);\n\t\t\n\t\t// GOOD: store data\
    \ in a cookie in encrypted form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\
    \t}\n}\n\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J.\
    \ Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n\
    * M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*,\
    \ 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison\
    \ Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition,\
    \ Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness\
    \ Enumeration: [CWE-313](https://cwe.mitre.org/data/definitions/313.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-312/CleartextStorageSharedPrefs.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-312/CleartextStorageSharedPrefs.bqrs
  metadata:
    name: Cleartext storage of sensitive information using `SharedPreferences` on
      Android
    description: |-
      Cleartext Storage of Sensitive Information using
                    SharedPreferences on Android allows access for users with root
                    privileges or unexpected exposure from chained vulnerabilities.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/android/cleartext-storage-shared-prefs
    tags: |-
      security
             external/cwe/cwe-312
  queryHelp: "# Cleartext storage of sensitive information using `SharedPreferences`\
    \ on Android\n`SharedPreferences` is an Android API that stores application preferences\
    \ using simple sets of data values. It allows you to easily save, alter, and retrieve\
    \ the values stored in a user's profile. However, sensitive information should\
    \ not be saved in cleartext. Otherwise it can be accessed by any process or user\
    \ in rooted devices, or can be disclosed through chained vulnerabilities, like\
    \ unexpected access to the private storage through exposed components.\n\n\n##\
    \ Recommendation\nUse the `EncryptedSharedPreferences` API or other encryption\
    \ algorithms for storing sensitive information.\n\n\n## Example\nIn the first\
    \ example, sensitive user information is stored in cleartext.\n\nIn the second\
    \ and third examples, the code encrypts sensitive information before saving it\
    \ to the device.\n\n\n```java\npublic void testSetSharedPrefs(Context context,\
    \ String name, String password)\n{\n\t{\n\t\t// BAD - sensitive information saved\
    \ in cleartext.\n\t\tSharedPreferences sharedPrefs = context.getSharedPreferences(\"\
    user_prefs\", Context.MODE_PRIVATE);\n\t\tEditor editor = sharedPrefs.edit();\n\
    \t\teditor.putString(\"name\", name);\n\t\teditor.putString(\"password\", password);\n\
    \t\teditor.commit();\n\t}\n\n\t{\n\t\t// GOOD - save sensitive information encrypted\
    \ with a custom method.\n\t\tSharedPreferences sharedPrefs = context.getSharedPreferences(\"\
    user_prefs\", Context.MODE_PRIVATE);\n\t\tEditor editor = sharedPrefs.edit();\n\
    \t\teditor.putString(\"name\", encrypt(name));\n\t\teditor.putString(\"password\"\
    , encrypt(password));\n\t\teditor.commit();\n\t}\n\n\t{\n\t\t// GOOD - sensitive\
    \ information saved using the built-in `EncryptedSharedPreferences` class in androidx.\n\
    \t\tMasterKey masterKey = new MasterKey.Builder(context, MasterKey.DEFAULT_MASTER_KEY_ALIAS)\n\
    \t\t\t.setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n\t\t\t.build();\n\n\t\tSharedPreferences\
    \ sharedPreferences = EncryptedSharedPreferences.create(\n\t\t\tcontext,\n\t\t\
    \t\"secret_shared_prefs\",\n\t\t\tmasterKey,\n\t\t\tEncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n\
    \t\t\tEncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM);\n\n\t\t\
    SharedPreferences.Editor editor = sharedPreferences.edit();\n\t\teditor.putString(\"\
    name\", name);\n\t\teditor.putString(\"password\", password);\n\t\teditor.commit();\n\
    \t}\n}\n\nprivate static String encrypt(String cleartext) throws Exception {\n\
    \t// Use an encryption or hashing algorithm in real world. The demo below just\
    \ returns its\n\t// hash.\n\tMessageDigest digest = MessageDigest.getInstance(\"\
    SHA-256\");\n\tbyte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n\
    \tString encoded = Base64.getEncoder().encodeToString(hash);\n\treturn encoded;\n\
    }\n\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n\
    * ProAndroidDev: [Encrypted Preferences in Android](https://proandroiddev.com/encrypted-preferences-in-android-af57a89af7c8)\n\
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-326/InsufficientKeySize.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-326/InsufficientKeySize.bqrs
  metadata:
    name: Use of a cryptographic algorithm with insufficient key size
    description: |-
      Using cryptographic algorithms with too small a key size can
                    allow an attacker to compromise security.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: java/insufficient-key-size
    tags: |-
      security
             external/cwe/cwe-326
  queryHelp: |
    # Use of a cryptographic algorithm with insufficient key size
    Modern encryption relies on the computational infeasibility of breaking a cipher and decoding its message without the key. As computational power increases, the ability to break ciphers grows, and key sizes need to become larger as a result. Cryptographic algorithms that use too small of a key size are vulnerable to brute force attacks, which can reveal sensitive data.


    ## Recommendation
    Use a key of the recommended size or larger. The key size should be at least 128 bits for AES encryption, 256 bits for elliptic-curve cryptography (ECC), and 2048 bits for RSA, DSA, or DH encryption.


    ## Example
    The following code uses cryptographic algorithms with insufficient key sizes.


    ```java
        KeyPairGenerator keyPairGen1 = KeyPairGenerator.getInstance("RSA");
        keyPairGen1.initialize(1024); // BAD: Key size is less than 2048

        KeyPairGenerator keyPairGen2 = KeyPairGenerator.getInstance("DSA");
        keyPairGen2.initialize(1024); // BAD: Key size is less than 2048

        KeyPairGenerator keyPairGen3 = KeyPairGenerator.getInstance("DH");
        keyPairGen3.initialize(1024); // BAD: Key size is less than 2048

        KeyPairGenerator keyPairGen4 = KeyPairGenerator.getInstance("EC");
        ECGenParameterSpec ecSpec = new ECGenParameterSpec("secp112r1"); // BAD: Key size is less than 256
        keyPairGen4.initialize(ecSpec);

        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(64); // BAD: Key size is less than 128

    ```
    To fix the code, change the key sizes to be the recommended size or larger for each algorithm.


    ## References
    * Wikipedia: [Key size](http://en.wikipedia.org/wiki/Key_size).
    * Wikipedia: [Strong cryptography](https://en.wikipedia.org/wiki/Strong_cryptography).
    * OWASP: [ Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms).
    * OWASP: [ Testing for Weak Encryption](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/04-Testing_for_Weak_Encryption).
    * NIST: [ Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf).
    * Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-327/BrokenCryptoAlgorithm.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-327/BrokenCryptoAlgorithm.bqrs
  metadata:
    name: Use of a broken or risky cryptographic algorithm
    description: Using broken or weak cryptographic algorithms can allow an attacker
      to compromise security.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: java/weak-cryptographic-algorithm
    tags: |-
      security
             external/cwe/cwe-327
             external/cwe/cwe-328
  queryHelp: "# Use of a broken or risky cryptographic algorithm\nUsing broken or\
    \ weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\
    \nMany cryptographic algorithms provided by cryptography libraries are known to\
    \ be weak, or flawed. Using such an algorithm means that an attacker may be able\
    \ to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you\
    \ use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\
    \ Do not use the ECB encryption mode since it is vulnerable to replay and other\
    \ attacks.\n\n\n## Example\nThe following code shows an example of using a java\
    \ `Cipher` to encrypt some data. When creating a `Cipher` instance, you must specify\
    \ the encryption algorithm to use. The first example uses DES, which is an older\
    \ algorithm that is now considered weak. The second example uses AES, which is\
    \ a strong modern algorithm.\n\n\n```java\n// BAD: DES is a weak algorithm \n\
    Cipher des = Cipher.getInstance(\"DES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n\
    \nbyte[] encrypted = cipher.doFinal(input.getBytes(\"UTF-8\"));\n\n// ...\n\n\
    // GOOD: AES is a strong algorithm\nCipher aes = Cipher.getInstance(\"AES\");\n\
    \n// ...\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security\
    \ Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n\
    * NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of\
    \ Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n\
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n\
    * Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-327/MaybeBrokenCryptoAlgorithm.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-327/MaybeBrokenCryptoAlgorithm.bqrs
  metadata:
    name: Use of a potentially broken or risky cryptographic algorithm
    description: Using broken or weak cryptographic algorithms can allow an attacker
      to compromise security.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/potentially-weak-cryptographic-algorithm
    tags: |-
      security
             external/cwe/cwe-327
             external/cwe/cwe-328
  queryHelp: "# Use of a potentially broken or risky cryptographic algorithm\nUsing\
    \ broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\
    \nMany cryptographic algorithms provided by cryptography libraries are known to\
    \ be weak, or flawed. Using such an algorithm means that an attacker may be able\
    \ to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you\
    \ use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\
    \ Do not use the ECB encryption mode since it is vulnerable to replay and other\
    \ attacks.\n\n\n## Example\nThe following code shows an example of using a java\
    \ `Cipher` to encrypt some data. When creating a `Cipher` instance, you must specify\
    \ the encryption algorithm to use. The first example uses DES, which is an older\
    \ algorithm that is now considered weak. The second example uses AES, which is\
    \ a strong modern algorithm.\n\n\n```java\n// BAD: DES is a weak algorithm \n\
    Cipher des = Cipher.getInstance(\"DES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n\
    \nbyte[] encrypted = cipher.doFinal(input.getBytes(\"UTF-8\"));\n\n// ...\n\n\
    // GOOD: AES is a strong algorithm\nCipher aes = Cipher.getInstance(\"AES\");\n\
    \n// ...\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security\
    \ Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n\
    * NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of\
    \ Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n\
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n\
    * Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-330/InsecureRandomness.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-330/InsecureRandomness.bqrs
  metadata:
    name: Insecure randomness
    description: |-
      Using a cryptographically Insecure pseudo-random number generator to generate a
                    security-sensitive value may allow an attacker to predict what value will
                    be generated.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: java/insecure-randomness
    tags: |-
      security
            external/cwe/cwe-330
            external/cwe/cwe-338
  queryHelp: |
    # Insecure randomness
    If you use a cryptographically weak pseudo-random number generator to generate security-sensitive values, such as passwords, attackers can more easily predict those values.

    Pseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values (the seed). If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.


    ## Recommendation
    The `java.util.Random` random number generator is not cryptographically secure. Use a secure random number generator such as `java.security.SecureRandom` instead.

    Use a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a general rule, a value should be considered "security-sensitive" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.


    ## Example
    The following examples show different ways of generating a cookie with a random value.

    In the first (BAD) case, we generate a fresh cookie by appending a random integer to the end of a static string. The random number generator used (`Random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated cookie.


    ```java
    Random r = new Random();

    byte[] bytes = new byte[16];
    r.nextBytes(bytes);

    String cookieValue = encode(bytes);

    Cookie cookie = new Cookie("name", cookieValue);
    response.addCookie(cookie);

    ```
    In the second (GOOD) case, we generate a fresh cookie by appending a random integer to the end of a static string. The random number generator used (`SecureRandom`) is cryptographically secure, so it is not possible for an attacker to predict the generated cookie.


    ```java
    SecureRandom r = new SecureRandom();

    byte[] bytes = new byte[16];
    r.nextBytes(bytes);

    String cookieValue = encode(bytes);

    Cookie cookie = new Cookie("name", cookieValue);
    response.addCookie(cookie);

    ```

    ## References
    * Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).
    * Java Docs: [Random](http://docs.oracle.com/javase/8/docs/api/java/util/Random.html).
    * Java Docs: [SecureRandom](http://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html).
    * Common Weakness Enumeration: [CWE-330](https://cwe.mitre.org/data/definitions/330.html).
    * Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-335/PredictableSeed.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-335/PredictableSeed.bqrs
  metadata:
    name: Use of a predictable seed in a secure random number generator
    description: Using a predictable seed in a pseudo-random number generator can
      lead to predictability of the numbers generated by it.
    kind: problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/predictable-seed
    tags: |-
      security
             external/cwe/cwe-335
             external/cwe/cwe-337
  queryHelp: |
    # Use of a predictable seed in a secure random number generator
    Using a predictable seed in a pseudo-random number generator can lead to predictability of the numbers generated by it.


    ## Recommendation
    If the predictability of the pseudo-random number generator does not matter then consider using the faster `Random` class from `java.util`. If it is important that the pseudo-random number generator produces completely unpredictable values then either let the generator securely seed itself by not specifying a seed or specify a randomly generated, unpredictable seed.


    ## Example
    In the first example shown here, a constant value is used as a seed. Depending on the implementation of ` SecureRandom`, this could lead to the same random number being generated each time the code is executed.

    In the second example shown here, the system time is used as a seed. Depending on the implementation of ` SecureRandom`, if an attacker knows what time the code was run, they could predict the generated random number.

    In the third example shown here, the random number generator is allowed to generate its own seed, which it will do in a secure way.


    ```java
    SecureRandom prng = new SecureRandom();
    int randomData = 0;

    // BAD: Using a constant value as a seed for a random number generator means all numbers it generates are predictable.
    prng.setSeed(12345L);
    randomData = prng.next(32);

    // BAD: System.currentTimeMillis() returns the system time which is predictable.
    prng.setSeed(System.currentTimeMillis());
    randomData = prng.next(32);

    // GOOD: SecureRandom implementations seed themselves securely by default.
    prng = new SecureRandom();
    randomData = prng.next(32);

    ```

    ## References
    * Common Weakness Enumeration: [CWE-335](https://cwe.mitre.org/data/definitions/335.html).
    * Common Weakness Enumeration: [CWE-337](https://cwe.mitre.org/data/definitions/337.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-338/JHipsterGeneratedPRNG.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-338/JHipsterGeneratedPRNG.bqrs
  metadata:
    name: Detect JHipster Generator Vulnerability CVE-2019-16303
    description: Using a vulnerable version of JHipster to generate random numbers
      makes it easier for attackers to take over accounts.
    kind: problem
    problem.severity: error
    security-severity: 7.8
    precision: very-high
    id: java/jhipster-prng
    tags: |-
      security
             external/cwe/cwe-338
  queryHelp: |
    # Detect JHipster Generator Vulnerability CVE-2019-16303
    This query detects instances of `RandomUtil.java` that were generated by a [JHipster](https://www.jhipster.tech/) version that is vulnerable to [CVE-2019-16303](https://github.com/jhipster/jhipster-kotlin/security/advisories/GHSA-j3rh-8vwq-wh84).

    If an app uses `RandomUtil.java` generated by a vulnerable version of JHipster, attackers can request a password reset token and use this to predict the value of future reset tokens generated by this server. Using this information, they can create a reset link that allows them to take over any account.

    This vulnerability has a [ CVSS v3.0 Base Score of 9.8/10 ](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?name=CVE-2019-16303&vector=AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H&version=3.1&source=NIST).


    ## Example
    The example below shows the vulnerable `RandomUtil` class generated by [JHipster prior to version 6.3.0](https://www.jhipster.tech/2019/09/13/jhipster-release-6.3.0.html).


    ```java
    import org.apache.commons.lang3.RandomStringUtils;

    /**
     * Utility class for generating random Strings.
     */
    public final class RandomUtil {

        private static final int DEF_COUNT = 20;

        private RandomUtil() {
        }

        /**
         * Generate a password.
         *
         * @return the generated password.
         */
        public static String generatePassword() {
            return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom
        }

        /**
         * Generate an activation key.
         *
         * @return the generated activation key.
         */
        public static String generateActivationKey() {
            return RandomStringUtils.randomNumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom
        }

        /**
         * Generate a reset key.
         *
         * @return the generated reset key.
         */
        public static String generateResetKey() {
            return RandomStringUtils.randomNumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom
        }

        /**
         * Generate a unique series to validate a persistent token, used in the
         * authentication remember-me mechanism.
         *
         * @return the generated series data.
         */
        public static String generateSeriesData() {
            return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom
        }

        /**
         * Generate a persistent token, used in the authentication remember-me mechanism.
         *
         * @return the generated token data.
         */
        public static String generateTokenData() {
            return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom
        }
    }

    ```
    Below is a fixed version of the `RandomUtil` class.


    ```java
    import org.apache.commons.lang3.RandomStringUtils;

    import java.security.SecureRandom;

    /**
     * Utility class for generating random Strings.
     */
    public final class RandomUtil {
        private static final SecureRandom SECURE_RANDOM = new SecureRandom(); // GOOD: Using SecureRandom

        private static final int DEF_COUNT = 20;

        static {
            SECURE_RANDOM.nextBytes(new byte[64]);
        }

        private RandomUtil() {
        }

        private static String generateRandomAlphanumericString() {
            // GOOD: Passing Secure Random to RandomStringUtils::random
            return RandomStringUtils.random(DEF_COUNT, 0, 0, true, true, null, SECURE_RANDOM);
        }

        /**
         * Generate a password.
         *
         * @return the generated password.
         */
        public static String generatePassword() {
            return generateRandomAlphanumericString();
        }

        /**
         * Generate an activation key.
         *
         * @return the generated activation key.
         */
        public static String generateActivationKey() {
            return generateRandomAlphanumericString();
        }

        /**
         * Generate a reset key.
         *
         * @return the generated reset key.
         */
        public static String generateResetKey() {
            return generateRandomAlphanumericString();
        }

        /**
         * Generate a unique series to validate a persistent token, used in the
         * authentication remember-me mechanism.
         *
         * @return the generated series data.
         */
        public static String generateSeriesData() {
            return generateRandomAlphanumericString();
        }

        /**
         * Generate a persistent token, used in the authentication remember-me mechanism.
         *
         * @return the generated token data.
         */
        public static String generateTokenData() {
            return generateRandomAlphanumericString();
        }
    }

    ```

    ## Recommendation
    You should refactor the `RandomUtil` class and replace every call to `RandomStringUtils.randomAlphaNumeric`. You could regenerate the class using the latest version of JHipster, or use an automated refactoring. For example, using the [Patching JHipster CWE-338](https://github.com/moderneinc/jhipster-cwe-338) for the [Rewrite project](https://github.com/openrewrite/rewrite).


    ## References
    * Cloudflare Blog: [ Why secure systems require random numbers ](https://blog.cloudflare.com/why-randomness-matters/)
    * Hacker News: [ How I Hacked Hacker News (with arc security advisory) ](https://news.ycombinator.com/item?id=639976)
    * Posts by Pucara Information Security Team: [ The Java Soothsayer: A practical application for insecure randomness. (Includes free 0day) ](https://blog.pucarasec.com/2020/05/09/the-java-soothsayer-a-practical-application-for-insecure-randomness-includes-free-0day/)
    * Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-347/MissingJWTSignatureCheck.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-347/MissingJWTSignatureCheck.bqrs
  metadata:
    name: Missing JWT signature check
    description: Failing to check the Json Web Token (JWT) signature may allow an
      attacker to forge their own tokens.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: java/missing-jwt-signature-check
    tags: |-
      security
             external/cwe/cwe-347
  queryHelp: |
    # Missing JWT signature check
    A JSON Web Token (JWT) consists of three parts: header, payload, and signature. The `io.jsonwebtoken.jjwt` library is one of many libraries used for working with JWTs. It offers different methods for parsing tokens like `parse`, `parseClaimsJws`, and `parsePlaintextJws`. The last two correctly verify that the JWT is properly signed. This is done by computing the signature of the combination of header and payload and comparing the locally computed signature with the signature part of the JWT.

    Therefore it is necessary to provide the `JwtParser` with a key that is used for signature validation. Unfortunately the `parse` method **accepts** a JWT whose signature is empty although a signing key has been set for the parser. This means that an attacker can create arbitrary JWTs that will be accepted if this method is used.


    ## Recommendation
    Always verify the signature by using either the `parseClaimsJws` and `parsePlaintextJws` methods or by overriding the `onPlaintextJws` or `onClaimsJws` of `JwtHandlerAdapter`.


    ## Example
    The following example shows four cases where a signing key is set for a parser. In the first 'BAD' case the `parse` method is used, which will not validate the signature. The second 'BAD' case uses a `JwtHandlerAdapter` where the `onPlaintextJwt` method is overriden, so it will not validate the signature. The third and fourth 'GOOD' cases use `parseClaimsJws` method or override the `onPlaintextJws` method.


    ```java
    public void badJwt(String token) {
        Jwts.parserBuilder()
                    .setSigningKey("someBase64EncodedKey").build()
                    .parse(token); // BAD: Does not verify the signature
    }

    public void badJwtHandler(String token) {
        Jwts.parserBuilder()
                    .setSigningKey("someBase64EncodedKey").build()
                    .parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, String>>() {
                        @Override
                        public Jwt<Header, String> onPlaintextJwt(Jwt<Header, String> jwt) {
                            return jwt;
                        }
                    }); // BAD: The handler is called on an unverified JWT
    }

    public void goodJwt(String token) {
        Jwts.parserBuilder()
                    .setSigningKey("someBase64EncodedKey").build()
                    .parseClaimsJws(token) // GOOD: Verify the signature
                    .getBody();
    }

    public void goodJwtHandler(String token) {
        Jwts.parserBuilder()
                    .setSigningKey("someBase64EncodedKey").build()
                    .parse(plaintextJwt, new JwtHandlerAdapter<Jws<String>>() {
                        @Override
                        public Jws<String> onPlaintextJws(Jws<String> jws) {
                            return jws;
                        }
                    }); // GOOD: The handler is called on a verified JWS
    }
    ```

    ## References
    * zofrex: [How I Found An alg=none JWT Vulnerability in the NHS Contact Tracing App](https://www.zofrex.com/blog/2020/10/20/alg-none-jwt-nhs-contact-tracing-app/).
    * Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-352/SpringCSRFProtection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-352/SpringCSRFProtection.bqrs
  metadata:
    name: Disabled Spring CSRF protection
    description: |-
      Disabling CSRF protection makes the application vulnerable to
                    a Cross-Site Request Forgery (CSRF) attack.
    kind: problem
    problem.severity: error
    security-severity: 8.8
    precision: high
    id: java/spring-disabled-csrf-protection
    tags: |-
      security
             external/cwe/cwe-352
  queryHelp: "# Disabled Spring CSRF protection\nWhen you set up a web server to receive\
    \ a request from a client without any mechanism for verifying that it was intentionally\
    \ sent, then it is vulnerable to attack. An attacker can trick a client into making\
    \ an unintended request to the web server that will be treated as an authentic\
    \ request. This can be done via a URL, image load, XMLHttpRequest, etc. and can\
    \ result in exposure of data or unintended code execution.\n\n\n## Recommendation\n\
    When you use Spring, Cross-Site Request Forgery (CSRF) protection is enabled by\
    \ default. Spring's recommendation is to use CSRF protection for any request that\
    \ could be processed by a browser client by normal users.\n\n\n## Example\nThe\
    \ following example shows the Spring Java configuration with CSRF protection disabled.\
    \ This type of configuration should only be used if you are creating a service\
    \ that is used only by non-browser clients.\n\n\n```java\nimport org.springframework.context.annotation.Configuration;\n\
    import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n\
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n\
    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\
    \n@EnableWebSecurity\n@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter\
    \ {\n  @Override\n  protected void configure(HttpSecurity http) throws Exception\
    \ {\n    http\n      .csrf(csrf ->\n        // BAD - CSRF protection shouldn't\
    \ be disabled\n        csrf.disable() \n      );\n  }\n}\n\n```\n\n## References\n\
    * OWASP: [Cross-Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).\n\
    * Spring Security Reference: [ Cross Site Request Forgery (CSRF) for Servlet Environments\
    \ ](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-csrf).\n\
    * Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-367/TOCTOURace.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-367/TOCTOURace.bqrs
  metadata:
    name: Time-of-check time-of-use race condition
    description: |-
      Using a resource after an unsynchronized state check can lead to a race condition,
                    if the state may be changed between the check and use.
    kind: problem
    problem.severity: warning
    security-severity: 7.7
    precision: medium
    id: java/toctou-race-condition
    tags: |-
      security
             external/cwe/cwe-367
  queryHelp: "# Time-of-check time-of-use race condition\nOften it is necessary to\
    \ check the state of a resource before using it. If the resource is accessed concurrently,\
    \ then the check and the use need to be performed atomically, otherwise the state\
    \ of the resource may change between the check and the use. This can lead to a\
    \ \"time-of-check/time-of-use\" (TOCTOU) race condition.\n\nIn Java, classes may\
    \ present state inspection methods and operation methods which are synchronized.\
    \ This prevents multiple threads from executing those methods simultaneously,\
    \ but it does not prevent a state change in between separate method invocations.\n\
    \n\n## Recommendation\nWhen calling a series of methods which require a consistent\
    \ view of an object, make sure to synchronize on a monitor that will prevent any\
    \ other access to the object during your operations.\n\nIf the class that you\
    \ are using has a well-designed interface, then synchronizing on the object itself\
    \ will prevent its state being changed inappropriately.\n\n\n## Example\nThe following\
    \ example shows a resource which has a readiness state, and an action that is\
    \ only valid if the resource is ready.\n\nIn the bad case, the caller checks the\
    \ readiness state and then acts, but does not synchronize around the two calls,\
    \ so the readiness state may be changed by another thread.\n\nIn the good case,\
    \ the caller jointly synchronizes the check and the use on the resource, so no\
    \ other thread can modify the state before the use.\n\n\n```java\nclass Resource\
    \ {\n\tpublic synchronized boolean isReady() { ... }\n\n\tpublic synchronized\
    \ void setReady(boolean ready) { ... }\n\t\n\tpublic synchronized void act() {\
    \ \n\t\tif (!isReady())\n\t\t\tthrow new IllegalStateException();\n\t\t...\n\t\
    }\n}\n\t\npublic synchronized void bad(Resource r) {\n\tif (r.isReady()) {\n\t\
    \t// r might no longer be ready, another thread might\n\t\t// have called setReady(false)\n\
    \t\tr.act();\n\t}\n}\n\npublic synchronized void good(Resource r) {\n\tsynchronized(r)\
    \ {\n\t\tif (r.isReady()) {\n\t\t\tr.act();\n\t\t}\n\t}\n}\n```\n\n## References\n\
    * Common Weakness Enumeration: [CWE-367](https://cwe.mitre.org/data/definitions/367.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-421/SocketAuthRace.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-421/SocketAuthRace.bqrs
  metadata:
    name: Race condition in socket authentication
    description: Opening a socket after authenticating via a different channel may
      allow an attacker to connect to the port first.
    kind: problem
    problem.severity: warning
    security-severity: 7.2
    precision: medium
    id: java/socket-auth-race-condition
    tags: |-
      security
             external/cwe/cwe-421
  queryHelp: "# Race condition in socket authentication\nA common pattern is to have\
    \ a channel of communication open with a user, and then to open another channel,\
    \ for example to transfer data. However, if user authentication is done over the\
    \ original channel rather than the alternate channel, then an attacker may be\
    \ able to connect to the alternate channel before the legitimate user does. This\
    \ allows the attacker to impersonate the user by \"piggybacking\" on any previous\
    \ authentication.\n\n\n## Recommendation\nWhen opening an alternate channel for\
    \ an authenticated user (for example, a Java `Socket`), always authenticate the\
    \ user over the new channel.\n\n\n## Example\nThis example shows two ways of opening\
    \ a connection for a user. In the first example, authentication is determined\
    \ based on materials that the user has already provided (for example, their username\
    \ and/or password), and then a new channel is opened. However, no authentication\
    \ is done over the new channel, and so an attacker could connect to it before\
    \ the user connects.\n\nIn the second example, authentication is done over the\
    \ socket channel itself, which verifies that the newly connected user is in fact\
    \ the user that was expected.\n\n\n```java\npublic void doConnect(int desiredPort,\
    \ String username) {\n\tServerSocket listenSocket = new ServerSocket(desiredPort);\n\
    \n\tif (isAuthenticated(username)) {\n\t\tSocket connection1 = listenSocket.accept();\n\
    \t\t// BAD: no authentication over the socket connection\n\t\tconnection1.getOutputStream().write(secretData);\n\
    \t}\n}\n\npublic void doConnect(int desiredPort, String username) {\n\tServerSocket\
    \ listenSocket = new ServerSocket(desiredPort);\n\n\tSocket connection2 = listenSocket.accept();\n\
    \t// GOOD: authentication happens over the socket\n\tif (doAuthenticate(connection2,\
    \ username)) {\n\t\tconnection2.getOutputStream().write(secretData);\n\t}\n}\n\
    ```\n\n## References\n* Common Weakness Enumeration: [CWE-421](https://cwe.mitre.org/data/definitions/421.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-441/UnsafeContentUriResolution.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-441/UnsafeContentUriResolution.bqrs
  metadata:
    name: Uncontrolled data used in content resolution
    description: |-
      Resolving externally-provided content URIs without validation can allow an attacker
                    to access unexpected resources.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: java/android/unsafe-content-uri-resolution
    tags: |-
      security
           external/cwe/cwe-441
           external/cwe/cwe-610
  queryHelp: |
    # Uncontrolled data used in content resolution
    When an Android application wants to access data in a content provider, it uses the `ContentResolver` object. `ContentResolver`s communicate with an instance of a class that implements the `ContentProvider` interface via URIs with the `content://` scheme. The authority part (the first path segment) of the URI, passed as parameter to the `ContentResolver`, determines which content provider is contacted for the operation. Specific operations that act on files also support the `file://` scheme, in which case the local filesystem is queried instead. If an external component, like a malicious or compromised application, controls the URI for a `ContentResolver` operation, it can trick the vulnerable application into accessing its own private files or non-exported content providers. The attacking application might be able to get access to the file by forcing it to be copied to a public directory, like external storage, or tamper with the contents by making the application overwrite the file with unexpected data.


    ## Recommendation
    If possible, avoid using externally-provided data to determine the URI for a `ContentResolver` to use. If that is not an option, validate that the incoming URI can only reference trusted components, like an allow list of content providers and/or applications, or alternatively make sure that the URI does not reference private directories like `/data/`.


    ## Example
    This example shows three ways of opening a file using a `ContentResolver`. In the first case, externally-provided data from an intent is used directly in the file-reading operation. This allows an attacker to provide a URI of the form `/data/data/(vulnerable app package)/(private file)` to trick the application into reading it and copying it to the external storage. In the second case, an insufficient check is performed on the externally-provided URI, still leaving room for exploitation. In the third case, the URI is correctly validated before being used, making sure it does not reference any internal application files.


    ```java
    import android.content.ContentResolver;
    import android.net.Uri;

    public class Example extends Activity {
        public void onCreate() {
            // BAD: Externally-provided URI directly used in content resolution
            {
                ContentResolver contentResolver = getContentResolver();
                Uri uri = (Uri) getIntent().getParcelableExtra("URI_EXTRA");
                InputStream is = contentResolver.openInputStream(uri);
                copyToExternalCache(is);
            }
            // BAD: input URI is not normalized, and check can be bypassed with ".." characters
            {
                ContentResolver contentResolver = getContentResolver();
                Uri uri = (Uri) getIntent().getParcelableExtra("URI_EXTRA");
                String path = uri.getPath();
                if (path.startsWith("/data"))
                    throw new SecurityException();
                InputStream is = contentResolver.openInputStream(uri);
                copyToExternalCache(is);
            }
            // GOOD: URI is properly validated to block access to internal files
            {
                ContentResolver contentResolver = getContentResolver();
                Uri uri = (Uri) getIntent().getParcelableExtra("URI_EXTRA");
                String path = uri.getPath();
                java.nio.file.Path normalized =
                        java.nio.file.FileSystems.getDefault().getPath(path).normalize();
                if (normalized.startsWith("/data"))
                    throw new SecurityException();
                InputStream is = contentResolver.openInputStream(uri);
                copyToExternalCache(is);
            }
        }

        private void copyToExternalCache(InputStream is) {
            // Reads the contents of is and writes a file in the app's external
            // cache directory, which can be read publicly by applications in the same device.
        }
    }

    ```

    ## References
    * Android developers: [Content provider basics](https://developer.android.com/guide/topics/providers/content-provider-basics)
    * [The ContentResolver class](https://developer.android.com/reference/android/content/ContentResolver)
    * Common Weakness Enumeration: [CWE-441](https://cwe.mitre.org/data/definitions/441.html).
    * Common Weakness Enumeration: [CWE-610](https://cwe.mitre.org/data/definitions/610.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-470/FragmentInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-470/FragmentInjection.bqrs
  metadata:
    name: Android fragment injection
    description: |-
      Instantiating an Android fragment from a user-provided value
                    may allow a malicious application to bypass access controls,  exposing the application to unintended effects.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/android/fragment-injection
    tags: |-
      security
             external/cwe/cwe-470
  queryHelp: |
    # Android fragment injection
    When fragments are instantiated with externally provided names, this exposes any exported activity that dynamically creates and hosts the fragment to fragment injection. A malicious application could provide the name of an arbitrary fragment, even one not designed to be externally accessible, and inject it into the activity. This can bypass access controls and expose the application to unintended effects.

    Fragments are reusable parts of an Android application's user interface. Even though a fragment controls its own lifecycle and layout, and handles its input events, it cannot exist on its own: it must be hosted either by an activity or another fragment. This means that, normally, a fragment will be accessible by third-party applications (that is, exported) only if its hosting activity is itself exported.


    ## Recommendation
    In general, do not instantiate classes (including fragments) with user-provided names unless the name has been properly validated. Also, if an exported activity is extending the `PreferenceActivity` class, make sure that the `isValidFragment` method is overriden and only returns `true` when the provided `fragmentName` points to an intended fragment.


    ## Example
    The following example shows two cases: in the first one, untrusted data is used to instantiate and add a fragment to an activity, while in the second one, a fragment is safely added with a static name.


    ```java
    public class MyActivity extends FragmentActivity {

        @Override
        protected void onCreate(Bundle savedInstance) {
            try {
                super.onCreate(savedInstance);
                // BAD: Fragment instantiated from user input without validation
                {
                    String fName = getIntent().getStringExtra("fragmentName");
                    getFragmentManager().beginTransaction().replace(com.android.internal.R.id.prefs,
                            Fragment.instantiate(this, fName, null)).commit();
                }
                // GOOD: Fragment instantiated statically
                {
                    getFragmentManager().beginTransaction()
                            .replace(com.android.internal.R.id.prefs, new MyFragment()).commit();
                }
            } catch (Exception e) {
            }
        }

    }

    ```
    The next example shows two activities that extend `PreferenceActivity`. The first activity overrides `isValidFragment`, but it wrongly returns `true` unconditionally. The second activity correctly overrides `isValidFragment` so that it only returns `true` when `fragmentName` is a trusted fragment name.


    ```java
    class UnsafeActivity extends PreferenceActivity {

        @Override
        protected boolean isValidFragment(String fragmentName) {
            // BAD: any Fragment name can be provided.
            return true;
        }
    }


    class SafeActivity extends PreferenceActivity {
        @Override
        protected boolean isValidFragment(String fragmentName) {
            // Good: only trusted Fragment names are allowed.
            return SafeFragment1.class.getName().equals(fragmentName)
                    || SafeFragment2.class.getName().equals(fragmentName)
                    || SafeFragment3.class.getName().equals(fragmentName);
        }

    }


    ```

    ## References
    * Google Help: [How to fix Fragment Injection vulnerability](https://support.google.com/faqs/answer/7188427?hl=en).
    * IBM Security Systems: [Android collapses into Fragments](https://securityintelligence.com/wp-content/uploads/2013/12/android-collapses-into-fragments.pdf).
    * Android Developers: [Fragments](https://developer.android.com/guide/fragments)
    * Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-470/FragmentInjectionInPreferenceActivity.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-470/FragmentInjectionInPreferenceActivity.bqrs
  metadata:
    name: Android fragment injection in PreferenceActivity
    description: |-
      An insecure implementation of the 'isValidFragment' method
                    of the 'PreferenceActivity' class may allow a malicious application to bypass access controls,
                    exposing the application to unintended effects.
    kind: problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/android/fragment-injection-preference-activity
    tags: |-
      security
             external/cwe/cwe-470
  queryHelp: |
    # Android fragment injection in PreferenceActivity
    When fragments are instantiated with externally provided names, this exposes any exported activity that dynamically creates and hosts the fragment to fragment injection. A malicious application could provide the name of an arbitrary fragment, even one not designed to be externally accessible, and inject it into the activity. This can bypass access controls and expose the application to unintended effects.

    Fragments are reusable parts of an Android application's user interface. Even though a fragment controls its own lifecycle and layout, and handles its input events, it cannot exist on its own: it must be hosted either by an activity or another fragment. This means that, normally, a fragment will be accessible by third-party applications (that is, exported) only if its hosting activity is itself exported.


    ## Recommendation
    In general, do not instantiate classes (including fragments) with user-provided names unless the name has been properly validated. Also, if an exported activity is extending the `PreferenceActivity` class, make sure that the `isValidFragment` method is overriden and only returns `true` when the provided `fragmentName` points to an intended fragment.


    ## Example
    The following example shows two cases: in the first one, untrusted data is used to instantiate and add a fragment to an activity, while in the second one, a fragment is safely added with a static name.


    ```java
    public class MyActivity extends FragmentActivity {

        @Override
        protected void onCreate(Bundle savedInstance) {
            try {
                super.onCreate(savedInstance);
                // BAD: Fragment instantiated from user input without validation
                {
                    String fName = getIntent().getStringExtra("fragmentName");
                    getFragmentManager().beginTransaction().replace(com.android.internal.R.id.prefs,
                            Fragment.instantiate(this, fName, null)).commit();
                }
                // GOOD: Fragment instantiated statically
                {
                    getFragmentManager().beginTransaction()
                            .replace(com.android.internal.R.id.prefs, new MyFragment()).commit();
                }
            } catch (Exception e) {
            }
        }

    }

    ```
    The next example shows two activities that extend `PreferenceActivity`. The first activity overrides `isValidFragment`, but it wrongly returns `true` unconditionally. The second activity correctly overrides `isValidFragment` so that it only returns `true` when `fragmentName` is a trusted fragment name.


    ```java
    class UnsafeActivity extends PreferenceActivity {

        @Override
        protected boolean isValidFragment(String fragmentName) {
            // BAD: any Fragment name can be provided.
            return true;
        }
    }


    class SafeActivity extends PreferenceActivity {
        @Override
        protected boolean isValidFragment(String fragmentName) {
            // Good: only trusted Fragment names are allowed.
            return SafeFragment1.class.getName().equals(fragmentName)
                    || SafeFragment2.class.getName().equals(fragmentName)
                    || SafeFragment3.class.getName().equals(fragmentName);
        }

    }


    ```

    ## References
    * Google Help: [How to fix Fragment Injection vulnerability](https://support.google.com/faqs/answer/7188427?hl=en).
    * IBM Security Systems: [Android collapses into Fragments](https://securityintelligence.com/wp-content/uploads/2013/12/android-collapses-into-fragments.pdf).
    * Android Developers: [Fragments](https://developer.android.com/guide/fragments)
    * Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-489/DebuggableAttributeEnabled.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-489/DebuggableAttributeEnabled.bqrs
  metadata:
    name: Android debuggable attribute enabled
    description: An enabled debugger can allow for entry points in the application
      or reveal sensitive information.
    kind: problem
    problem.severity: warning
    security-severity: 7.2
    id: java/android/debuggable-attribute-enabled
    tags: |-
      security
             external/cwe/cwe-489
    precision: very-high
  queryHelp: |
    # Android debuggable attribute enabled
    The Android manifest file defines configuration settings for Android applications. In this file, the `android:debuggable` attribute of the `application` element can be used to define whether or not the application can be debugged. When set to `true`, this attribute will allow the application to be debugged even when running on a device in user mode.

    When a debugger is enabled, it could allow for entry points in the application or reveal sensitive information. As a result, `android:debuggable` should only be enabled during development and should be disabled in production builds.


    ## Recommendation
    In Android applications, either set the `android:debuggable` attribute to `false`, or do not include it in the manifest. The default value, when not included, is `false`.


    ## Example
    In the example below, the `android:debuggable` attribute is set to `true`.


    ```xml
    <manifest ... >
        <!-- BAD: 'android:debuggable' set to 'true' -->
        <application
            android:debuggable="true">
            <activity ... >
            </activity>
        </application>
    </manifest>

    ```
    The corrected version sets the `android:debuggable` attribute to `false`.


    ```xml
    <manifest ... >
        <!-- GOOD: 'android:debuggable' set to 'false' -->
        <application
            android:debuggable="false">
            <activity ... >
            </activity>
        </application>
    </manifest>

    ```

    ## References
    * Android Developers: [App Manifest Overview](https://developer.android.com/guide/topics/manifest/manifest-intro).
    * Android Developers: [The android:debuggable attribute](https://developer.android.com/guide/topics/manifest/application-element#debug).
    * Android Developers: [Enable debugging](https://developer.android.com/studio/debug#enable-debug).
    * Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-489/WebviewDebuggingEnabled.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-489/WebviewDebuggingEnabled.bqrs
  metadata:
    name: Android Webview debugging enabled
    description: Enabling Webview debugging in production builds can expose entry
      points or leak sensitive information.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.2
    id: java/android/webview-debugging-enabled
    tags: |-
      security
             external/cwe/cwe-489
    precision: high
  queryHelp: "# Android Webview debugging enabled\nThe `WebView.setWebContentsDebuggingEnabled`\
    \ method enables or disables the contents of any `WebView` in the application\
    \ to be debugged.\n\nYou should only enable debugging features during development.\
    \ When you create a production build, you should disable it. If you enable debugging\
    \ features, this can make your code vulnerable by adding entry points, or leaking\
    \ sensitive information.\n\n\n## Recommendation\nEnsure that debugging features\
    \ are not enabled in production builds, such as by guarding calls to `WebView.setWebContentsDebuggingEnabled(true)`\
    \ by a flag that is only enabled in debug builds.\n\n\n## Example\nIn the first\
    \ (bad) example, WebView debugging is always enabled. whereas the GOOD case only\
    \ enables it if the `android:debuggable` attribute is set to `true`.\n\n\n```java\n\
    // BAD - debugging is always enabled \nWebView.setWebContentsDebuggingEnabled(true);\n\
    \n// GOOD - debugging is only enabled when this is a debug build, as indicated\
    \ by the debuggable flag being set.\nif (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))\
    \ {\n    WebView.setWebContentsDebuggingEnabled(true);\n}\n```\n\n## References\n\
    * Android Developers: [setWebContentsDebuggingEnabled](https://developer.android.com/reference/android/webkit/WebView.html#setWebContentsDebuggingEnabled(boolean)).\n\
    * Android Developers: [Remote debugging WebViews](https://developer.chrome.com/docs/devtools/remote-debugging/webviews/).\n\
    * Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-501/TrustBoundaryViolation.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-501/TrustBoundaryViolation.bqrs
  metadata:
    id: java/trust-boundary-violation
    name: Trust boundary violation
    description: Modifying the HTTP session attributes based on data from an untrusted
      source may violate a trust boundary.
    kind: path-problem
    problem.severity: error
    security-severity: 8.8
    precision: medium
    tags: |-
      security
            external/cwe/cwe-501
  queryHelp: |
    # Trust boundary violation
    A trust boundary violation occurs when a value is passed from a less trusted context to a more trusted context.

    For example, a value that is generated by a less trusted source, such as a user, may be passed to a more trusted source, such as a system process. If the less trusted source is malicious, then the value may be crafted to exploit the more trusted source.

    Trust boundary violations are often caused by a failure to validate input. For example, if a web application accepts a cookie from a user, then the application should validate the cookie before using it. If the cookie is not validated, then the user may be able to craft a malicious cookie that exploits the application.


    ## Recommendation
    To maintain a trust boundary, validate data from less trusted sources before use.


    ## Example
    In the first (bad) example, the server accepts a parameter from the user, then uses it to set the username without validation.


    ```java
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        String username = request.getParameter("username");

        // BAD: The input is written to the session without being sanitized.
        request.getSession().setAttribute("username", username);
    }
    ```
    In the second (good) example, the server validates the parameter from the user, then uses it to set the username.


    ```java
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        String username = request.getParameter("username");

        if (validator.isValidInput("HTTP parameter", username, "username", 20, false)) {
            // GOOD: The input is sanitized before being written to the session.
            request.getSession().setAttribute("username", username);
        }
    }
    ```

    ## References
    * Wikipedia: [Trust boundary](http://en.wikipedia.org/wiki/Trust_boundary).
    * Common Weakness Enumeration: [CWE-501](https://cwe.mitre.org/data/definitions/501.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-502/UnsafeDeserialization.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-502/UnsafeDeserialization.bqrs
  metadata:
    name: Deserialization of user-controlled data
    description: |-
      Deserializing user-controlled data may allow attackers to
                    execute arbitrary code.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/unsafe-deserialization
    tags: |-
      security
             external/cwe/cwe-502
  queryHelp: |
    # Deserialization of user-controlled data
    Deserializing untrusted data using any deserialization framework that allows the construction of arbitrary serializable objects is easily exploitable and in many cases allows an attacker to execute arbitrary code. Even before a deserialized object is returned to the caller of a deserialization method a lot of code may have been executed, including static initializers, constructors, and finalizers. Automatic deserialization of fields means that an attacker may craft a nested combination of objects on which the executed initialization code may have unforeseen effects, such as the execution of arbitrary code.

    There are many different serialization frameworks. This query currently supports Kryo, XmlDecoder, XStream, SnakeYaml, JYaml, JsonIO, YAMLBeans, HessianBurlap, Castor, Burlap, Jackson, Jabsorb, Jodd JSON, Flexjson, Gson, JMS, and Java IO serialization through `ObjectInputStream`/`ObjectOutputStream`.


    ## Recommendation
    Avoid deserialization of untrusted data if at all possible. If the architecture permits it then use other formats instead of serialized objects, for example JSON or XML. However, these formats should not be deserialized into complex objects because this provides further opportunities for attack. For example, XML-based deserialization attacks are possible through libraries such as XStream and XmlDecoder.

    Alternatively, a tightly controlled whitelist can limit the vulnerability of code, but be aware of the existence of so-called Bypass Gadgets, which can circumvent such protection measures.

    Recommendations specific to particular frameworks supported by this query:

    **FastJson** - `com.alibaba:fastjson`

    * **Secure by Default**: Partially
    * **Recommendation**: Call `com.alibaba.fastjson.parser.ParserConfig#setSafeMode` with the argument `true` before deserializing untrusted data.


    **FasterXML** - `com.fasterxml.jackson.core:jackson-databind`

    * **Secure by Default**: Yes
    * **Recommendation**: Don't call `com.fasterxml.jackson.databind.ObjectMapper#enableDefaultTyping` and don't annotate any object fields with `com.fasterxml.jackson.annotation.JsonTypeInfo` passing either the `CLASS` or `MINIMAL_CLASS` values to the annotation. Read [this guide](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba).


    **Kryo** - `com.esotericsoftware:kryo` and `com.esotericsoftware:kryo5`

    * **Secure by Default**: Yes for `com.esotericsoftware:kryo5` and for `com.esotericsoftware:kryo` &gt;= v5.0.0
    * **Recommendation**: Don't call `com.esotericsoftware.kryo(5).Kryo#setRegistrationRequired` with the argument `false` on any `Kryo` instance that may deserialize untrusted data.


    **ObjectInputStream** - `Java Standard Library`

    * **Secure by Default**: No
    * **Recommendation**: Use a validating input stream, such as `org.apache.commons.io.serialization.ValidatingObjectInputStream`.


    **SnakeYAML** - `org.yaml:snakeyaml`

    * **Secure by Default**: No
    * **Recommendation**: Pass an instance of `org.yaml.snakeyaml.constructor.SafeConstructor` to `org.yaml.snakeyaml.Yaml`'s constructor before using it to deserialize untrusted data.


    **XML Decoder** - `Standard Java Library`

    * **Secure by Default**: No
    * **Recommendation**: Do not use with untrusted user input.


    **ObjectMesssage** - `Java EE/Jakarta EE`

    * **Secure by Default**: Depends on the JMS implementation.
    * **Recommendation**: Do not use with untrusted user input.



    ## Example
    The following example calls `readObject` directly on an `ObjectInputStream` that is constructed from untrusted data, and is therefore inherently unsafe.


    ```java
    public MyObject {
      public int field;
      MyObject(int field) {
        this.field = field;
      }
    }

    public MyObject deserialize(Socket sock) {
      try(ObjectInputStream in = new ObjectInputStream(sock.getInputStream())) {
        return (MyObject)in.readObject(); // unsafe
      }
    }

    ```
    Rewriting the communication protocol to only rely on reading primitive types from the input stream removes the vulnerability.


    ```java
    public MyObject deserialize(Socket sock) {
      try(DataInputStream in = new DataInputStream(sock.getInputStream())) {
        return new MyObject(in.readInt());
      }
    }

    ```

    ## References
    * OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).
    * OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).
    * Talks by Chris Frohoff &amp; Gabriel Lawrence: [ AppSecCali 2015: Marshalling Pickles - how deserializing objects will ruin your day](http://frohoff.github.io/appseccali-marshalling-pickles/), [OWASP SD: Deserialize My Shorts: Or How I Learned to Start Worrying and Hate Java Object Deserialization](http://frohoff.github.io/owaspsd-deserialize-my-shorts/).
    * Alvaro Muñoz &amp; Christian Schneider, RSAConference 2016: [Serial Killer: Silently Pwning Your Java Endpoints](https://speakerdeck.com/pwntester/serial-killer-silently-pwning-your-java-endpoints).
    * SnakeYaml documentation on deserialization: [SnakeYaml deserialization](https://bitbucket.org/snakeyaml/snakeyaml/wiki/Documentation#markdown-header-loading-yaml).
    * Hessian deserialization and related gadget chains: [Hessian deserialization](https://paper.seebug.org/1137/).
    * Castor and Hessian java deserialization vulnerabilities: [Castor and Hessian deserialization](https://securitylab.github.com/research/hessian-java-deserialization-castor-vulnerabilities/).
    * Remote code execution in JYaml library: [JYaml deserialization](https://www.cybersecurity-help.cz/vdb/SB2020022512).
    * JsonIO deserialization vulnerabilities: [JsonIO deserialization](https://klezvirus.github.io/Advanced-Web-Hacking/Serialisation/).
    * Research by Moritz Bechler: [Java Unmarshaller Security - Turning your data into code execution](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
    * Blog posts by the developer of Jackson libraries: [On Jackson CVEs: Don’t Panic — Here is what you need to know](https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062) [Jackson 2.10: Safe Default Typing](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba)
    * Jabsorb documentation on deserialization: [Jabsorb JSON Serializer](https://github.com/Servoy/jabsorb/blob/master/src/org/jabsorb/).
    * Jodd JSON documentation on deserialization: [JoddJson Parser](https://json.jodd.org/parser).
    * RCE in Flexjson: [Flexjson deserialization](https://codewhitesec.blogspot.com/2020/03/liferay-portal-json-vulns.html).
    * Android Intent deserialization vulnerabilities with GSON parser: [Insecure use of JSON parsers](https://blog.oversecured.com/Exploiting-memory-corruption-vulnerabilities-on-Android/#insecure-use-of-json-parsers).
    * Research by Matthias Kaiser: [Pwning Your Java Messaging With Deserialization Vulnerabilities](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf).
    * Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-522/InsecureBasicAuth.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-522/InsecureBasicAuth.bqrs
  metadata:
    name: Insecure basic authentication
    description: |-
      Basic authentication only obfuscates username/password in
                    Base64 encoding, which can be easily recognized and reversed.
                    Transmitting sensitive information without using HTTPS makes
                    the data vulnerable to packet sniffing.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.8
    precision: medium
    id: java/insecure-basic-auth
    tags: |-
      security
             external/cwe/cwe-522
             external/cwe/cwe-319
  queryHelp: |
    # Insecure basic authentication
    Basic authentication only obfuscates usernames and passwords in Base64 encoding, which can be easily recognized and reversed, thus it must not be transmitted over the cleartext HTTP channel. Transmitting sensitive information without using HTTPS makes the data vulnerable to packet sniffing.


    ## Recommendation
    Either use a more secure authentication mechanism like digest authentication or federated authentication, or use the HTTPS communication protocol.


    ## Example
    The following example shows two ways of using basic authentication. In the 'BAD' case, the credentials are transmitted over HTTP. In the 'GOOD' case, the credentials are transmitted over HTTPS.


    ```java
    public class InsecureBasicAuth {
      /**
       * Test basic authentication with Apache HTTP request.
       */
      public void testApacheHttpRequest(String username, String password) {

        // BAD: basic authentication over HTTP
        String url = "http://www.example.com/rest/getuser.do?uid=abcdx";

        // GOOD: basic authentication over HTTPS
        url = "https://www.example.com/rest/getuser.do?uid=abcdx";

        HttpPost post = new HttpPost(url);
        post.setHeader("Accept", "application/json");
        post.setHeader("Content-type", "application/json");

        String authString = username + ":" + password;
        byte[] authEncBytes = Base64.getEncoder().encode(authString.getBytes());
        String authStringEnc = new String(authEncBytes);

        post.addHeader("Authorization", "Basic " + authStringEnc);
      }

      /**
       * Test basic authentication with Java HTTP URL connection.
       */
      public void testHttpUrlConnection(String username, String password) {

        // BAD: basic authentication over HTTP
        String urlStr = "http://www.example.com/rest/getuser.do?uid=abcdx";

        // GOOD: basic authentication over HTTPS
        urlStr = "https://www.example.com/rest/getuser.do?uid=abcdx";

        String authString = username + ":" + password;
        String encoding = Base64.getEncoder().encodeToString(authString.getBytes("UTF-8"));
        URL url = new URL(urlStr);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod("POST");
        conn.setDoOutput(true);
        conn.setRequestProperty("Authorization", "Basic " + encoding);
      }
    }

    ```

    ## References
    * SonarSource rule: [Basic authentication should not be used](https://rules.sonarsource.com/java/tag/owasp/RSPEC-2647).
    * Acunetix: [WEB VULNERABILITIES INDEX - Basic authentication over HTTP](https://www.acunetix.com/vulnerabilities/web/basic-authentication-over-http/).
    * Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).
    * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-522/InsecureLdapAuth.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-522/InsecureLdapAuth.bqrs
  metadata:
    name: Insecure LDAP authentication
    description: LDAP authentication with credentials sent in cleartext makes sensitive
      information vulnerable to remote attackers
    kind: path-problem
    problem.severity: error
    security-severity: 8.8
    precision: high
    id: java/insecure-ldap-auth
    tags: |-
      security
             external/cwe/cwe-522
             external/cwe/cwe-319
  queryHelp: |
    # Insecure LDAP authentication
    When using the Java LDAP API to perform LDAPv3-style extended operations and controls, a context with connection properties including user credentials is started. Transmission of LDAP credentials in cleartext allows remote attackers to obtain sensitive information by sniffing the network.


    ## Recommendation
    Use the `ldaps://` protocol to send credentials through SSL or use SASL authentication.


    ## Example
    In the following (bad) example, a `ldap://` URL is used and credentials will be sent in plaintext.


    ```java
    String ldapUrl = "ldap://ad.your-server.com:389";
    Hashtable<String, String> environment = new Hashtable<String, String>();
    environment.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    environment.put(Context.PROVIDER_URL, ldapUrl);
    environment.put(Context.REFERRAL, "follow");
    environment.put(Context.SECURITY_AUTHENTICATION, "simple");
    environment.put(Context.SECURITY_PRINCIPAL, ldapUserName);
    environment.put(Context.SECURITY_CREDENTIALS, password);
    DirContext dirContext = new InitialDirContext(environment);

    ```
    In the following (good) example, a `ldaps://` URL is used so credentials will be encrypted with SSL.


    ```java
    String ldapUrl = "ldaps://ad.your-server.com:636";
    Hashtable<String, String> environment = new Hashtable<String, String>();
    environment.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    environment.put(Context.PROVIDER_URL, ldapUrl);
    environment.put(Context.REFERRAL, "follow");
    environment.put(Context.SECURITY_AUTHENTICATION, "simple");
    environment.put(Context.SECURITY_PRINCIPAL, ldapUserName);
    environment.put(Context.SECURITY_CREDENTIALS, password);
    DirContext dirContext = new InitialDirContext(environment);

    ```
    In the following (good) example, a `ldap://` URL is used, but SASL authentication is enabled so that the credentials will be encrypted.


    ```java
    String ldapUrl = "ldap://ad.your-server.com:389";
    Hashtable<String, String> environment = new Hashtable<String, String>();
    environment.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    environment.put(Context.PROVIDER_URL, ldapUrl);
    environment.put(Context.REFERRAL, "follow");
    environment.put(Context.SECURITY_AUTHENTICATION, "DIGEST-MD5 GSSAPI");
    environment.put(Context.SECURITY_PRINCIPAL, ldapUserName);
    environment.put(Context.SECURITY_CREDENTIALS, password);
    DirContext dirContext = new InitialDirContext(environment);

    ```

    ## References
    * Oracle: [LDAP and LDAPS URLs](https://docs.oracle.com/javase/jndi/tutorial/ldap/misc/url.html)
    * Oracle: [Simple authentication](https://docs.oracle.com/javase/tutorial/jndi/ldap/simple.html)
    * Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).
    * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-524/SensitiveKeyboardCache.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-524/SensitiveKeyboardCache.bqrs
  metadata:
    name: Android sensitive keyboard cache
    description: Allowing the keyboard to cache sensitive information may result in
      information leaks to other applications.
    kind: problem
    problem.severity: warning
    security-severity: 8.1
    id: java/android/sensitive-keyboard-cache
    tags: |-
      security
             external/cwe/cwe-524
    precision: medium
  queryHelp: "# Android sensitive keyboard cache\nWhen a user enters information in\
    \ a text input field on an Android application, their input is saved to a keyboard\
    \ cache which provides autocomplete suggestions and predictions. There is a risk\
    \ that sensitive user data, such as passwords or banking information, may be leaked\
    \ to other applications via the keyboard cache.\n\n\n## Recommendation\nFor input\
    \ fields expected to accept sensitive information, use input types such as `\"\
    textNoSuggestions\"` (or `\"textPassword\"` for a password) to ensure the input\
    \ does not get stored in the keyboard cache.\n\nOptionally, instead of declaring\
    \ an input type through XML, you can set the input type in your code using `TextView.setInputType()`.\n\
    \n\n## Example\nIn the following example, the field labeled BAD allows the password\
    \ to be saved to the keyboard cache, whereas the field labeled GOOD uses the `\"\
    textPassword\"` input type to ensure the password is not cached.\n\n\n```xml\n\
    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"\
    http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\
    >\n\n    <!-- BAD: This password field uses the `text` input type, which allows\
    \ the input to be saved to the keyboard cache. -->\n    <EditText\n        android:id=\"\
    @+id/password_bad\"\n        android:inputType=\"text\"/> \n\n    <!-- GOOD: This\
    \ password field uses the `textPassword` input type, which ensures that the input\
    \ is not saved to the keyboard cache. -->\n    <EditText\n        android:id=\"\
    @+id/password_good\"\n        android:inputType=\"textPassword\"/>  \n</LinearLayout>\n\
    ```\n\n## References\n* OWASP Mobile Application Security Testing Guide: [Determining\
    \ Whether the Keyboard Cache Is Disabled for Text Input Fields](https://github.com/OWASP/owasp-mastg/blob/b7a93a2e5e0557cc9a12e55fc3f6675f6986bb86/Document/0x05d-Testing-Data-Storage.md#determining-whether-the-keyboard-cache-is-disabled-for-text-input-fields-mstg-storage-5).\n\
    * Android Developers: [android:inputType attribute documentation.](https://developer.android.com/reference/android/widget/TextView#attr_android:inputType)\n\
    * Common Weakness Enumeration: [CWE-524](https://cwe.mitre.org/data/definitions/524.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-532/SensitiveInfoLog.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-532/SensitiveInfoLog.bqrs
  metadata:
    name: Insertion of sensitive information into log files
    description: |-
      Writing sensitive information to log files can allow that
                    information to be leaked to an attacker more easily.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/sensitive-log
    tags: |-
      security
             external/cwe/cwe-532
  queryHelp: "# Insertion of sensitive information into log files\nInformation written\
    \ to log files can be of a sensitive nature and give valuable guidance to an attacker\
    \ or expose sensitive user information. Third-party logging utilities like Log4J\
    \ and SLF4J are widely used in Java projects. When sensitive information is written\
    \ to logs without properly set logging levels, it is accessible to potential attackers\
    \ who can use it to gain access to file storage.\n\n\n## Recommendation\nDo not\
    \ write secrets into the log files and enforce proper logging level control.\n\
    \n\n## Example\nThe following example shows two ways of logging sensitive information.\
    \ In the 'BAD' case, the credentials are simply written to a debug log. In the\
    \ 'GOOD' case, the credentials are never written to debug logs.\n\n\n```java\n\
    public static void main(String[] args) {\n    {\n        private static final\
    \ Logger logger = LogManager.getLogger(SensitiveInfoLog.class);\n\n        String\
    \ password = \"Pass@0rd\";\n\n        // BAD: user password is written to debug\
    \ log\n        logger.debug(\"User password is \"+password);\n    }\n\t\n    {\n\
    \        private static final Logger logger = LogManager.getLogger(SensitiveInfoLog.class);\n\
    \  \n        String password = \"Pass@0rd\";\n\n        // GOOD: user password\
    \ is never written to debug log\n        logger.debug(\"User password changed\"\
    )\n    }\n}\n\n```\n\n## References\n* [OWASP Logging Guide](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n\
    * Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-552/UrlForward.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-552/UrlForward.bqrs
  metadata:
    name: URL forward from a remote source
    description: |-
      URL forward based on unvalidated user input
                    may cause file information disclosure.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/unvalidated-url-forward
    tags: |-
      security
             external/cwe/cwe-552
  queryHelp: "# URL forward from a remote source\nDirectly incorporating user input\
    \ into a URL forward request without validating the input can cause file information\
    \ disclosure by allowing an attacker to access unauthorized URLs.\n\n\n## Recommendation\n\
    To guard against untrusted URL forwarding, you should avoid putting user input\
    \ directly into a forwarded URL. Instead, you should maintain a list of authorized\
    \ URLs on the server, then choose from that list based on the user input provided.\n\
    \n\n## Example\nThe following example shows an HTTP request parameter being used\
    \ directly in a URL forward without validating the input, which may cause file\
    \ information disclosure. It also shows how to remedy the problem by validating\
    \ the user input against a known fixed string.\n\n\n```java\npublic class UrlForward\
    \ extends HttpServlet {\n\tprivate static final String VALID_FORWARD = \"https://cwe.mitre.org/data/definitions/552.html\"\
    ;\n\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\
    \t\t\tthrows ServletException, IOException {\n\t\tServletConfig cfg = getServletConfig();\n\
    \t\tServletContext sc = cfg.getServletContext();\n\n\t\t// BAD: a request parameter\
    \ is incorporated without validation into a URL forward\n\t\tsc.getRequestDispatcher(request.getParameter(\"\
    target\")).forward(request, response);\n\n\t\t// GOOD: the request parameter is\
    \ validated against a known fixed string\n\t\tif (VALID_FORWARD.equals(request.getParameter(\"\
    target\"))) {\n\t\t\tsc.getRequestDispatcher(VALID_FORWARD).forward(request, response);\n\
    \t\t}\n\t}\n}\n\n```\n\n## References\n* OWASP: [Unvalidated Redirects and Forwards\
    \ Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n\
    * Common Weakness Enumeration: [CWE-552](https://cwe.mitre.org/data/definitions/552.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-601/UrlRedirect.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-601/UrlRedirect.bqrs
  metadata:
    name: URL redirection from remote source
    description: |-
      URL redirection based on unvalidated user-input
                    may cause redirection to malicious web sites.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: java/unvalidated-url-redirection
    tags: |-
      security
             external/cwe/cwe-601
  queryHelp: |
    # URL redirection from remote source
    Directly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.


    ## Recommendation
    To guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.

    If this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.


    ## Example
    The following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:


    ```java
    public class UrlRedirect extends HttpServlet {
      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // BAD: a request parameter is incorporated without validation into a URL redirect
        response.sendRedirect(request.getParameter("target"));
      }
    }
    ```
    One way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:


    ```java
    public class UrlRedirect extends HttpServlet {
      private static final List<String> VALID_REDIRECTS = Arrays.asList(
        "http://cwe.mitre.org/data/definitions/601.html",
        "http://cwe.mitre.org/data/definitions/79.html"
      );

      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // GOOD: the request parameter is validated against a known list of strings
        String target = request.getParameter("target");
        if (VALID_REDIRECTS.contains(target)) {
            response.sendRedirect(target);
        } else {
            response.sendRedirect("/error.html");
        }
      }
    }
    ```
    Alternatively, we can check that the target URL does not redirect to a different host by checking that the URL is either relative or on a known good host:


    ```java
    public class UrlRedirect extends HttpServlet {
      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        try {
          String urlString = request.getParameter("page");
          URI url = new URI(urlString);

          if (!url.isAbsolute()) {
            response.sendRedirect(url.toString()); // GOOD: The redirect is to a relative URL
          }

          if ("example.org".equals(url.getHost())) {
            response.sendRedirect(url.toString()); // GOOD: The redirect is to a known host
          }
        } catch (URISyntaxException e) {
            // handle exception
        }
      }
    }
    ```
    Note that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.


    ## References
    * OWASP: [ Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Microsoft Docs: [Preventing Open Redirection Attacks (C\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).
    * Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-611/XXE.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-611/XXE.bqrs
  metadata:
    name: Resolving XML external entity in user-controlled data
    description: |-
      Parsing user-controlled XML documents and allowing expansion of external entity
       references may lead to disclosure of confidential data or denial of service.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: high
    id: java/xxe
    tags: |-
      security
             external/cwe/cwe-611
             external/cwe/cwe-776
             external/cwe/cwe-827
  queryHelp: |
    # Resolving XML external entity in user-controlled data
    Parsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial of service, or server side request forgery. Even when the result of parsing is not returned to the user, out-of-band data retrieval techniques may allow attackers to steal sensitive data. Denial of services can also be carried out in this situation.

    There are many XML parsers for Java, and most of them are vulnerable to XXE because their default settings enable parsing of external entities. This query currently identifies vulnerable XML parsing from the following parsers: `javax.xml.parsers.DocumentBuilder`, `javax.xml.stream.XMLStreamReader`, `org.jdom.input.SAXBuilder`/`org.jdom2.input.SAXBuilder`, `javax.xml.parsers.SAXParser`,`org.dom4j.io.SAXReader`, `org.xml.sax.XMLReader`, `javax.xml.transform.sax.SAXSource`, `javax.xml.transform.TransformerFactory`, `javax.xml.transform.sax.SAXTransformerFactory`, `javax.xml.validation.SchemaFactory`, `javax.xml.bind.Unmarshaller` and `javax.xml.xpath.XPathExpression`.


    ## Recommendation
    The best way to prevent XXE attacks is to disable the parsing of any Document Type Declarations (DTDs) in untrusted data. If this is not possible you should disable the parsing of external general entities and external parameter entities. This improves security but the code will still be at risk of denial of service and server side request forgery attacks. Protection against denial of service attacks may also be implemented by setting entity expansion limits, which is done by default in recent JDK and JRE implementations. Because there are many different ways to disable external entity retrieval with varying support between different providers, in this query we choose to specifically check for the [OWASP recommended way](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java) to disable external entity retrieval for a particular parser. There may be other ways of making a particular parser safe which deviate from these guidelines, in which case this query will continue to flag the parser as potentially dangerous.


    ## Example
    The following example calls `parse` on a `DocumentBuilder` that is not safely configured on untrusted data, and is therefore inherently unsafe.


    ```java
    public void parse(Socket sock) throws Exception {
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      DocumentBuilder builder = factory.newDocumentBuilder();
      builder.parse(sock.getInputStream()); //unsafe
    }

    ```
    In this example, the `DocumentBuilder` is created with DTD disabled, securing it against XXE attack.


    ```java
    public void disableDTDParse(Socket sock) throws Exception {
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
      DocumentBuilder builder = factory.newDocumentBuilder();
      builder.parse(sock.getInputStream()); //safe
    }

    ```

    ## References
    * OWASP vulnerability description: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).
    * OWASP guidance on parsing xml files: [XXE Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java).
    * Paper by Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/)
    * Out-of-band data retrieval: Timur Yunusov &amp; Alexey Osipov, Black hat EU 2013: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).
    * Denial of service attack (Billion laughs): [Billion Laughs.](https://en.wikipedia.org/wiki/Billion_laughs)
    * The Java Tutorials: [Processing Limit Definitions.](https://docs.oracle.com/javase/tutorial/jaxp/limits/limits.html)
    * Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).
    * Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).
    * Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-614/InsecureCookie.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-614/InsecureCookie.bqrs
  metadata:
    name: Failure to use secure cookies
    description: |-
      Insecure cookies may be sent in cleartext, which makes them vulnerable to
                    interception.
    kind: problem
    problem.severity: error
    security-severity: 5.0
    precision: high
    id: java/insecure-cookie
    tags: |-
      security
             external/cwe/cwe-614
  queryHelp: "# Failure to use secure cookies\nFailing to set the 'secure' flag on\
    \ a cookie can cause it to be sent in cleartext. This makes it easier for an attacker\
    \ to intercept.\n\n\n## Recommendation\nAlways use `setSecure` to set the 'secure'\
    \ flag on a cookie before adding it to an `HttpServletResponse`.\n\n\n## Example\n\
    This example shows two ways of adding a cookie to an `HttpServletResponse`. The\
    \ first way leaves out the setting of the 'secure' flag; the second way includes\
    \ the setting of the flag.\n\n\n```java\npublic static void test(HttpServletRequest\
    \ request, HttpServletResponse response) {\n\t{\n\t\tCookie cookie = new Cookie(\"\
    secret\", \"fakesecret\");\n\t\t\n\t\t// BAD: 'secure' flag not set\n\t\tresponse.addCookie(cookie);\n\
    \t}\n\n\t{\n\t\tCookie cookie = new Cookie(\"secret\", \"fakesecret\");\n\t\t\n\
    \t\t// GOOD: set 'secure' flag\n\t\tcookie.setSecure(true);\n\t\tresponse.addCookie(cookie);\n\
    \t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J.\
    \ Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n\
    * Java Platform, Enterprise Edition (Java EE) 7, API Specification: [Class Cookie](https://docs.oracle.com/javaee/7/api/javax/servlet/http/Cookie.html).\n\
    * Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-643/XPathInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-643/XPathInjection.bqrs
  metadata:
    name: XPath injection
    description: |-
      Building an XPath expression from user-controlled sources is vulnerable to insertion of
                    malicious code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/xml/xpath-injection
    tags: |-
      security
             external/cwe/cwe-643
  queryHelp: "# XPath injection\nIf an XPath expression is built using string concatenation,\
    \ and the components of the concatenation include user input, it makes it very\
    \ easy for a user to create a malicious XPath expression.\n\n\n## Recommendation\n\
    If user input must be included in an XPath expression, either sanitize the data\
    \ or pre-compile the query and use variable references to include the user input.\n\
    \nXPath injection can also be prevented by using XQuery.\n\n\n## Example\nIn the\
    \ first three examples, the code accepts a name and password specified by the\
    \ user, and uses this unvalidated and unsanitized value in an XPath expression.\
    \ This is vulnerable to the user providing special characters or string sequences\
    \ that change the meaning of the XPath expression to search for different values.\n\
    \nIn the fourth example, the code uses `setXPathVariableResolver` which prevents\
    \ XPath injection.\n\nThe final two examples are for dom4j. They show an example\
    \ of XPath injection and one method of preventing it.\n\n\n```java\nfinal String\
    \ xmlStr = \"<users>\" + \n                        \"   <user name=\\\"aaa\\\"\
    \ pass=\\\"pass1\\\"></user>\" + \n                        \"   <user name=\\\"\
    bbb\\\" pass=\\\"pass2\\\"></user>\" + \n                        \"</users>\"\
    ;\ntry {\n    DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\n\
    \    domFactory.setNamespaceAware(true);\n    DocumentBuilder builder = domFactory.newDocumentBuilder();\n\
    \    //Document doc = builder.parse(\"user.xml\");\n    Document doc = builder.parse(new\
    \ InputSource(new StringReader(xmlStr)));\n\n    XPathFactory factory = XPathFactory.newInstance();\n\
    \    XPath xpath = factory.newXPath();\n\n    // Injectable data\n    String user\
    \ = request.getParameter(\"user\");\n    String pass = request.getParameter(\"\
    pass\");\n    if (user != null && pass != null) {\n        boolean isExist = false;\n\
    \n        // Bad expression\n        String expression1 = \"/users/user[@name='\"\
    \ + user + \"' and @pass='\" + pass + \"']\";\n        isExist = (boolean)xpath.evaluate(expression1,\
    \ doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n    \
    \    // Bad expression\n        XPathExpression expression2 = xpath.compile(\"\
    /users/user[@name='\" + user + \"' and @pass='\" + pass + \"']\");\n        isExist\
    \ = (boolean)expression2.evaluate(doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\
    \n        // Bad expression\n        StringBuffer sb = new StringBuffer(\"/users/user[@name=\"\
    );\n        sb.append(user);\n        sb.append(\"' and @pass='\");\n        sb.append(pass);\n\
    \        sb.append(\"']\");\n        String query = sb.toString();\n        XPathExpression\
    \ expression3 = xpath.compile(query);\n        isExist = (boolean)expression3.evaluate(doc,\
    \ XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n        //\
    \ Good expression\n        String expression4 = \"/users/user[@name=$user and\
    \ @pass=$pass]\";\n        xpath.setXPathVariableResolver(v -> {\n        switch\
    \ (v.getLocalPart()) {\n            case \"user\":\n                return user;\n\
    \            case \"pass\":\n                return pass;\n            default:\n\
    \                throw new IllegalArgumentException();\n            }\n      \
    \  });\n        isExist = (boolean)xpath.evaluate(expression4, doc, XPathConstants.BOOLEAN);\n\
    \        System.out.println(isExist);\n\n\n        // Bad Dom4j \n        org.dom4j.io.SAXReader\
    \ reader = new org.dom4j.io.SAXReader();\n        org.dom4j.Document document\
    \ = reader.read(new InputSource(new StringReader(xmlStr)));\n        isExist =\
    \ document.selectSingleNode(\"/users/user[@name='\" + user + \"' and @pass='\"\
    \ + pass + \"']\") != null;\n        // or document.selectNodes\n        System.out.println(isExist);\n\
    \n        // Good Dom4j\n        org.jaxen.SimpleVariableContext svc = new org.jaxen.SimpleVariableContext();\n\
    \        svc.setVariableValue(\"user\", user);\n        svc.setVariableValue(\"\
    pass\", pass);\n        String xpathString = \"/users/user[@name=$user and @pass=$pass]\"\
    ;\n        org.dom4j.XPath safeXPath = document.createXPath(xpathString);\n  \
    \      safeXPath.setVariableContext(svc);\n        isExist = safeXPath.selectSingleNode(document)\
    \ != null;\n        System.out.println(isExist);\n    }\n} catch (ParserConfigurationException\
    \ e) {\n\n} catch (SAXException e) {\n\n} catch (XPathExpressionException e) {\n\
    \n} catch (org.dom4j.DocumentException e) {\n\n}\n```\n\n## References\n* OWASP:\
    \ [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n\
    * OWASP: [XPath Injection](https://owasp.org/www-community/attacks/XPATH_Injection).\n\
    * Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-676/PotentiallyDangerousFunction.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-676/PotentiallyDangerousFunction.bqrs
  metadata:
    name: Use of a potentially dangerous function
    description: Certain standard library routines are dangerous to call.
    kind: problem
    problem.severity: warning
    security-severity: 10.0
    precision: medium
    id: java/potentially-dangerous-function
    tags: |-
      reliability
             security
             external/cwe/cwe-676
  queryHelp: |
    # Use of a potentially dangerous function
    This rule finds calls to methods that are dangerous to use. Currently, it checks for calls to `Thread.stop`.

    Stopping a thread with `Thread.stop` causes it to receive a `ThreadDeath` exception. That exception propagates up the stack, releasing all monitors that the thread was holding. In some cases the relevant code will be protected by catching the `ThreadDeath` exception and cleaning up, but because the exception can potentially be thrown from so very many locations, it is impractical to catch all such cases. As a result, calling `Thread.stop` is likely to result in corrupt data.


    ## Recommendation
    The best solution is usually to provide an alternate communication mechanism for the thread that might need to be interrupted early. For example, Oracle gives the following example of using a volatile variable to communicate whether the worker thread should exit:


    ```java
    private volatile Thread blinker;

    public void stop() {
        blinker = null;
    }

    public void run() {
        Thread thisThread = Thread.currentThread();
        while (blinker == thisThread) {
            try {
                Thread.sleep(interval);
            } catch (InterruptedException e){
            }
            repaint();
        }
    }

    ```
    It is also possible to use `Thread.interrupt` and to catch and handle `InterruptedException` when it occurs. However, it can be difficult to handle an `InterruptedException` everywhere it might occur; for example, the sample code above simply discards the exception rather than actually exiting the thread.

    Another strategy is to use message passing, for example via a `BlockingQueue`. In addition to passing the worker thread its ordinary work via such a message queue, the worker can be asked to exit by a particular kind of message being sent on the queue.


    ## References
    * SEI CERT Oracle Coding Standard for Java: [THI05-J. Do not use Thread.stop() to terminate threads](https://wiki.sei.cmu.edu/confluence/display/java/THI05-J.+Do+not+use+Thread.stop()+to+terminate+threads).
    * Java API Specification: [Java Thread Primitive Deprecation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html).
    * Java API Specification: [Thread.interrupt](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#interrupt()), [BlockingQueue](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/BlockingQueue.html).
    * Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-681/NumericCastTainted.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-681/NumericCastTainted.bqrs
  metadata:
    name: User-controlled data in numeric cast
    description: |-
      Casting user-controlled numeric data to a narrower type without validation
                    can cause unexpected truncation.
    kind: path-problem
    problem.severity: error
    security-severity: 9.0
    precision: high
    id: java/tainted-numeric-cast
    tags: |-
      security
             external/cwe/cwe-197
             external/cwe/cwe-681
  queryHelp: "# User-controlled data in numeric cast\nCasting a user-controlled numeric\
    \ value to a narrower type can result in truncated values unless the input is\
    \ validated.\n\nNarrowing conversions may cause potentially unintended results.\
    \ For example, casting the positive integer value `128` to type `byte` yields\
    \ the negative value `-128`.\n\n\n## Recommendation\nGuard against unexpected\
    \ truncation of user-controlled arithmetic data by doing one of the following:\n\
    \n* Validate the user input.\n* Define a guard on the cast expression, so that\
    \ the cast is performed only if the input is known to be within the range of the\
    \ resulting type.\n* Avoid casting to a narrower type, and instead continue to\
    \ use a wider type.\n\n## Example\nIn this example, a value is read from standard\
    \ input into a `long`. Because the value is a user-controlled value, it could\
    \ be extremely large. Casting this value to a narrower type could therefore cause\
    \ unexpected truncation. The `scaled2` example uses a guard to avoid this problem\
    \ and checks the range of the input before performing the cast. If the value is\
    \ too large to cast to type `int` it is rejected as invalid.\n\n\n```java\nclass\
    \ Test {\n\tpublic static void main(String[] args) throws IOException {\n\t\t\
    {\n\t\t\tlong data;\n\n\t\t\tBufferedReader readerBuffered = new BufferedReader(\n\
    \t\t\t\t\tnew InputStreamReader(System.in, \"UTF-8\"));\n\t\t\tString stringNumber\
    \ = readerBuffered.readLine();\n\t\t\tif (stringNumber != null) {\n\t\t\t\tdata\
    \ = Long.parseLong(stringNumber.trim());\n\t\t\t} else {\n\t\t\t\tdata = 0;\n\t\
    \t\t}\n\n\t\t\t// AVOID: potential truncation if input data is very large,\n\t\
    \t\t// for example 'Long.MAX_VALUE'\n\t\t\tint scaled = (int)data;\n\n\t\t\t//...\n\
    \n\t\t\t// GOOD: use a guard to ensure no truncation occurs\n\t\t\tint scaled2;\n\
    \t\t\tif (data > Integer.MIN_VALUE && data < Integer.MAX_VALUE)\n\t\t\t\tscaled2\
    \ = (int)data;\n\t\t\telse\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid\
    \ input\");\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard\
    \ for Java: [NUM12-J. Ensure conversions of numeric types to narrower types do\
    \ not result in lost or misinterpreted data](https://wiki.sei.cmu.edu/confluence/display/java/NUM12-J.+Ensure+conversions+of+numeric+types+to+narrower+types+do+not+result+in+lost+or+misinterpreted+data).\n\
    * Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n\
    * Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-730/PolynomialReDoS.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-730/PolynomialReDoS.bqrs
  metadata:
    name: Polynomial regular expression used on uncontrolled data
    description: |-
      A regular expression that can require polynomial time
                    to match may be vulnerable to denial-of-service attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: java/polynomial-redos
    tags: |-
      security
             external/cwe/cwe-1333
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: "# Polynomial regular expression used on uncontrolled data\nSome regular\
    \ expressions take a long time to match certain input strings to the point where\
    \ the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>*\
    \ or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance,\
    \ or even allow a malicious user to perform a Denial of Service (\"DoS\") attack\
    \ by crafting an expensive input string for the regular expression to match.\n\
    \nThe regular expression engine provided by Java uses a backtracking non-deterministic\
    \ finite automata to implement regular expression matching. While this approach\
    \ is space-efficient and allows supporting advanced features like capture groups,\
    \ it is not time-efficient in general. The worst-case time complexity of such\
    \ an automaton can be polynomial or even exponential, meaning that for strings\
    \ of a certain shape, increasing the input length by ten characters may make the\
    \ automaton about 1000 times slower.\n\nTypically, a regular expression is affected\
    \ by this problem if it contains a repetition of the form `r*` or `r+` where the\
    \ sub-expression `r` is ambiguous in the sense that it can match some string in\
    \ multiple ways. More information about the precise circumstances can be found\
    \ in the references.\n\nNote that Java versions 9 and above have some mitigations\
    \ against ReDoS; however they aren't perfect and more complex regular expressions\
    \ can still be affected by this problem.\n\n\n## Recommendation\nModify the regular\
    \ expression to remove the ambiguity, or ensure that the strings matched with\
    \ the regular expression are short enough that the time-complexity does not matter.\
    \ Alternatively, an alternate regex library that guarantees linear time execution,\
    \ such as Google's RE2J, may be used.\n\n\n## Example\nConsider this use of a\
    \ regular expression, which removes all leading and trailing whitespace in a string:\n\
    \n```java\n\nPattern.compile(\"^\\\\s+|\\\\s+$\").matcher(text).replaceAll(\"\"\
    ) // BAD\n```\nThe sub-expression `\"\\\\s+$\"` will match the whitespace characters\
    \ in `text` from left to right, but it can start matching anywhere within a whitespace\
    \ sequence. This is problematic for strings that do **not** end with a whitespace\
    \ character. Such a string will force the regular expression engine to process\
    \ each whitespace sequence once per whitespace character in the sequence.\n\n\
    This ultimately means that the time cost of trimming a string is quadratic in\
    \ the length of the string. So a string like `\"a b\"` will take milliseconds\
    \ to process, but a similar string with a million spaces instead of just one will\
    \ take several minutes.\n\nAvoid this problem by rewriting the regular expression\
    \ to not contain the ambiguity about when to start matching whitespace sequences.\
    \ For instance, by using a negative look-behind (`\"^\\\\s+|(?<!\\\\s)\\\\s+$\"\
    `), or just by using the built-in trim method (`text.trim()`).\n\nNote that the\
    \ sub-expression `\"^\\\\s+\"` is **not** problematic as the `^` anchor restricts\
    \ when that sub-expression can start matching, and as the regular expression engine\
    \ matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler\
    \ problem, consider the regular expression that matches lines with numbers, possibly\
    \ written using scientific notation:\n\n```java\n\n\"^0\\\\.\\\\d+E?\\\\d+$\"\"\
    \ \n```\nThe problem with this regular expression is in the sub-expression `\\\
    d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the\
    \ first match of the first `\\d+` if there is no `E` in the input string.\n\n\
    This is problematic for strings that do **not** end with a digit. Such a string\
    \ will force the regular expression engine to process each digit sequence once\
    \ per digit in the sequence, again leading to a quadratic time complexity.\n\n\
    To make the processing faster, the regular expression should be rewritten such\
    \ that the two `\\d+` sub-expressions do not have overlapping matches: `\"^0\\\
    \\.\\\\d+(E\\\\d+)?$\"`.\n\n\n## Example\nSometimes it is unclear how a regular\
    \ expression can be rewritten to avoid the problem. In such cases, it often suffices\
    \ to limit the length of the input string. For instance, the following regular\
    \ expression is used to match numbers, and on some non-number inputs it can have\
    \ quadratic time complexity:\n\n```java\n\nPattern.matches(\"^(\\\\+|-)?(\\\\\
    d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\nIt is not immediately\
    \ obvious how to rewrite this regular expression to avoid the problem. However,\
    \ you can mitigate performance issues by limiting the length to 1000 characters,\
    \ which will always finish in a reasonable amount of time.\n\n```java\n\nif (str.length()\
    \ > 1000) {\n    throw new IllegalArgumentException(\"Input too long\");\n}\n\n\
    Pattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\"\
    , str); \n```\n\n## References\n* OWASP: [Regular expression Denial of Service\
    \ - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n\
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time\
    \ complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage,\
    \ Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service\
    \ Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n\
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n\
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-730/ReDoS.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-730/ReDoS.bqrs
  metadata:
    name: Inefficient regular expression
    description: |-
      A regular expression that requires exponential time to match certain inputs
                    can be a performance bottleneck, and may be vulnerable to denial-of-service
                    attacks.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/redos
    tags: |-
      security
             external/cwe/cwe-1333
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Inefficient regular expression
    Some regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service ("DoS") attack by crafting an expensive input string for the regular expression to match.

    The regular expression engine provided by Java uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.

    Typically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.

    Note that Java versions 9 and above have some mitigations against ReDoS; however they aren't perfect and more complex regular expressions can still be affected by this problem.


    ## Recommendation
    Modify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter. Alternatively, an alternate regex library that guarantees linear time execution, such as Google's RE2J, may be used.


    ## Example
    Consider this regular expression:

    ```java

    ^_(__|.)+_$
    ```
    Its sub-expression `"(__|.)+?"` can match the string `"__"` either by the first alternative `"__"` to the left of the `"|"` operator, or by two repetitions of the second alternative `"."` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.

    This problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:

    ```java

    ^_(__|[^_])+_$
    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).
    * James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).
    * Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-730/RegexInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-730/RegexInjection.bqrs
  metadata:
    name: Regular expression injection
    description: |-
      User input should not be used in regular expressions without first being escaped,
                    otherwise a malicious user may be able to provide a regex that could require
                    exponential time on certain inputs.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/regex-injection
    tags: |-
      security
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Regular expression injection
    Constructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.


    ## Recommendation
    Before embedding user input into a regular expression, use a sanitization function such as `Pattern.quote` to escape meta-characters that have special meaning.


    ## Example
    The following example shows an HTTP request parameter that is used to construct a regular expression.

    In the first case the user-provided regex is not escaped. If a malicious user provides a regex whose worst-case performance is exponential, then this could lead to a Denial of Service.

    In the second case, the user input is escaped using `Pattern.quote` before being included in the regular expression. This ensures that the user cannot insert characters which have a special meaning in regular expressions.


    ```java
    import java.util.regex.Pattern;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;

    public class RegexInjectionDemo extends HttpServlet {

      public boolean badExample(javax.servlet.http.HttpServletRequest request) {
        String regex = request.getParameter("regex");
        String input = request.getParameter("input");

        // BAD: Unsanitized user input is used to construct a regular expression
        return input.matches(regex);
      }

      public boolean goodExample(javax.servlet.http.HttpServletRequest request) {
        String regex = request.getParameter("regex");
        String input = request.getParameter("input");

        // GOOD: User input is sanitized before constructing the regex
        return input.matches(Pattern.quote(regex));
      }
    }

    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * Java API Specification: [Pattern.quote](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html#quote(java.lang.String)).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-732/ReadingFromWorldWritableFile.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-732/ReadingFromWorldWritableFile.bqrs
  metadata:
    name: Reading from a world writable file
    description: |-
      Reading from a file which is set as world writable is dangerous because
                    the file may be modified or removed by external actors.
    kind: problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: java/world-writable-file-read
    tags: |-
      security
             external/cwe/cwe-732
  queryHelp: |
    # Reading from a world writable file
    Reading from a world-writable file is dangerous on a multi-user system because other users may be able to affect program execution by modifying or deleting the file.


    ## Recommendation
    Do not make files explicitly world writable unless the file is intended to be written by multiple users on a multi-user system. In many cases, the file may only need to be writable for the current user.

    For some file systems, there may be alternatives to setting the file to be world writable. For example, POSIX file systems support "groups" which may be used to ensure that only subset of all the users can write to the file. Access Control Lists (ACLs) are available for many operating system and file system combinations, and can provide fine-grained read and write support without resorting to world writable permissions.


    ## Example
    In the following example, we are loading some configuration parameters from a file:

    ```java

    private void readConfig(File configFile) {
      if (!configFile.exists()) {
        // Create an empty config file
        configFile.createNewFile();
        // Make the file writable for all
        configFile.setWritable(true, false);
      }
      // Now read the config
      loadConfig(configFile);
    }

    ```
    If the configuration file does not yet exist, an empty file is created. Creating an empty file can simplify the later code and is a convenience for the user. However, by setting the file to be world writable, we allow any user on the system to modify the configuration, not just the current user. If there may be untrusted users on the system, this is potentially dangerous.


    ## References
    * SEI CERT Oracle Coding Standard for Java: [FIO01-J. Create files with appropriate access permissions](https://wiki.sei.cmu.edu/confluence/display/java/FIO01-J.+Create+files+with+appropriate+access+permissions).
    * Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-749/UnsafeAndroidAccess.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-749/UnsafeAndroidAccess.bqrs
  metadata:
    name: Unsafe resource fetching in Android WebView
    description: |-
      JavaScript rendered inside WebViews can access protected
                    application files and web resources from any origin exposing them to attack.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: medium
    id: java/android/unsafe-android-webview-fetch
    tags: |-
      security
             external/cwe/cwe-749
             external/cwe/cwe-079
  queryHelp: "# Unsafe resource fetching in Android WebView\nAndroid WebViews that\
    \ allow externally controlled URLs to be loaded, and whose JavaScript interface\
    \ is enabled, are potentially vulnerable to cross-site scripting and sensitive\
    \ resource disclosure attacks.\n\nA `WebView` whose `WebSettings` object has called\
    \ `setAllowFileAccessFromFileURLs(true)` or `setAllowUniversalAccessFromFileURLs(true)`\
    \ must not load any untrusted web content.\n\nEnabling these settings allows malicious\
    \ scripts loaded in a `file://` context to launch cross-site scripting attacks,\
    \ accessing arbitrary local files including WebView cookies, session tokens, private\
    \ app data or even credentials used on arbitrary web sites.\n\nThis query detects\
    \ the following two scenarios:\n\n1. A vulnerability introduced by WebViews when\
    \ JavaScript is enabled and remote inputs are allowed.\n1. A more severe vulnerability\
    \ when \"allow cross-origin resource access\" is also enabled. This setting was\
    \ deprecated in API level 30 (Android 11), but most devices are still affected,\
    \ especially since some Android phones are updated slowly or no longer updated\
    \ at all.\n\n## Recommendation\nOnly allow trusted web content to be displayed\
    \ in WebViews when JavaScript is enabled. Disallow cross-origin resource access\
    \ in WebSettings to reduce the attack surface.\n\n\n## Example\nThe following\
    \ example shows both 'BAD' and 'GOOD' configurations. In the 'BAD' configuration,\
    \ JavaScript and the allow access setting are enabled and URLs are loaded from\
    \ externally controlled inputs. In the 'GOOD' configuration, JavaScript is disabled\
    \ or only trusted web content is allowed to be loaded.\n\n\n```java\npublic class\
    \ UnsafeAndroidAccess extends Activity {\n\tpublic void onCreate(Bundle savedInstanceState)\
    \ {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.webview);\n\
    \n\t\t// BAD: Have both JavaScript and cross-origin resource access enabled in\
    \ webview while\n\t\t// taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView)\
    \ findViewById(R.id.my_webview);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\
    \n\t\t\twebSettings.setJavaScriptEnabled(true);\n\t\t\twebSettings.setAllowUniversalAccessFromFileURLs(true);\n\
    \n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\t\
    public boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\t\
    view.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tString\
    \ thisUrl = getIntent().getExtras().getString(\"url\"); // dangerous remote input\
    \ from  the intent's Bundle of extras\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\
    \t// BAD: Have both JavaScript and cross-origin resource access enabled in webview\
    \ while\n\t\t// taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView)\
    \ findViewById(R.id.my_webview);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\
    \n\t\t\twebSettings.setJavaScriptEnabled(true);\n\t\t\twebSettings.setAllowUniversalAccessFromFileURLs(true);\n\
    \n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\t\
    public boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\t\
    view.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tString\
    \ thisUrl = getIntent().getStringExtra(\"url\"); //dangerous remote input from\
    \ intent extra\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\t// GOOD: Have JavaScript\
    \ and cross-origin resource access disabled by default on modern Android (Jellybean+)\
    \ while taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(-1);\n\
    \t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twv.setWebViewClient(new\
    \ WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView\
    \ view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\
    \t\t\t}\n\t\t\t});\n\n\t\t\tString thisUrl = getIntent().getExtras().getString(\"\
    url\"); // remote input\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\t// GOOD: Have\
    \ JavaScript enabled in webview but remote user input is not allowed\n\t\t{\n\t\
    \t\tWebView wv = (WebView) findViewById(-1);\n\t\t\tWebSettings webSettings =\
    \ wv.getSettings();\n\n\t\t\twebSettings.setJavaScriptEnabled(true);\n\n\t\t\t\
    wv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean\
    \ shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\
    \t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\twv.loadUrl(\"https://www.mycorp.com\"\
    );\n\t\t}\n\t}\n}\n```\n\n## References\n* Google Help: [Fixing a File-based XSS\
    \ Vulnerability](https://support.google.com/faqs/answer/7668153?hl=en)\n* OWASP:\
    \ [Testing JavaScript Execution in WebViews (MSTG-PLATFORM-5)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-javascript-execution-in-webviews-mstg-platform-5)\n\
    * OWASP: [Testing WebView Protocol Handlers (MSTG-PLATFORM-6)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-webview-protocol-handlers-mstg-platform-6)\n\
    * Common Weakness Enumeration: [CWE-749](https://cwe.mitre.org/data/definitions/749.html).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-780/RsaWithoutOaep.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-780/RsaWithoutOaep.bqrs
  metadata:
    name: Use of RSA algorithm without OAEP
    description: "Using RSA encryption without OAEP padding can result in a padding\
      \ oracle attack, leading to a weaker encryption."
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: java/rsa-without-oaep
    tags: |-
      security
             external/cwe/cwe-780
  queryHelp: |
    # Use of RSA algorithm without OAEP
    Cryptographic algorithms often use padding schemes to make the plaintext less predictable. The OAEP (Optimal Asymmetric Encryption Padding) scheme should be used with RSA encryption. Using an outdated padding scheme such as PKCS1, or no padding at all, can weaken the encryption by making it vulnerable to a padding oracle attack.


    ## Recommendation
    Use the OAEP scheme when using RSA encryption.


    ## Example
    In the following example, the BAD case shows no padding being used, whereas the GOOD case shows an OAEP scheme being used.


    ```java
    // BAD: No padding scheme is used
    Cipher rsa = Cipher.getInstance("RSA/ECB/NoPadding");
    ...

    //GOOD: OAEP padding is used
    Cipher rsa = Cipher.getInstance("RSA/ECB/OAEPWithSHA-1AndMGF1Padding");
    ...
    ```

    ## References
    * [Mobile Security Testing Guide](https://github.com/MobSF/owasp-mstg/blob/master/Document/0x04g-Testing-Cryptography.md#padding-oracle-attacks-due-to-weaker-padding-or-block-operation-implementations).
    * [The Padding Oracle Attack](https://robertheaton.com/2013/07/29/padding-oracle-attack/).
    * Common Weakness Enumeration: [CWE-780](https://cwe.mitre.org/data/definitions/780.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-798/HardcodedCredentialsApiCall.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-798/HardcodedCredentialsApiCall.bqrs
  metadata:
    name: Hard-coded credential in API call
    description: Using a hard-coded credential in a call to a sensitive Java API may
      compromise security.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: medium
    id: java/hardcoded-credential-api-call
    tags: |-
      security
             external/cwe/cwe-798
  queryHelp: |
    # Hard-coded credential in API call
    Including unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.


    ## Recommendation
    Remove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.


    ## Example
    The following code example connects to a database using a hard-coded user name and password:


    ```java
    private static final String p = "123456"; // hard-coded credential

    public static void main(String[] args) throws SQLException {
        String url = "jdbc:mysql://localhost/test";
        String u = "admin"; // hard-coded credential

        getConn(url, u, p);
    }

    public static void getConn(String url, String v, String q) throws SQLException {
        DriverManager.getConnection(url, v, q); // sensitive call
    }

    ```
    Instead, the user name and password could be supplied through environment variables, which can be set externally without hard-coding credentials in the source code.


    ## References
    * OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).
    * Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-807/ConditionalBypass.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-807/ConditionalBypass.bqrs
  metadata:
    name: User-controlled bypass of sensitive method
    description: |-
      User-controlled bypassing of sensitive methods may allow attackers to avoid
                    passing through authentication systems.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: medium
    id: java/user-controlled-bypass
    tags: |-
      security
             external/cwe/cwe-807
             external/cwe/cwe-290
  queryHelp: "# User-controlled bypass of sensitive method\nMany Java constructs enable\
    \ code statements to be executed conditionally, for example `if` statements and\
    \ `for` statements. If these statements contain important authentication or login\
    \ code, and the decision about whether to execute this code is based on user-controlled\
    \ data, it may be possible for an attacker to bypass security systems by preventing\
    \ this code from executing.\n\n\n## Recommendation\nNever decide whether to authenticate\
    \ a user based on data that may be controlled by that user. If necessary, ensure\
    \ that the data is validated extensively when it is input before any authentication\
    \ checks are performed.\n\nIt is still possible to have a system that \"remembers\"\
    \ users, thus not requiring the user to login on every interaction. For example,\
    \ personalization settings can be applied without authentication because this\
    \ is not sensitive information. However, users should be allowed to take sensitive\
    \ actions only when they have been fully authenticated.\n\n\n## Example\nThis\
    \ example shows two ways of deciding whether to authenticate a user. The first\
    \ way shows a decision that is based on the value of a cookie. Cookies can be\
    \ easily controlled by the user, and so this allows a user to become authenticated\
    \ without providing valid credentials. The second, more secure way shows a decision\
    \ that is based on looking up the user in a security database.\n\n\n```java\n\
    public boolean doLogin(String user, String password) {\n\tCookie adminCookie =\
    \ getCookies()[0];\n\n\t// BAD: login is executed only if the value of 'adminCookie'\
    \ is 'false', \n\t// but 'adminCookie' is controlled by the user\n\tif(adminCookie.getValue()==\"\
    false\")\n\t\treturn login(user, password);\n\t\n\treturn true;\n}\n\npublic boolean\
    \ doLogin(String user, String password) {\n\tCookie adminCookie = getCookies()[0];\n\
    \t\n\t// GOOD: use server-side information based on the credentials to decide\n\
    \t// whether user has privileges\n\tboolean isAdmin = queryDbForAdminStatus(user,\
    \ password);\n\tif(!isAdmin)\n\t\treturn login(user, password);\n\t\n\treturn\
    \ true;\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java:\
    \ [SEC02-J. Do not base security checks on untrusted sources](https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources).\n\
    * Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n\
    * Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-807/TaintedPermissionsCheck.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-807/TaintedPermissionsCheck.bqrs
  metadata:
    name: User-controlled data used in permissions check
    description: |-
      Using user-controlled data in a permissions check may result in inappropriate
                    permissions being granted.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: java/tainted-permissions-check
    tags: |-
      security
             external/cwe/cwe-807
             external/cwe/cwe-290
  queryHelp: "# User-controlled data used in permissions check\nUsing user-controlled\
    \ data in a permissions check may allow a user to gain unauthorized access to\
    \ protected functionality or data.\n\n\n## Recommendation\nWhen checking whether\
    \ a user is authorized for a particular activity, do not use data that is controlled\
    \ by that user in the permissions check. If necessary, always validate the input,\
    \ ideally against a fixed list of expected values.\n\nSimilarly, do not decide\
    \ which permission to check for based on user data. In particular, avoid using\
    \ computation to decide which permissions to check for. Use fixed permissions\
    \ for particular actions, rather than generating the permission to check for.\n\
    \n\n## Example\nThis example, using the Apache Shiro security framework, shows\
    \ two ways to specify the permissions to check. The first way uses a string, `whatDoTheyWantToDo`,\
    \ to specify the permissions to check. However, this string is built from user\
    \ input. This can allow an attacker to force a check against a permission that\
    \ they know they have, rather than the permission that should be checked. For\
    \ example, while trying to access the account details of another user, the attacker\
    \ could force the system to check whether they had permissions to access their\
    \ *own* account details, which is incorrect, and would allow them to perform the\
    \ action. The second, more secure way uses a fixed check that does not depend\
    \ on data that is controlled by the user.\n\n\n```java\npublic static void main(String[]\
    \ args) {\n\tString whatDoTheyWantToDo = args[0];\n\tSubject subject = SecurityUtils.getSubject();\n\
    \n\t// BAD: permissions decision made using tainted data\n\tif(subject.isPermitted(\"\
    domain:sublevel:\" + whatDoTheyWantToDo))\n\t\tdoIt();\n\n\t// GOOD: use fixed\
    \ checks\n\tif(subject.isPermitted(\"domain:sublevel:whatTheMethodDoes\"))\n\t\
    \tdoIt();\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java:\
    \ [SEC02-J. Do not base security checks on untrusted sources](https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources).\n\
    * Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n\
    * Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-829/InsecureDependencyResolution.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-829/InsecureDependencyResolution.bqrs
  metadata:
    name: Failure to use HTTPS or SFTP URL in Maven artifact upload/download
    description: Non-HTTPS connections can be intercepted by third parties.
    kind: problem
    problem.severity: error
    security-severity: 8.1
    precision: very-high
    id: java/maven/non-https-url
    tags: |-
      security
             external/cwe/cwe-300
             external/cwe/cwe-319
             external/cwe/cwe-494
             external/cwe/cwe-829
  queryHelp: |
    # Failure to use HTTPS or SFTP URL in Maven artifact upload/download
    Using an insecure protocol like HTTP or FTP to download your dependencies leaves your Maven build vulnerable to a [Man in the Middle (MITM)](https://en.wikipedia.org/wiki/Man-in-the-middle_attack). This can allow attackers to inject malicious code into the artifacts that you are resolving and infect build artifacts that are being produced. This can be used by attackers to perform a [Supply chain attack](https://en.wikipedia.org/wiki/Supply_chain_attack) against your project's users.

    This vulnerability has a [ CVSS v3.1 base score of 8.1/10 ](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H&version=3.1).


    ## Recommendation
    Always use HTTPS or SFTP to download artifacts from artifact servers.


    ## Example
    These examples show examples of locations in Maven POM files where artifact repository upload/download is configured. The first shows the use of HTTP, the second shows the use of HTTPS.


    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

        <modelVersion>4.0.0</modelVersion>

        <groupId>com.semmle</groupId>
        <artifactId>parent</artifactId>
        <version>1.0</version>
        <packaging>pom</packaging>

        <name>Security Testing</name>
        <description>An example of insecure download and upload of dependencies</description>

        <distributionManagement>
            <repository>
                <id>insecure-releases</id>
                <name>Insecure Repository Releases</name>
                <!-- BAD! Use HTTPS -->
                <url>http://insecure-repository.example</url>
            </repository>
            <snapshotRepository>
                <id>insecure-snapshots</id>
                <name>Insecure Repository Snapshots</name>
                <!-- BAD! Use HTTPS -->
                <url>http://insecure-repository.example</url>
            </snapshotRepository>
        </distributionManagement>
        <repositories>
            <repository>
                <id>insecure</id>
                <name>Insecure Repository</name>
                <!-- BAD! Use HTTPS -->
                <url>http://insecure-repository.example</url>
            </repository>
        </repositories>
        <pluginRepositories>
            <pluginRepository>
                <id>insecure-plugins</id>
                <name>Insecure Repository Releases</name>
                <!-- BAD! Use HTTPS -->
                <url>http://insecure-repository.example</url>
            </pluginRepository>
        </pluginRepositories>
    </project>

    ```

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

        <modelVersion>4.0.0</modelVersion>

        <groupId>com.semmle</groupId>
        <artifactId>parent</artifactId>
        <version>1.0</version>
        <packaging>pom</packaging>

        <name>Security Testing</name>
        <description>An example of secure download and upload of dependencies</description>

        <distributionManagement>
            <repository>
                <id>insecure-releases</id>
                <name>Secure Repository Releases</name>
                <!-- GOOD! Use HTTPS -->
                <url>https://insecure-repository.example</url>
            </repository>
            <snapshotRepository>
                <id>insecure-snapshots</id>
                <name>Secure Repository Snapshots</name>
                <!-- GOOD! Use HTTPS -->
                <url>https://insecure-repository.example</url>
            </snapshotRepository>
        </distributionManagement>
        <repositories>
            <repository>
                <id>insecure</id>
                <name>Secure Repository</name>
                <!-- GOOD! Use HTTPS -->
                <url>https://insecure-repository.example</url>
            </repository>
        </repositories>
        <pluginRepositories>
            <pluginRepository>
                <id>insecure-plugins</id>
                <name>Secure Repository Releases</name>
                <!-- GOOD! Use HTTPS -->
                <url>https://insecure-repository.example</url>
            </pluginRepository>
        </pluginRepositories>
    </project>

    ```

    ## References
    * Research: [ Want to take over the Java ecosystem? All you need is a MITM! ](https://medium.com/bugbountywriteup/want-to-take-over-the-java-ecosystem-all-you-need-is-a-mitm-1fc329d898fb?source=friends_link&sk=3c99970c55a899ad9ef41f126efcde0e)
    * Research: [ How to take over the computer of any Java (or Closure or Scala) Developer. ](https://max.computer/blog/how-to-take-over-the-computer-of-any-java-or-clojure-or-scala-developer/)
    * Proof of Concept: [ mveytsman/dilettante ](https://github.com/mveytsman/dilettante)
    * Additional Gradle &amp; Maven plugin: [ Announcing nohttp ](https://spring.io/blog/2019/06/10/announcing-nohttp)
    * Java Ecosystem Announcement: [ HTTP Decommission Artifact Server Announcements ](https://gist.github.com/JLLeitschuh/789e49e3d34092a005031a0a1880af99)
    * Common Weakness Enumeration: [CWE-300](https://cwe.mitre.org/data/definitions/300.html).
    * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).
    * Common Weakness Enumeration: [CWE-494](https://cwe.mitre.org/data/definitions/494.html).
    * Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-835/InfiniteLoop.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-835/InfiniteLoop.bqrs
  metadata:
    name: Loop with unreachable exit condition
    description: |-
      An iteration or loop with an exit condition that cannot be
                    reached is an indication of faulty logic and can likely lead to infinite
                    looping.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: java/unreachable-exit-in-loop
    tags: |-
      security
             external/cwe/cwe-835
  queryHelp: |
    # Loop with unreachable exit condition
    Loops can contain multiple exit conditions, either directly in the loop condition or as guards around `break` or `return` statements. If an exit condition cannot be satisfied, then the code is misleading at best, and the loop might not terminate.


    ## Recommendation
    When writing a loop that is intended to terminate, make sure that all the necessary exit conditions can be satisfied and that loop termination is clear.


    ## Example
    The following example shows a potentially infinite loop, since the inner loop condition is constantly true. Of course, the loop may or may not be infinite depending on the behavior of `shouldBreak`, but if this was intended as the only exit condition the loop should be rewritten to make this clear.


    ```java
    for (int i=0; i<10; i++) {
        for (int j=0; i<10; j++) {
            // do stuff
            if (shouldBreak()) break;
        }
    }

    ```
    To fix the loop the condition is corrected to check the right variable.


    ```java
    for (int i=0; i<10; i++) {
        for (int j=0; j<10; j++) {
            // do stuff
            if (shouldBreak()) break;
        }
    }

    ```

    ## References
    * Java Language Specification: [Blocks and Statements](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html).
    * Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-917/OgnlInjection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-917/OgnlInjection.bqrs
  metadata:
    name: OGNL Expression Language statement with user-controlled input
    description: |-
      Evaluation of OGNL Expression Language statement with user-controlled input can
                      lead to execution of arbitrary code.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: java/ognl-injection
    tags: |-
      security
             external/cwe/cwe-917
  queryHelp: "# OGNL Expression Language statement with user-controlled input\nObject-Graph\
    \ Navigation Language (OGNL) is an open-source Expression Language (EL) for Java.\
    \ OGNL can create or change executable code, consequently it can introduce critical\
    \ security flaws to any application that uses it. Evaluation of unvalidated expressions\
    \ is a common flaw in OGNL. This exposes the properties of Java objects to modification\
    \ by an attacker and may allow them to execute arbitrary code.\n\n\n## Recommendation\n\
    The general recommendation is to avoid evaluating untrusted ONGL expressions.\
    \ If user-provided OGNL expressions must be evaluated, do this in a sandbox and\
    \ validate the expressions before evaluation.\n\n\n## Example\nIn the following\
    \ examples, the code accepts an OGNL expression from the user and evaluates it.\n\
    \nIn the first example, the user-provided OGNL expression is parsed and evaluated.\n\
    \nThe second example validates the expression and evaluates it inside a sandbox.\
    \ You can add a sandbox by setting a system property, as shown in the example,\
    \ or by adding `-Dognl.security.manager` to JVM arguments.\n\n\n```java\nimport\
    \ ognl.Ognl;\nimport ognl.OgnlException;\n\npublic void evaluate(HttpServletRequest\
    \ request, Object root) throws OgnlException {\n  String expression = request.getParameter(\"\
    expression\");\n\n  // BAD: User provided expression is evaluated\n  Ognl.getValue(expression,\
    \ root);\n  \n  // GOOD: The name is validated and expression is evaluated in\
    \ sandbox\n  System.setProperty(\"ognl.security.manager\", \"\"); // Or add -Dognl.security.manager\
    \ to JVM args\n  if (isValid(expression)) {\n    Ognl.getValue(expression, root);\n\
    \  } else {\n    // Reject the request\n  }\n}\n\npublic void isValid(Strig expression)\
    \ {\n  // Custom method to validate the expression.\n  // For instance, make sure\
    \ it doesn't include unexpected code.\n}\n\n```\n\n## References\n* Apache Commons:\
    \ [Apache Commons OGNL](https://commons.apache.org/proper/commons-ognl/).\n* Struts\
    \ security: [Proactively protect from OGNL Expression Injections attacks](https://struts.apache.org/security/#proactively-protect-from-ognl-expression-injections-attacks-if-easily-applicable).\n\
    * Common Weakness Enumeration: [CWE-917](https://cwe.mitre.org/data/definitions/917.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-918/RequestForgery.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-918/RequestForgery.bqrs
  metadata:
    name: Server-side request forgery
    description: |-
      Making web requests based on unvalidated user-input
                    may cause the server to communicate with malicious servers.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: high
    id: java/ssrf
    tags: |-
      security
             external/cwe/cwe-918
  queryHelp: "# Server-side request forgery\nDirectly incorporating user input into\
    \ an HTTP request without validating the input can facilitate server-side request\
    \ forgery (SSRF) attacks. In these attacks, the server may be tricked into making\
    \ a request and interacting with an attacker-controlled server.\n\n\n## Recommendation\n\
    To guard against SSRF attacks, you should avoid putting user-provided input directly\
    \ into a request URL. Instead, maintain a list of authorized URLs on the server;\
    \ then choose from that list based on the input provided. Alternatively, ensure\
    \ requests constructed from user input are limited to a particular host or more\
    \ restrictive URL prefix.\n\n\n## Example\nThe following example shows an HTTP\
    \ request parameter being used directly to form a new request without validating\
    \ the input, which facilitates SSRF attacks. It also shows how to remedy the problem\
    \ by validating the user input against a known fixed string.\n\n\n```java\nimport\
    \ java.net.http.HttpClient;\n\npublic class SSRF extends HttpServlet {\n\tprivate\
    \ static final String VALID_URI = \"http://lgtm.com\";\n\tprivate HttpClient client\
    \ = HttpClient.newHttpClient();\n\n\tprotected void doGet(HttpServletRequest request,\
    \ HttpServletResponse response)\n\t\tthrows ServletException, IOException {\n\t\
    \tURI uri = new URI(request.getParameter(\"uri\"));\n\t\t// BAD: a request parameter\
    \ is incorporated without validation into a Http request\n\t\tHttpRequest r =\
    \ HttpRequest.newBuilder(uri).build();\n\t\tclient.send(r, null);\n\n\t\t// GOOD:\
    \ the request parameter is validated against a known fixed string\n\t\tif (VALID_URI.equals(request.getParameter(\"\
    uri\"))) {\n\t\t\tHttpRequest r2 = HttpRequest.newBuilder(uri).build();\n\t\t\t\
    client.send(r2, null);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* [OWASP SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n\
    * Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-925/ImproperIntentVerification.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-925/ImproperIntentVerification.bqrs
  metadata:
    name: Improper verification of intent by broadcast receiver
    description: A broadcast receiver that does not verify intents it receives may
      be susceptible to unintended behavior by third party applications sending it
      explicit intents.
    kind: problem
    problem.severity: warning
    security-severity: 8.2
    precision: high
    id: java/improper-intent-verification
    tags: |-
      security
             external/cwe/cwe-925
  queryHelp: |
    # Improper verification of intent by broadcast receiver
    When an Android application uses a `BroadcastReceiver` to receive intents, it is also able to receive explicit intents that are sent directly to it, regardless of its filter. Certain intent actions are only able to be sent by the operating system, not third-party applications. However, a `BroadcastReceiver` that is registered to receive system intents is still able to receive intents from a third-party application, so it should check that the intent received has the expected action. Otherwise, a third-party application could impersonate the system this way to cause unintended behavior, such as a denial of service.


    ## Example
    In the following code, the `ShutdownReceiver` initiates a shutdown procedure upon receiving an intent, without checking that the received action is indeed `ACTION_SHUTDOWN`. This allows third-party applications to send explicit intents to this receiver to cause a denial of service.


    ```java
    public class ShutdownReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(final Context context, final Intent intent) {
            mainActivity.saveLocalData();
            mainActivity.stopActivity();
        }
    }
    ```

    ```xml
    <manifest xmlns:android="http://schemas.android.com/apk/res/android" package="test">
        <application>
            <receiver android:name=".BootReceiverXml">
                <intent-filter>
                    <action android:name="android.intent.action.BOOT_COMPLETED" />
                </intent-filter>
            </receiver>
        </application>
    </manifest>
    ```

    ## Recommendation
    In the `onReceive` method of a `BroadcastReceiver`, the action of the received Intent should be checked. The following code demonstrates this.


    ```java
    public class ShutdownReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(final Context context, final Intent intent) {
            if (!intent.getAction().equals(Intent.ACTION_SHUTDOWN)) {
                return;
            }
            mainActivity.saveLocalData();
            mainActivity.stopActivity();
        }
    }
    ```

    ## References
    * Common Weakness Enumeration: [CWE-925](https://cwe.mitre.org/data/definitions/925.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-926/ContentProviderIncompletePermissions.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-926/ContentProviderIncompletePermissions.bqrs
  metadata:
    name: Missing read or write permission in a content provider
    description: Android content providers which do not configure both read and write
      permissions can allow permission bypass.
    kind: problem
    problem.severity: warning
    security-severity: 8.2
    id: java/android/incomplete-provider-permissions
    tags: |-
      security
             external/cwe/cwe-926
    precision: medium
  queryHelp: |
    # Missing read or write permission in a content provider
    The Android manifest file specifies the content providers for the application using `provider` elements. The `provider` element specifies the explicit permissions an application requires in order to access a resource using that provider. You specify the permissions using the `android:readPermission`, `android:writePermission`, or `android:permission` attributes. If you do not specify the permission required to perform an operation, the application will implicitly have access to perform that operation. For example, if you specify only `android:readPermission`, the application must have explicit permission to read data, but requires no permission to write data.


    ## Recommendation
    To prevent permission bypass, you should create `provider` elements that either specify both the `android:readPermission` and `android:writePermission` attributes, or specify the `android:permission` attribute.


    ## Example
    In the following two (bad) examples, the provider is configured with only read or write permissions. This allows a malicious application to bypass the permission check by requesting access to the unrestricted operation.


    ```xml
    <manifest ... >
        <application ...>
          <!-- BAD: only 'android:readPermission' is set -->
          <provider
              android:name=".MyContentProvider"
              android:authorities="table"
              android:enabled="true"
              android:exported="true"
              android:readPermission="android.permission.MANAGE_DOCUMENTS">
          </provider>
        </application>
    </manifest>

    ```

    ```xml
    <manifest ... >
        <application ...>
          <!-- BAD: only 'android:writePermission' is set -->
          <provider
              android:name=".MyContentProvider"
              android:authorities="table"
              android:enabled="true"
              android:exported="true"
              android:writePermission="android.permission.MANAGE_DOCUMENTS">
          </provider>
        </application>
    </manifest>

    ```
    In the following (good) examples, the provider is configured with full permissions, protecting it from a permissions bypass.


    ```xml
    <manifest ... >
        <application ...>
          <!-- Good: both 'android:readPermission' and 'android:writePermission' are set -->
          <provider
              android:name=".MyContentProvider"
              android:authorities="table"
              android:enabled="true"
              android:exported="true"
              android:writePermission="android.permission.MANAGE_DOCUMENTS"
              android:readPermission="android.permission.MANAGE_DOCUMENTS">
          </provider>
        </application>
    </manifest>

    ```

    ```xml
    <manifest ... >
        <application ...>
          <!-- Good: 'android:permission' is set  -->
          <provider
              android:name=".MyContentProvider"
              android:authorities="table"
              android:enabled="true"
              android:exported="true"
              android:permission="android.permission.MANAGE_DOCUMENTS">
          </provider>
        </application>
    </manifest>

    ```

    ## References
    * Android Documentation: [Provider element](https://developer.android.com/guide/topics/manifest/provider-element)
    * CVE-2021-41166: [Insufficient permission control in Nextcloud Android app](https://nvd.nist.gov/vuln/detail/CVE-2021-41166)
    * GitHub Security Lab Research: [Insufficient permission control in Nextcloud Android app](https://securitylab.github.com/advisories/GHSL-2021-1007-Nextcloud_Android_app/#issue-2-permission-bypass-in-disklruimagecachefileprovider-ghsl-2021-1008)
    * Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-926/ImplicitlyExportedAndroidComponent.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-926/ImplicitlyExportedAndroidComponent.bqrs
  metadata:
    name: Implicitly exported Android component
    description: "Android components with an '<intent-filter>' and no 'android:exported'\
      \ attribute are implicitly exported, which can allow for improper access to\
      \ the components themselves and to their data."
    kind: problem
    problem.severity: warning
    security-severity: 8.2
    id: java/android/implicitly-exported-component
    tags: |-
      security
             external/cwe/cwe-926
    precision: high
  queryHelp: |
    # Implicitly exported Android component
    The Android manifest file defines configuration settings for Android applications. In this file, components can be declared with intent filters which specify what the components can do and what types of intents the components can respond to. If the `android:exported` attribute is omitted from the component when an intent filter is included, then the component will be implicitly exported.

    An implicitly exported component could allow for improper access to the component and its data.


    ## Recommendation
    Explicitly set the `android:exported` attribute for every component or use permissions to limit access to the component.


    ## Example
    In the example below, the `android:exported` attribute is omitted when an intent filter is used.


    ```xml
    <manifest ... >
        <application ...
            <!-- BAD: this component is implicitly exported -->
            <activity>
                android:name=".Activity">
                <intent-filter>
                    <action android:name="android.intent.action.VIEW" />
                </intent-filter>
            </activity>
        </application>
    </manifest>

    ```
    A corrected version sets the `android:exported` attribute to `false`.


    ```xml
    <manifest ... >
        <application ...
            <!-- GOOD: this component is not exported due to 'android:exported' explicitly set to 'false'-->
            <activity>
                android:name=".Activity">
                android:exported="false"
                <intent-filter>
                    <action android:name="android.intent.action.VIEW" />
                </intent-filter>
            </activity>
        </application>
    </manifest>

    ```

    ## References
    * Android Developers: [App Manifest Overview](https://developer.android.com/guide/topics/manifest/manifest-intro).
    * Android Developers: [The &lt;intent-filter&gt; element](https://developer.android.com/guide/topics/manifest/intent-filter-element).
    * Android Developers: [The android:exported attribute](https://developer.android.com/guide/topics/manifest/activity-element#exported).
    * Android Developers: [The android:permission attribute](https://developer.android.com/guide/topics/manifest/activity-element#prmsn).
    * Android Developers: [Safer component exporting](https://developer.android.com/about/versions/12/behavior-changes-12#exported).
    * Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-927/ImplicitPendingIntents.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-927/ImplicitPendingIntents.bqrs
  metadata:
    name: Use of implicit PendingIntents
    description: |-
      Sending an implicit and mutable 'PendingIntent' to an unspecified third party
                    component may provide an attacker with access to internal components of the
                    application or cause other unintended effects.
    kind: path-problem
    problem.severity: error
    security-severity: 8.2
    precision: high
    id: java/android/implicit-pendingintents
    tags: |-
      security
             external/cwe/cwe-927
  queryHelp: "# Use of implicit PendingIntents\nA `PendingIntent` is used to wrap\
    \ an `Intent` that will be supplied and executed by another application. When\
    \ the `Intent` is executed, it behaves as if it were run directly by the supplying\
    \ application, using the privileges of that application.\n\nIf a `PendingIntent`\
    \ is configured to be mutable, the fields of its internal `Intent` can be changed\
    \ by the receiving application if they were not previously set. This means that\
    \ a mutable `PendingIntent` that has not defined a destination component (that\
    \ is, an implicit `PendingIntent`) can be altered to execute an arbitrary action\
    \ with the privileges of the application that created it.\n\nA malicious application\
    \ can access an implicit `PendingIntent` as follows:\n\n* It is wrapped and sent\
    \ as an extra of another implicit `Intent`.\n* It is sent as the action of a `Slide`.\n\
    * It is sent as the action of a `Notification`.\n\n\nOn gaining access, the attacker\
    \ can modify the underlying `Intent` and execute an arbitrary action with elevated\
    \ privileges. This could give the malicious application access to private components\
    \ of the victim application, or the ability to perform actions without having\
    \ the necessary permissions.\n\n\n## Recommendation\nAvoid creating implicit `PendingIntent`s.\
    \ This means that the underlying `Intent` should always have an explicit destination\
    \ component.\n\nWhen you add the `PendingIntent` as an extra of another `Intent`,\
    \ make sure that this second `Intent` also has an explicit destination component,\
    \ so that it is not delivered to untrusted applications.\n\nCreate the `PendingIntent`\
    \ using the flag `FLAG_IMMUTABLE` whenever possible, to prevent the destination\
    \ component from modifying empty fields of the underlying `Intent`.\n\n\n## Example\n\
    In the following examples, a `PendingIntent` is created and wrapped as an extra\
    \ of another `Intent`.\n\nIn the first example, both the `PendingIntent` and the\
    \ `Intent` it is wrapped in are implicit, making them vulnerable to attack.\n\n\
    In the second example, the issue is avoided by adding explicit destination components\
    \ to the `PendingIntent` and the wrapping `Intent`.\n\nThe third example uses\
    \ the `FLAG_IMMUTABLE` flag to prevent the underlying `Intent` from being modified\
    \ by the destination component.\n\n\n```java\nimport android.app.Activity;\nimport\
    \ android.app.PendingIntent;\nimport android.content.Intent;\nimport android.os.Bundle;\n\
    \npublic class ImplicitPendingIntents extends Activity {\n\n\tpublic void onCreate(Bundle\
    \ savedInstance) {\n\t\t{\n\t\t\t// BAD: an implicit Intent is used to create\
    \ a PendingIntent.\n\t\t\t// The PendingIntent is then added to another implicit\
    \ Intent\n\t\t\t// and started.\n\t\t\tIntent baseIntent = new Intent();\n\t\t\
    \tPendingIntent pi =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, baseIntent,\
    \ PendingIntent.FLAG_ONE_SHOT);\n\t\t\tIntent fwdIntent = new Intent(\"SOME_ACTION\"\
    );\n\t\t\tfwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\tsendBroadcast(fwdIntent);\n\
    \t\t}\n\n\t\t{\n\t\t\t// GOOD: both the PendingIntent and the wrapping Intent\
    \ are explicit.\n\t\t\tIntent safeIntent = new Intent(this, AnotherActivity.class);\n\
    \t\t\tPendingIntent pi =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, safeIntent,\
    \ PendingIntent.FLAG_ONE_SHOT);\n\t\t\tIntent fwdIntent = new Intent();\n\t\t\t\
    fwdIntent.setClassName(\"destination.package\", \"DestinationClass\");\n\t\t\t\
    fwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\tstartActivity(fwdIntent);\n\t\t\
    }\n\n\t\t{\n\t\t\t// GOOD: The PendingIntent is created with FLAG_IMMUTABLE.\n\
    \t\t\tIntent baseIntent = new Intent(\"SOME_ACTION\");\n\t\t\tPendingIntent pi\
    \ =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, baseIntent, PendingIntent.FLAG_IMMUTABLE);\n\
    \t\t\tIntent fwdIntent = new Intent();\n\t\t\tfwdIntent.setClassName(\"destination.package\"\
    , \"DestinationClass\");\n\t\t\tfwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\t\
    startActivity(fwdIntent);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Google Help:\
    \ [ Remediation for Implicit PendingIntent Vulnerability ](https://support.google.com/faqs/answer/10437428?hl=en)\n\
    * University of Potsdam: [ PIAnalyzer: A precise approach for PendingIntent vulnerability\
    \ analysis ](https://www.cs.uni-potsdam.de/se/papers/esorics18.pdf)\n* Common\
    \ Weakness Enumeration: [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-927/SensitiveCommunication.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-927/SensitiveCommunication.bqrs
  metadata:
    name: Leaking sensitive information through an implicit Intent
    description: |-
      An Android application uses implicit Intents containing sensitive data
                    in a way that exposes it to arbitrary applications on the device.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.2
    precision: medium
    id: java/android/sensitive-communication
    tags: |-
      security
             external/cwe/cwe-927
  queryHelp: "# Leaking sensitive information through an implicit Intent\nWhen an\
    \ implicit Intent is used with a method such as `startActivity`, `startService`,\
    \ or `sendBroadcast`, it may be read by other applications on the device.\n\n\
    This means that sensitive data in these Intents may be leaked.\n\n\n## Recommendation\n\
    For `sendBroadcast` methods, a receiver permission may be specified so that only\
    \ applications with a certain permission may receive the Intent; or a `LocalBroadcastManager`\
    \ may be used. Otherwise, ensure that Intents containing sensitive data have an\
    \ explicit receiver class set.\n\n\n## Example\nThe following example shows two\
    \ ways of broadcasting Intents. In the 'BAD' case, no \"receiver permission\"\
    \ is specified. In the 'GOOD' case, \"receiver permission\" or \"receiver application\"\
    \ is specified.\n\n\n```java\npublic void sendBroadcast1(Context context, String\
    \ token, String refreshToken) \n{\n    {\n        // BAD: broadcast sensitive\
    \ information to all listeners\n        Intent intent = new Intent();\n      \
    \  intent.setAction(\"com.example.custom_action\");\n        intent.putExtra(\"\
    token\", token);\n        intent.putExtra(\"refreshToken\", refreshToken);\n \
    \       context.sendBroadcast(intent);\n    }\n\n    {\n        // GOOD: broadcast\
    \ sensitive information only to those with permission\n        Intent intent =\
    \ new Intent();\n        intent.setAction(\"com.example.custom_action\");\n  \
    \      intent.putExtra(\"token\", token);\n        intent.putExtra(\"refreshToken\"\
    , refreshToken);\n        context.sendBroadcast(intent, \"com.example.user_permission\"\
    );\n    }\n\n    {\n        // GOOD: broadcast sensitive information to a specific\
    \ application\n        Intent intent = new Intent();\n        intent.setAction(\"\
    com.example.custom_action\");\n        intent.setClassName(\"com.example2\", \"\
    com.example2.UserInfoHandler\");\n        intent.putExtra(\"token\", token);\n\
    \        intent.putExtra(\"refreshToken\", refreshToken);\n        context.sendBroadcast(intent);\n\
    \    }\n}\n```\n\n## References\n* Android Developers: [Security considerations\
    \ and best practices for sending and receiving broadcasts](https://developer.android.com/guide/components/broadcasts)\n\
    * SonarSource: [Broadcasting intents is security-sensitive](https://rules.sonarsource.com/java/type/Security%20Hotspot/RSPEC-5320)\n\
    * Android Developer Fundamentals: [Restricting broadcasts](https://google-developer-training.github.io/android-developer-fundamentals-course-concepts-v2/unit-3-working-in-the-background/lesson-7-background-tasks/7-3-c-broadcasts/7-3-c-broadcasts.html)\n\
    * Carnegie Mellon University: [DRD03-J. Do not broadcast sensitive information\
    \ using an implicit intent](https://wiki.sei.cmu.edu/confluence/display/android/DRD03-J.+Do+not+broadcast+sensitive+information+using+an+implicit+intent)\n\
    * Android Developers: [Android LiveData Overview](https://developer.android.com/topic/libraries/architecture/livedata)\n\
    * Oversecured: [Interception of Android implicit intents](https://blog.oversecured.com/Interception-of-Android-implicit-intents/)\n\
    * Common Weakness Enumeration: [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-927/SensitiveResultReceiver.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-927/SensitiveResultReceiver.bqrs
  metadata:
    name: Leaking sensitive information through a ResultReceiver
    description: |-
      Sending sensitive data to a 'ResultReceiver' obtained from an untrusted source
                    can allow malicious actors access to your information.
    kind: path-problem
    problem.severity: error
    security-severity: 8.2
    precision: medium
    id: java/android/sensitive-result-receiver
    tags: |-
      security
             external/cwe/cwe-927
  queryHelp: "# Leaking sensitive information through a ResultReceiver\nIf a `ResultReceiver`\
    \ is obtained from an untrusted source, such as an `Intent` received by an exported\
    \ component, do not send it sensitive data. Otherwise, the information may be\
    \ leaked to a malicious application.\n\n\n## Recommendation\nDo not send sensitive\
    \ data to an untrusted `ResultReceiver`.\n\n\n## Example\nIn the following (bad)\
    \ example, sensitive data is sent to an untrusted `ResultReceiver`.\n\n\n```java\n\
    // BAD: Sensitive data is sent to an untrusted result receiver \nvoid bad(String\
    \ password) {\n    Intent intent = getIntent();\n    ResultReceiver rec = intent.getParcelableExtra(\"\
    Receiver\");\n    Bundle b = new Bundle();\n    b.putCharSequence(\"pass\", password);\n\
    \    rec.send(0, b); \n}\n```\n\n## References\n* Common Weakness Enumeration:\
    \ [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Security/CWE/CWE-940/AndroidIntentRedirection.ql
  relativeBqrsPath: codeql/java-queries/Security/CWE/CWE-940/AndroidIntentRedirection.bqrs
  metadata:
    name: Android Intent redirection
    description: |-
      Starting Android components with user-provided Intents
                    can provide access to internal components of the application,
                    increasing the attack surface and potentially causing unintended effects.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: java/android/intent-redirection
    tags: |-
      security
             external/cwe/cwe-926
             external/cwe/cwe-940
  queryHelp: "# Android Intent redirection\nAn exported Android component that obtains\
    \ a user-provided Intent and uses it to launch another component can be exploited\
    \ to obtain access to private, unexported components of the same app or to launch\
    \ other apps' components on behalf of the victim app.\n\n\n## Recommendation\n\
    Do not export components that start other components from a user-provided Intent.\
    \ They can be made private by setting the `android:exported` property to `false`\
    \ in the app's Android Manifest.\n\nIf this is not possible, restrict either which\
    \ apps can send Intents to the affected component, or which components can be\
    \ started from it.\n\n\n## Example\nThe following snippet contains three examples.\
    \ In the first example, an arbitrary component can be started from the externally\
    \ provided `forward_intent` Intent. In the second example, the destination component\
    \ of the Intent is first checked to make sure it is safe. In the third example,\
    \ the component that created the Intent is first checked to make sure it comes\
    \ from a trusted origin.\n\n\n```java\n// BAD: A user-provided Intent is used\
    \ to launch an arbitrary component\nIntent forwardIntent = (Intent) getIntent().getParcelableExtra(\"\
    forward_intent\");\nstartActivity(forwardIntent);\n\n// GOOD: The destination\
    \ component is checked before launching it\nIntent forwardIntent = (Intent) getIntent().getParcelableExtra(\"\
    forward_intent\");\nComponentName destinationComponent = forwardIntent.resolveActivity(getPackageManager());\n\
    if (destinationComponent.getPackageName().equals(\"safe.package\") && \n    destinationComponent.getClassName().equals(\"\
    SafeClass\")) {\n    startActivity(forwardIntent);\n}\n\n// GOOD: The component\
    \ that sent the Intent is checked before launching the destination component\n\
    Intent forwardIntent = (Intent) getIntent().getParcelableExtra(\"forward_intent\"\
    );\nComponentName originComponent = getCallingActivity();\nif (originComponent.getPackageName().equals(\"\
    trusted.package\") && originComponent.getClassName().equals(\"TrustedClass\"))\
    \ {\n    startActivity(forwardIntent);\n}\n\n```\n\n## References\n* Google: [Remediation\
    \ for Intent Redirection Vulnerability](https://support.google.com/faqs/answer/9267555?hl=en).\n\
    * OWASP Mobile Security Testing Guide: [Intents](https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05a-platform-overview#intents).\n\
    * Android Developers: [The android:exported attribute](https://developer.android.com/guide/topics/manifest/activity-element#exported).\n\
    * Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n\
    * Common Weakness Enumeration: [CWE-940](https://cwe.mitre.org/data/definitions/940.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/ExternalLibraryUsage.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/ExternalLibraryUsage.bqrs
  metadata:
    name: External libraries
    description: A list of external libraries used in the code
    kind: metric
    tags: summary telemetry
    id: java/telemetry/external-libs
  queryHelp: null
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/ExtractorInformation.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/ExtractorInformation.bqrs
  metadata:
    name: Java extraction information
    description: Information about the extraction for a Java database
    kind: metric
    tags: summary telemetry
    id: java/telemetry/extraction-information
  queryHelp: null
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/SupportedExternalApis.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/SupportedExternalApis.bqrs
  metadata:
    name: Usage of supported APIs coming from external libraries
    description: A list of supported 3rd party APIs used in the codebase. Excludes
      test and generated code.
    kind: metric
    tags: summary telemetry
    id: java/telemetry/supported-external-api
  queryHelp: null
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/SupportedExternalSinks.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/SupportedExternalSinks.bqrs
  metadata:
    name: Supported sinks in external libraries
    description: A list of 3rd party APIs detected as sinks. Excludes test and generated
      code.
    kind: metric
    tags: summary telemetry
    id: java/telemetry/supported-external-api-sinks
  queryHelp: null
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/SupportedExternalSources.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/SupportedExternalSources.bqrs
  metadata:
    name: Supported sources in external libraries
    description: A list of 3rd party APIs detected as sources. Excludes test and generated
      code.
    kind: metric
    tags: summary telemetry
    id: java/telemetry/supported-external-api-sources
  queryHelp: null
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/SupportedExternalTaint.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/SupportedExternalTaint.bqrs
  metadata:
    name: Supported flow steps in external libraries
    description: A list of 3rd party APIs detected as flow steps. Excludes test and
      generated code.
    kind: metric
    tags: summary telemetry
    id: java/telemetry/supported-external-api-taint
  queryHelp: null
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Telemetry/UnsupportedExternalAPIs.ql
  relativeBqrsPath: codeql/java-queries/Telemetry/UnsupportedExternalAPIs.bqrs
  metadata:
    name: Usage of unsupported APIs coming from external libraries
    description: A list of 3rd party APIs used in the codebase. Excludes test and
      generated code.
    kind: metric
    tags: summary telemetry
    id: java/telemetry/unsupported-external-api
  queryHelp: null
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Boxed Types/BoxedVariable.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Boxed Types/BoxedVariable.bqrs
  metadata:
    name: Boxed variable is never null
    description: |-
      Using a boxed type for a variable that is never assigned 'null'
                    hinders readability because it implies that 'null' is a potential value.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/non-null-boxed-variable
    tags: |-
      readability
             types
  queryHelp: |
    # Boxed variable is never null
    In Java all of the primitive types have boxed counterparts. The boxed types are objects and can therefore be `null`, whereas the primitive types can never be `null`. The names of the primitive and boxed types are similar except that primitive types start with a lower-case letter and boxed types start with an upper-case letter (also, for `char` and `int` the names of the boxed types are slightly longer, namely `Character` and `Integer`).

    Because the names are so similar and because Java performs automatic boxing and unboxing conversions, they can easily be confused. Furthermore, using a boxed type where a primitive type was intended leads to both readability issues and potentially superfluous allocation of objects.


    ## Recommendation
    If a variable is never assigned `null` it should use the primitive type, as this both directly shows the impossibility of `null` and also avoids unnecessary boxing and unboxing conversions.


    ## Example
    In the example below the variable `done` controls the loop exit. It is only set to `false` before the loop entry and set to `true` at some point during the loop iteration.


    ```java
    Boolean done = false;
    while (!done) {
      // ...
      done = true;
      // ...
    }

    ```
    Each of the assignments to `done` involves a boxing conversion and the check involves an unboxing conversion. Since `done` is never `null`, these conversions can be completely avoided, and the code made clearer, by using the primitive type instead. Therefore the code should be rewritten in the following way:


    ```java
    boolean done = false;
    while (!done) {
      // ...
      done = true;
      // ...
    }

    ```

    ## References
    * Java Language Specification: [Boxing Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.7), [Unboxing Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.8).
    * The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/CreatesEmptyZip.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/CreatesEmptyZip.bqrs
  metadata:
    name: Creates empty ZIP file entry
    description: |-
      Omitting a call to 'ZipOutputStream.write' when writing a ZIP file to an output
                    stream means that an empty ZIP file entry is written.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/empty-zip-file-entry
    tags: |-
      reliability
             readability
  queryHelp: "# Creates empty ZIP file entry\nThe `ZipOutputStream` class is used\
    \ to write ZIP files to a file or other stream. A ZIP file consists of a number\
    \ of *entries*. Usually each entry corresponds to a file in the directory structure\
    \ being zipped. There is a method on `ZipOutputStream` that is slightly confusingly\
    \ named `putNextEntry`. Despite its name, it does not write a whole entry. Instead,\
    \ it writes the *metadata* for an entry. The content for that entry is then written\
    \ using the `write` method. Finally the entry is closed using `closeEntry`.\n\n\
    Therefore, if you call `putNextEntry` and `closeEntry` but omit the call to `write`,\
    \ an empty ZIP file entry is written to the output stream.\n\n\n## Recommendation\n\
    Ensure that you include a call to `ZipOutputStream.write`.\n\n\n## Example\nIn\
    \ the following example, the `archive` method calls `putNextEntry` and `closeEntry`\
    \ but the call to `write` is left out.\n\n\n```java\nclass Archive implements\
    \ Closeable\n{\n\tprivate ZipOutputStream zipStream;\n\n\tpublic Archive(File\
    \ zip) throws IOException {\n\t\tOutputStream stream = new FileOutputStream(zip);\n\
    \t\tstream = new BufferedOutputStream(stream);\n\t\tzipStream = new ZipOutputStream(stream);\n\
    \t}\n\n\tpublic void archive(String name, byte[] content) throws IOException {\n\
    \t\tZipEntry entry = new ZipEntry(name);\n\t\tzipStream.putNextEntry(entry);\n\
    \t\t// Missing call to 'write'\n\t\tzipStream.closeEntry();\n\t}\n\n\tpublic void\
    \ close() throws IOException {\n\t\tzipStream.close();\n\t}\n}\n```\n\n## References\n\
    * Java API Specification: [ ZipOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/zip/ZipOutputStream.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/DeadRefTypes.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/DeadRefTypes.bqrs
  metadata:
    name: Unused classes and interfaces
    description: |-
      A non-public class or interface that is not used anywhere in the program wastes
                    programmer resources.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/unused-reference-type
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: |
    # Unused classes and interfaces
    A non-public class or interface that is not used anywhere in the program may cause a programmer to waste time and effort maintaining and documenting it.


    ## Recommendation
    Ensure that redundant types are removed from the program.


    ## References
    * Wikipedia: [Unreachable code](http://en.wikipedia.org/wiki/Unreachable_code).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/InterfaceCannotBeImplemented.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/InterfaceCannotBeImplemented.bqrs
  metadata:
    name: Interface cannot be implemented
    description: |-
      An interface method that is incompatible with a protected method on
                    'java.lang.Object' means that the interface cannot be implemented.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/unimplementable-interface
    tags: |-
      maintainability
             useless-code
  queryHelp: |
    # Interface cannot be implemented
    An interface that contains methods whose return types clash with protected methods on `java.lang.Object` can never be implemented, because methods cannot be overloaded based simply on their return type.


    ## Recommendation
    If the interface is useful, name methods so that they do not clash with methods in `Object`. Otherwise you should delete the interface.


    ## Example
    In the following example, the interface `I` is useless because the `clone` method must return type `java.lang.Object`:


    ```java
    interface I {
        int clone();
    }

    class C implements I {
        public int clone() {
            return 23;
        }
    }
    ```
    Any attempt to implement the interface produces an error:

    ```

    InterfaceCannotBeImplemented.java:6: clone() in C cannot override
      clone() in java.lang.Object; attempting to use incompatible return
      type
    found   : int
    required: java.lang.Object
      public int clone() {
                 ^
    1 error

    ```

    ## References
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * Java Language Specification: [9.2 Interface Members](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.2).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/UnreadLocal.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/UnreadLocal.bqrs
  metadata:
    name: Unread local variable
    description: A local variable that is never read is redundant.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/local-variable-is-never-read
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Unread local variable\nA local variable that is never read is useless.\n\
    \nAs a matter of good practice, there should be no unused or useless code. It\
    \ makes the program more difficult to understand and maintain, and can waste a\
    \ programmer's time.\n\n\n## Recommendation\nThis rule applies to variables that\
    \ are never used as well as variables that are only written to but never read.\
    \ In both cases, ensure that no operations are missing that would use the local\
    \ variable. If appropriate, simply remove the declaration. However, if the variable\
    \ is written to, ensure that any side-effects in the assignments are retained.\
    \ (For further details, see the example.)\n\n\n## Example\nIn the following example,\
    \ the local variable `oldQuantity` is assigned a value but never read. In the\
    \ fixed version of the example, the variable is removed but the call to `items.put`\
    \ in the assignment is retained.\n\n\n```java\n// Version containing unread local\
    \ variable\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\t\
    public void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity\
    \ = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\tInteger oldQuantity\
    \ = items.put(i, quantity);  // AVOID: Unread local variable\n\t}\n}\n\n// Version\
    \ with unread local variable removed\npublic class Cart {\n\tprivate Map<Item,\
    \ Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\
    \t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\
    \titems.put(i, quantity);\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform:\
    \ [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Dead Code/UnusedLabel.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Dead Code/UnusedLabel.bqrs
  metadata:
    name: Unused label
    description: |-
      An unused label for a loop or 'switch' statement is either redundant or indicates
                    incorrect 'break' or 'continue' statements.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/unused-label
    tags: |-
      maintainability
             useless-code
             external/cwe/cwe-561
  queryHelp: "# Unused label\nLoop and `switch` statements can be labeled. These labels\
    \ can serve as targets for `break` or `continue` statements, to specify which\
    \ loop or `switch` statement they refer to.\n\nApart from serving as such jump\
    \ targets, the labels have no effect on program behavior, which means that having\
    \ an unused label is suspicious.\n\n\n## Recommendation\nIf the label is used\
    \ to document the intended behavior of a loop or `switch` statement, remove it.\
    \ It is better to use comments for this purpose. However, an unused label may\
    \ indicate that something is wrong: that some of the nested `break` or `continue`\
    \ statements should be using the label. In this case, the current control flow\
    \ is probably wrong, and you should adjust some jumps to use the label after checking\
    \ the desired behavior.\n\n\n## Example\nThe following example uses a loop and\
    \ a nested loop to check whether any of the currently active shopping carts contains\
    \ a particular item. On line 4, the `carts:` label is unused. Inspecting the code,\
    \ we can see that the `break` statement on line 10 is inefficient because it only\
    \ breaks out of the nested loop. It could in fact break out of the outer loop,\
    \ which should improve performance in common cases. By changing the statement\
    \ on line 10 to read `break carts;`, the label is no longer unused and we improve\
    \ the code.\n\n\n```java\npublic class WebStore {\n\tpublic boolean itemIsBeingBought(Item\
    \ item) {\n\t\tboolean found = false;\n\t\tcarts:  // AVOID: Unused label\n\t\t\
    for (int i = 0; i < carts.size(); i++) {\n\t\t\tCart cart = carts.get(i);\n\t\t\
    \tfor (int j = 0; j < cart.numItems(); j++) {\n\t\t\t\tif (item.equals(cart.getItem(j)))\
    \ {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\
    return found;\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java\
    \ Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Declarations/NoConstantsOnly.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Declarations/NoConstantsOnly.bqrs
  metadata:
    name: Constant interface anti-pattern
    description: |-
      Implementing an interface (or extending an abstract class)
                    only to put a number of constant definitions into scope is considered bad practice.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/constants-only-interface
    tags: |-
      maintainability
             modularity
  queryHelp: "# Constant interface anti-pattern\nDefinitions of constants (meaning\
    \ static, final fields) should be placed in an appropriate class where they belong\
    \ logically. However, it is usually bad practice to implement an interface (or\
    \ extend an abstract class) only to put a number of constant definitions into\
    \ scope.\n\n\n## Recommendation\nThe preferred way of putting the constant definitions\
    \ into scope is to use the `import static` directive, which allows a compilation\
    \ unit to put any visible static members from other classes into scope.\n\nThis\
    \ issue is discussed in \\[Bloch\\]:\n\n> That a class uses some constants internally\
    \ is an implementation detail. Implementing a constant interface causes this implementation\
    \ detail to leak into the classes exported API. It is of no consequence to the\
    \ users of a class that the class implements a constant interface. In fact, it\
    \ may even confuse them. Worse, it represents a commitment: if in a future release\
    \ the class is modified so that it no longer needs to use the constants, it still\
    \ must implement the interface to ensure binary compatibility.\n\nTo prevent this\
    \ pollution of a class's binary interface, it is best to move the constant definitions\
    \ to whatever concrete class uses them most frequently. Users of the definitions\
    \ could use `import static` to access the relevant fields.\n\n\n## Example\nIn\
    \ the following example, the interface `MathConstants` has been defined only to\
    \ hold a constant.\n\n\n```java\npublic class NoConstantsOnly {\n\tstatic interface\
    \ MathConstants\n\t{\n\t    public static final Double Pi = 3.14;\n\t}\n\n\tstatic\
    \ class Circle implements MathConstants\n\t{\n\t    public double radius;\n\t\
    \    public double area()\n\t    {\n\t        return Math.pow(radius, 2) * Pi;\n\
    \t    }\n\t}\n}\n```\nInstead, the constant should be moved to the `Circle` class\
    \ or another class that uses the constant frequently.\n\n\n## References\n* J.\
    \ Bloch, *Effective Java (second edition)*, Item 19. Addison-Wesley, 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Exception Handling/IgnoreExceptionalReturn.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Exception Handling/IgnoreExceptionalReturn.bqrs
  metadata:
    name: Ignored error status of call
    description: |-
      Ignoring an exceptional value that is returned by a method may cause subsequent
                    code to fail.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/ignored-error-status-of-call
    tags: |-
      reliability
             correctness
             external/cwe/cwe-391
  queryHelp: |
    # Ignored error status of call
    Many methods in the Java Development Kit (for examples, see the references below) return status values (for example, as an `int`) to indicate whether the method execution finished normally. They may return an error code if the method did not finish normally. If the method result is not checked, exceptional method executions may cause subsequent code to fail.


    ## Recommendation
    You should insert additional code to check the return value and take appropriate action.


    ## Example
    The following example uses the `java.io.InputStream.read` method to read 16 bytes from an input stream and store them in an array. However, `read` may not actually be able to read as many bytes as requested, for example because the stream is exhausted. Therefore, the code should not simply rely on the array `b` being filled with precisely 16 bytes from the input stream. Instead, the code should check the method's return value, which indicates the number of bytes actually read.


    ```java
    java.io.InputStream is = (...);
    byte[] b = new byte[16];
    is.read(b);
    ```

    ## References
    * SEI CERT Oracle Coding Standard for Java: [ EXP00-J. Do not ignore values returned by methods](https://wiki.sei.cmu.edu/confluence/display/java/EXP00-J.+Do+not+ignore+values+returned+by+methods).
    * Java API Specification: [ java.util.Queue.offer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Queue.html#offer(E)).
    * Java API Specification: [ java.util.concurrent.BlockingQueue.offer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/BlockingQueue.html#offer(E,long,java.util.concurrent.TimeUnit)).
    * Java API Specification, java.util.concurrent.locks.Condition: [ await](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html#await(long,java.util.concurrent.TimeUnit)), [ awaitUntil](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html#awaitUntil(java.util.Date)), [ awaitNanos](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html#awaitNanos(long)).
    * Java API Specification, java.io.File: [ createNewFile](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#createNewFile()), [ delete](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#delete()), [ mkdir](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#mkdir()), [ renameTo](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#renameTo(java.io.File)), [ setLastModified](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setLastModified(long)), [ setReadOnly](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setReadOnly()), [ setWritable(boolean)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setWritable(boolean)), [ setWritable(boolean, boolean)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setWritable(boolean,boolean)).
    * Java API Specification, java.io.InputStream: [ skip](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html#skip(long)), [ read(byte\[\])](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html#read(byte%5B%5D)), [ read(byte\[\], int, int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html#read(byte[],int,int)).
    * Common Weakness Enumeration: [CWE-391](https://cwe.mitre.org/data/definitions/391.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Exception Handling/NumberFormatException.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Exception Handling/NumberFormatException.bqrs
  metadata:
    name: Missing catch of NumberFormatException
    description: |-
      Calling a string to number conversion method without handling
                    'NumberFormatException' may cause unexpected runtime exceptions.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/uncaught-number-format-exception
    tags: |-
      reliability
             external/cwe/cwe-248
  queryHelp: "# Missing catch of NumberFormatException\nMethods such as `Integer.parseInt`\
    \ that parse strings into numbers throw `NumberFormatException` if their arguments\
    \ cannot be parsed. This exception should be caught so that any parse errors can\
    \ be handled.\n\n\n## Recommendation\nIt is usually best to handle `NumberFormatException`\
    \ in a `catch` clause surrounding the call to the parsing method.\n\n\n## Example\n\
    In the following example, the first call to `Integer.parseInt` does not catch\
    \ the exception. The second call does.\n\n\n```java\nString s = ...;\nint n;\n\
    \nn = Integer.parseInt(s); // BAD: NumberFormatException is not caught.\n\ntry\
    \ {\n        n = Integer.parseInt(s);\n} catch (NumberFormatException e) {  //\
    \ GOOD: The exception is caught. \n        // Handle the exception\n}\n\n```\n\
    \n## References\n* Java API Specification: [Integer.valueOf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#valueOf(java.lang.String)),\
    \ [Integer.parseInt](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#parseInt(java.lang.String)),\
    \ [Long.parseLong](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html#parseLong(java.lang.String)),\
    \ [NumberFormatException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NumberFormatException.html).\n\
    * Common Weakness Enumeration: [CWE-248](https://cwe.mitre.org/data/definitions/248.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Implementation Hiding/AbstractToConcreteCollection.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Implementation
    Hiding/AbstractToConcreteCollection.bqrs
  metadata:
    name: Cast from abstract to concrete collection
    description: |-
      A cast from an abstract collection to a concrete implementation type makes the
                    code brittle.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/abstract-to-concrete-cast
    tags: |-
      reliability
             maintainability
             modularity
             external/cwe/cwe-485
  queryHelp: "# Cast from abstract to concrete collection\nMost collections in the\
    \ Java standard library are defined by an abstract interface (for example `java.util.List`\
    \ or `java.util.Set`), which is implemented by a range of concrete classes and\
    \ a range of wrappers. Normally, except when constructing an object, it is better\
    \ to use the abstract types because this avoids assumptions about what the implementation\
    \ is.\n\nA cast from an abstract to a concrete collection makes the code brittle\
    \ by ensuring it works only for one possible implementation class and not others.\
    \ Usually, such casts are either an indication of over-reliance on concrete implementation\
    \ types, or of the fact that the wrong abstract type was used.\n\n\n## Recommendation\n\
    It is usually best to use the abstract type consistently in variable, field and\
    \ parameter declarations.\n\nThere may be individual exceptions. For example,\
    \ it is common to declare variables as `LinkedHashSet` rather than `Set` when\
    \ the iteration order matters and only the `LinkedHashSet` implementation provides\
    \ the right behavior.\n\n\n## Example\nThe following example illustrates a situation\
    \ where the wrong abstract type is used. The `List` interface does not provide\
    \ a `poll` method, so the original code casts `queue` down to the concrete type\
    \ `LinkedList`, which does. To avoid this downcasting, simply use the correct\
    \ abstract type for this method, namely `Queue`. This documents the intent of\
    \ the programmer and allows for various implementations of queues to be used by\
    \ clients of this method.\n\n\n```java\nCustomer getNext(List<Customer> queue)\
    \ {\n\tif (queue == null)\n\t\treturn null;\n\tLinkedList<Customer> myQueue =\
    \ (LinkedList<Customer>)queue;  // AVOID: Cast to concrete type.\n\treturn myQueue.poll();\n\
    }\n\nCustomer getNext(Queue<Customer> queue) {\n\tif (queue == null)\n\t\treturn\
    \ null;\n\treturn queue.poll();  // GOOD: Use abstract type.\n}\n\n```\n\n## References\n\
    * J. Bloch, *Effective Java (second edition)*, Item 52. Addison-Wesley, 2008.\n\
    * Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html).\n\
    * Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Implementation Hiding/ExposeRepresentation.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Implementation
    Hiding/ExposeRepresentation.bqrs
  metadata:
    name: Exposing internal representation
    description: |-
      An object that accidentally exposes its internal representation may allow the
                    object's fields to be modified in ways that the object is not prepared to handle.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/internal-representation-exposure
    tags: |-
      reliability
             maintainability
             modularity
             external/cwe/cwe-485
  queryHelp: "# Exposing internal representation\nA subtle type of defect is caused\
    \ when an object accidentally exposes its internal representation to the code\
    \ outside the object, and the internal representation is then (deliberately or\
    \ accidentally) modified in ways that the object is not prepared to handle. Most\
    \ commonly, this happens when a getter returns a direct reference to a mutable\
    \ field within the object, or a setter just assigns a mutable argument to its\
    \ field.\n\n\n## Recommendation\nThere are three ways of addressing this problem:\n\
    \n* **Using immutable objects** : The fields store objects that are *immutable*,\
    \ which means that once constructed their value can never be changed. Examples\
    \ from the standard library are `String`, `Integer` or `Float`. Although such\
    \ an object may be aliased, or shared between several contexts, there can be no\
    \ unexpected changes to the internal state of the object because it cannot be\
    \ modified.\n* **Creating a read-only view** : The `java.util.Collections.unmodifiable*`\
    \ methods can be used to create a read-only view of a collection without copying\
    \ it. This tends to give better performance than creating copies of objects. Note\
    \ that this technique is not suitable for every situation, because any changes\
    \ to the underlying collection will spread to affect the view. This can lead to\
    \ unexpected results, and is a particular danger when writing multi-threaded code.\n\
    * **Making defensive copies** : Each setter (or constructor) makes a copy or clone\
    \ of the incoming parameter. In this way, it constructs an instance known only\
    \ internally, and no matter what happens with the object that was passed in, the\
    \ state stays consistent. Conversely, each getter for a field must also construct\
    \ a copy of the field's value to return.\n\n## Example\nIn the following example,\
    \ the private field `items` is returned directly by the getter `getItems`. Thus,\
    \ a caller obtains a reference to internal object state and can manipulate the\
    \ collection of items in the cart. In the example, each of the carts is emptied\
    \ when `countItems` is called.\n\n\n```java\npublic class Cart {\n\tprivate Set<Item>\
    \ items;\n\t// ...\n\t// AVOID: Exposes representation\n\tpublic Set<Item> getItems()\
    \ {\n\t\treturn items;\n\t}\n}\n....\nint countItems(Set<Cart> carts) {\n\tint\
    \ result = 0;\n\tfor (Cart cart : carts) {\n\t\tSet<Item> items = cart.getItems();\n\
    \t\tresult += items.size();\n\t\titems.clear(); // AVOID: Changes internal representation\n\
    \t}\n\treturn result;\n}\n```\nThe solution is for `getItems` to return a *copy*\
    \ of the actual field, for example `return new HashSet<Item>(items);`.\n\n\n##\
    \ References\n* J. Bloch, *Effective Java (second edition)*, Items 15 and 39.\
    \ Addison-Wesley, 2008.\n* Java API Specification: [Collections](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html).\n\
    * Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Implementation Hiding/GetClassGetResource.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Implementation
    Hiding/GetClassGetResource.bqrs
  metadata:
    name: Unsafe use of getResource
    description: |-
      Calling 'this.getClass().getResource()' may yield unexpected results if called from a
                    subclass in another package.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/unsafe-get-resource
    tags: |-
      reliability
             maintainability
  queryHelp: |
    # Unsafe use of getResource
    Using the `Class.getResource` method is a common way of including some non-code resources with an application.

    There are problems when this is called using `x.getClass().getResource()`, for some variable `x`. This is not a safe way to retrieve a resource. The method `getClass` returns the *run-time* class of `x` (that is, its actual, "most derived" class, rather than its declared type), which causes two potential problems:

    * If the run-time type of the receiving object is a subclass of the declared type and is in a different package, the resource path may be interpreted differently. According to its contract, `Class.getResource` qualifies non-absolute paths with the current package name, thus potentially returning a different resource or failing to find the requested resource.
    * `Class.getResource` delegates finding the resource to the class loader that loaded the class. At run time, there is no guarantee that all subclasses of a particular type are loaded by the same class loader, resulting in resource lookup failures that are difficult to diagnose.

    ## Recommendation
    Rather than using the `getClass` method, which relies on dynamic dispatch and run-time types, use `class` literals instead. For example, instead of calling `getClass().getResource()` on an object of type `Foo`, call `Foo.class.getResource()`. Class literals always refer to the declared type they are used on, removing the dependency on run-time types.


    ## Example
    In the following example, the calls to `getPostalCodes` return different results, depending on which class the call is made on: the class `Address` is in the package `framework` and the class `UKAddress` is in the package `client`.


    ```java
    package framework;
    class Address {
        public URL getPostalCodes() {
            // AVOID: The call is made on the run-time type of 'this'.
            return this.getClass().getResource("postal-codes.csv");
        }
    }

    package client;
    class UKAddress extends Address {
        public void convert() {
            // Looks up "framework/postal-codes.csv"
            new Address().getPostalCodes();
            // Looks up "client/postal-codes.csv"
            new UKAddress().getPostalCodes();
        }
    }
    ```
    In the following corrected example, the implementation of `getPostalCodes` is changed so that it always calls `getResource` on the same class.


    ```java
    package framework;
    class Address {
        public URL getPostalCodes() {
            // GOOD: The call is always made on an object of the same type.
            return Address.class.getResource("postal-codes.csv");
        }
    }

    package client;
    class UKAddress extends Address {
        public void convert() {
            // Looks up "framework/postal-codes.csv"
            new Address().getPostalCodes();
            // Looks up "framework/postal-codes.csv"
            new UKAddress().getPostalCodes();
        }
    }
    ```

    ## References
    * Java API Specification: [Class.getResource()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#getResource(java.lang.String)).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/AmbiguousOuterSuper.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/AmbiguousOuterSuper.bqrs
  metadata:
    name: Subtle call to inherited method
    description: |-
      An unqualified call to a method that exists with the same signature in both a
                    superclass and an outer class is ambiguous.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: java/subtle-inherited-call
    tags: |-
      reliability
             readability
  queryHelp: "# Subtle call to inherited method\nIf a call is made to a method from\
    \ an inner class A, and a method of that name is defined in both a superclass\
    \ of A and an outer class of A, it is not clear to a programmer which method is\
    \ intended to be called.\n\n\n## Example\nIn the following example, it is not\
    \ clear whether the call to `printMessage` calls the method that is defined in\
    \ `Outer` or `Super`.\n\n\n```java\npublic class Outer\n{\n\tvoid printMessage()\
    \ {\n\t\tSystem.out.println(\"Outer\");\n\t}\n\t\n\tclass Inner extends Super\n\
    \t{\n\t\tvoid ambiguous() {\n\t\t\tprintMessage();  // Ambiguous call\n\t\t}\n\
    \t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Outer().new Inner().ambiguous();\n\
    \t}\n}\n\nclass Super\n{\n\tvoid printMessage() {\n\t\tSystem.out.println(\"Super\"\
    );\n\t}\n}\n\n```\nInherited methods take precedence over methods in outer classes,\
    \ so the method in the superclass is called. However, such situations are a potential\
    \ cause of confusion and defects.\n\n\n## Recommendation\nResolve the ambiguity\
    \ by explicitly qualifying the method call:\n\n* To specify the outer class, prefix\
    \ the method with `Outer.this.`.\n* To specify the superclass, prefix the method\
    \ with `super.`.\nIn the above example, the call to `printMessage` could be replaced\
    \ by either `Outer.this.printMessage` or `super.printMessage`, depending on which\
    \ method you intend to call. To preserve the behavior in the example, use `super.printMessage`.\n\
    \n\n## References\n* Inner Classes Specification: [What are top-level classes\
    \ and inner classes?](http://www.cis.upenn.edu/~bcpierce/courses/629/jdkdocs/guide/innerclasses/spec/innerclasses.doc1.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/ConfusingMethodNames.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/ConfusingMethodNames.bqrs
  metadata:
    name: Confusing method names because of capitalization
    description: |-
      Methods in the same class whose names differ only in capitalization are
                    confusing.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/confusing-method-name
    tags: |-
      maintainability
             readability
             naming
  queryHelp: "# Confusing method names because of capitalization\nIt is bad practice\
    \ to have methods in a class with names that differ only in their capitalization.\
    \ This can be confusing and lead to mistakes.\n\n\n## Recommendation\nName the\
    \ methods to make the distinction between them clear.\n\n\n## Example\nThe following\
    \ example shows a class that contains two methods: `toUri` and `toURI`. One or\
    \ both of them should be renamed.\n\n\n```java\npublic class InternetResource\n\
    {\n\tprivate String protocol;\n\tprivate String host;\n\tprivate String path;\n\
    \n\t// ...\n\n\tpublic String toUri() {\n\t\treturn protocol + \"://\" + host\
    \ + \"/\" + path;\n\t}\n\n\t// ...\n\n\tpublic String toURI() {\n\t\treturn toUri();\n\
    \t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile\
    \ Software Craftsmanship*, 17.N4. Prentice Hall, 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/ConfusingOverloading.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/ConfusingOverloading.bqrs
  metadata:
    name: Confusing overloading of methods
    description: |-
      Overloaded methods that have the same number of parameters, where each pair of
                    corresponding parameter types is convertible by casting or autoboxing, may be
                    confusing.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/confusing-method-signature
    tags: |-
      maintainability
             readability
             naming
  queryHelp: |
    # Confusing overloading of methods
    Overloaded method declarations that have the same number of parameters may be confusing if none of the corresponding pairs of parameter types is substantially different. A pair of parameter types A and B is substantially different if A cannot be cast to B and B cannot be cast to A. If the parameter types are not substantially different then the programmer may assume that the method with parameter type A is called when in fact the method with parameter type B is called.


    ## Recommendation
    It is generally best to avoid declaring overloaded methods with the same number of parameters, unless at least one of the corresponding parameter pairs is substantially different.


    ## Example
    Declaring overloaded methods `process(Object obj)` and `process(String s)` is confusing because the parameter types are not substantially different. It is clearer to declare methods with different names: `processObject(Object obj)` and `processString(String s)`.

    In contrast, declaring overloaded methods `process(Object obj, String s)` and `process(String s, int i)` is not as confusing because the second parameters of each method are substantially different.


    ## References
    * J. Bloch, *Effective Java (second edition)*, Item 41. Addison-Wesley, 2008.
    * Java Language Specification: [15.12 Method Invocation Expressions](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/FieldMasksSuperField.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/FieldMasksSuperField.bqrs
  metadata:
    name: Field masks field in super class
    description: |-
      Hiding a field in a superclass by redeclaring it in a subclass might be
                    unintentional, especially if references to the hidden field are not qualified using
                    'super'.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/field-masks-super-field
    tags: |-
      maintainability
             readability
  queryHelp: |
    # Field masks field in super class
    A field that has the same name as a field in a superclass *hides* the field in the superclass. Such hiding might be unintentional, especially if there are no references to the hidden field using the `super` qualifier. In any case, it makes code more difficult to read.


    ## Recommendation
    Ensure that any hiding is intentional. For clarity, it may be better to rename the field in the subclass.


    ## Example
    In the following example, the programmer unintentionally added an `age` field to `Employee`, which hides the `age` field in `Person`. The constructor in `Person` sets the `age ` field in `Person` to 20 but the `age` field in `Employee` is still 0. This means that the program outputs 0, which is probably not what was intended.


    ```java
    public class FieldMasksSuperField {
        static class Person {
            protected int age;
            public Person(int age)
            {
                this.age = age;
            }
        }

        static class Employee extends Person {
            protected int age;  // This field hides 'Person.age'.
            protected int numberOfYearsEmployed;
            public Employee(int age, int numberOfYearsEmployed)
            {
                super(age);
                this.numberOfYearsEmployed = numberOfYearsEmployed;
            }
        }

        public static void main(String[] args) {
            Employee e = new Employee(20, 2);
            System.out.println(e.age);
        }
    }
    ```
    To fix this, delete the declaration of `age` on line 11.


    ## References
    * Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).
    * The Java Tutorials: [Hiding Fields](https://docs.oracle.com/javase/tutorial/java/IandI/hidevariables.html).
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/LocalShadowsFieldConfusing.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/LocalShadowsFieldConfusing.bqrs
  metadata:
    name: Possible confusion of local and field
    description: |-
      A method in which a variable is declared with the same name as a field is difficult
                    to understand.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/local-shadows-field
    tags: |-
      maintainability
             readability
  queryHelp: "# Possible confusion of local and field\nIf a method declares a local\
    \ variable with the same name as a field, then it is very easy to mix up the two\
    \ when reading or modifying the program.\n\n\n## Recommendation\nConsider using\
    \ different names for the field and local variable to make the difference between\
    \ them clear.\n\n\n## Example\nThe following example shows a local variable `values`\
    \ that has the same name as a field.\n\n\n```java\npublic class Container\n{\n\
    \tprivate int[] values; // Field called 'values'\n\t\n\tpublic Container (int...\
    \ values) {\n\t\tthis.values = values;\n\t}\n\n\tpublic Container dup() {\n\t\t\
    int length = values.length;\n\t\tint[] values = new int[length];  // Local variable\
    \ called 'values'\n\t\tContainer result = new Container(values);\n\t\treturn result;\n\
    \t}\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings\
    \ Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n\
    * Java Language Specification: [ 6.4 Shadowing and Obscuring](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Naming Conventions/SameNameAsSuper.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Naming Conventions/SameNameAsSuper.bqrs
  metadata:
    name: Class has same name as super class
    description: A class that has the same name as its superclass may be confusing.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/class-name-matches-super-class
    tags: |-
      maintainability
             readability
             naming
  queryHelp: "# Class has same name as super class\nA class that has the same name\
    \ as its superclass may be confusing.\n\n\n## Recommendation\nClarify the difference\
    \ between the subclass and the superclass by using different names.\n\n\n## Example\n\
    In the following example, it is not clear that the `attendees` field refers to\
    \ the inner class `Attendees` and not the class `com.company.util.Attendees`.\n\
    \n\n```java\nimport com.company.util.Attendees;\n\npublic class Meeting\n{\n\t\
    private Attendees attendees;\n\n\t// ...\n\t// Many lines\n\t// ...\n\n\t// AVOID:\
    \ This class has the same name as its superclass.\n\tprivate static class Attendees\
    \ extends com.company.util.Attendees\n\t{\n\t\t// ...\n\t}\n}\n```\nTo fix this,\
    \ the inner class should be renamed.\n\n\n## References\n* R. C. Martin, *Clean\
    \ Code: A Handbook of Agile Software Craftsmanship*, &sect;17.N4. Prentice Hall,\
    \ 2008.\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Undesirable Calls/CallsToRunFinalizersOnExit.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Undesirable Calls/CallsToRunFinalizersOnExit.bqrs
  metadata:
    name: Dangerous runFinalizersOnExit
    description: |-
      Calling 'System.runFinalizersOnExit' or 'Runtime.runFinalizersOnExit'
                    may cause finalizers to be run on live objects, leading to erratic behavior or
                    deadlock.
    kind: problem
    problem.severity: error
    precision: medium
    id: java/run-finalizers-on-exit
    tags: |-
      reliability
             maintainability
  queryHelp: "# Dangerous runFinalizersOnExit\nAvoid calling `System.runFinalizersOnExit`\
    \ or `Runtime.runFinalizersOnExit`, which are considered to be dangerous methods.\n\
    \nThe Java Development Kit documentation for `System.runFinalizersOnExit` states:\n\
    \n> This method is inherently unsafe. It may result in finalizers being called\
    \ on live objects while other threads are concurrently manipulating those objects,\
    \ resulting in erratic behavior or deadlock.\n\nObject finalizers are normally\
    \ only called when the object is about to be collected by the garbage collector.\
    \ Using `runFinalizersOnExit` sets a Java Virtual Machine-wide flag that executes\
    \ finalizers *on all objects with a `finalize` method* before the runtime exits.\
    \ This would require all objects with finalizers to defend against the possibility\
    \ of `finalize` being called when the object is still in use, which is not practical\
    \ for most applications.\n\n\n## Recommendation\nEnsure that the code does not\
    \ rely on the execution of finalizers. If the code is dependent on the garbage\
    \ collection behavior of the Java Virtual Machine, there is no guarantee that\
    \ finalizers will be executed in a timely manner, or at all. This may become a\
    \ problem if finalizers are used to dispose of limited system resources, such\
    \ as file handles.\n\nInstead of finalizers, use explicit `dispose` methods in\
    \ `finally` blocks, to make sure that an object's resources are released.\n\n\n\
    ## Example\nThe following example shows a program that calls `runFinalizersOnExit`,\
    \ which is not recommended.\n\n\n```java\nvoid main() {\n\t// ...\n\t// BAD: Call\
    \ to 'runFinalizersOnExit' forces execution of all finalizers on termination of\
    \ \n\t// the runtime, which can cause live objects to transition to an invalid\
    \ state.\n\t// Avoid using this method (and finalizers in general).\n\tSystem.runFinalizersOnExit(true);\n\
    \t// ...\n}\n```\nThe following example shows the recommended approach: a program\
    \ that calls a `dispose` method in a `finally` block.\n\n\n```java\n// Instead\
    \ of using finalizers, define explicit termination methods \n// and call them\
    \ in 'finally' blocks.\nclass LocalCache {\n\tprivate Collection<File> cacheFiles\
    \ = ...;\n\t\n\t// Explicit method to close all cacheFiles\n\tpublic void dispose()\
    \ {\n\t\tfor (File cacheFile : cacheFiles) {\n\t\t\tdisposeCacheFile(cacheFile);\n\
    \t\t}\n\t}\n}\n\nvoid main() {\n\tLocalCache cache = new LocalCache();\n\ttry\
    \ {\n\t\t// Use the cache\n\t} finally {\n\t\t// Call the termination method in\
    \ a 'finally' block, to ensure that\n\t\t// the cache's resources are freed. \n\
    \t\tcache.dispose();\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java\
    \ (second edition)*, Item 7. Addison-Wesley, 2008.\n* Java API Specification:\
    \ [System.runFinalizersOnExit()](https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#runFinalizersOnExit-boolean-),\
    \ [Object.finalize()](https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#finalize--).\n\
    * Java API Specification: [Java Thread Primitive Deprecation](https://docs.oracle.com/javase/10/docs/api/java/lang/doc-files/threadPrimitiveDeprecation.html).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Undesirable Calls/CallsToStringToString.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Undesirable Calls/CallsToStringToString.bqrs
  metadata:
    name: Useless toString on String
    description: Calling 'toString' on a string is redundant.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/useless-tostring-call
    tags: maintainability
  queryHelp: "# Useless toString on String\nThere is no need to call `toString` on\
    \ a `String` because it just returns the object itself. From the Java API Specification\
    \ entry for `String.toString()`:\n\n> `public String toString()`\n\nThis object\
    \ (which is already a string!) is itself returned.\n\n\n## Recommendation\nDo\
    \ not call `toString` on a `String` object.\n\n\n## Example\nThe following example\
    \ shows an unnecessary call to `toString` on the string `name`.\n\n\n```java\n\
    public static void main(String args[]) {\n\tString name = \"John Doe\";\n\t\n\t\
    // BAD: Unnecessary call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my\
    \ name is \" + name.toString());\n\t\n\t// GOOD: No call to 'toString' on 'name'\n\
    \tSystem.out.println(\"Hi, my name is \" + name);\n}\n```\n\n## References\n*\
    \ Java API Specification: [String.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#toString()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Undesirable Calls/DefaultToString.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Undesirable Calls/DefaultToString.bqrs
  metadata:
    name: Use of default toString()
    description: |-
      Calling the default implementation of 'toString' returns a value that is unlikely to
                    be what you expect.
    kind: problem
    problem.severity: recommendation
    precision: high
    id: java/call-to-object-tostring
    tags: |-
      reliability
             maintainability
  queryHelp: "# Use of default toString()\nIn most cases, calling the default implementation\
    \ of `toString` in `java.lang.Object` is not what is intended when a string representation\
    \ of an object is required. The output of the default `toString` method consists\
    \ of the class name of the object as well as the object's hashcode, which is usually\
    \ not what was intended.\n\nThis rule includes explicit and implicit calls to\
    \ `toString` that resolve to `java.lang.Object.toString`, particularly calls that\
    \ are used in print or log statements.\n\n\n## Recommendation\nFor objects that\
    \ are printed, define a `toString` method for the object that returns a human-readable\
    \ string.\n\n\n## Example\nThe following example shows that printing an object\
    \ makes an implicit call to `toString`. Because the class `WrongPerson` does not\
    \ have a `toString` method, `Object.toString` is called instead, which returns\
    \ the class name and the `wp` object's hashcode.\n\n\n```java\n// This class does\
    \ not have a 'toString' method, so 'java.lang.Object.toString'\n// is used when\
    \ the class is converted to a string.\nclass WrongPerson {\n\tprivate String name;\n\
    \tprivate Date birthDate; \n\t\n\tpublic WrongPerson(String name, Date birthDate)\
    \ {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static\
    \ void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new\
    \ SimpleDateFormat(\"yyyy-MM-dd\");\n\tWrongPerson wp = new WrongPerson(\"Robert\
    \ Van Winkle\", dateFormatter.parse(\"1967-10-31\"));\n\n\t// BAD: The following\
    \ statement implicitly calls 'Object.toString', \n\t// which returns something\
    \ similar to:\n\t// WrongPerson@4383f74d\n\tSystem.out.println(wp);\n}\n```\n\
    In contrast, in the following modification of the example, the class `Person`\
    \ does have a `toString` method, which returns a string containing the arguments\
    \ that were passed when the object `p` was created.\n\n\n```java\n// This class\
    \ does have a 'toString' method, which is used when the object is\n// converted\
    \ to a string.\nclass Person {\n\tprivate String name;\n\tprivate Date birthDate;\n\
    \t\n\tpublic String toString() {\n\t\tDateFormat dateFormatter = new SimpleDateFormat(\"\
    yyyy-MM-dd\");\n\t\treturn \"(Name: \" + name + \", Birthdate: \" + dateFormatter.format(birthDate)\
    \ + \")\";\n\t}\n\t\n\tpublic Person(String name, Date birthDate) {\n\t\tthis.name\
    \ =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String\
    \ args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"\
    yyyy-MM-dd\");\n\tPerson p = new Person(\"Eric Arthur Blair\", dateFormatter.parse(\"\
    1903-06-25\"));\n\n\t// GOOD: The following statement implicitly calls 'Person.toString',\
    \ \n\t// which correctly returns a human-readable string:\n\t// (Name: Eric Arthur\
    \ Blair, Birthdate: 1903-06-25)\n\tSystem.out.println(p);\n}\n```\n\n## References\n\
    * J. Bloch, *Effective Java (second edition)*, Item 10. Addison-Wesley, 2008.\n\
    * Java API Specification: [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Undesirable Calls/NextFromIterator.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Undesirable Calls/NextFromIterator.bqrs
  metadata:
    name: Next in hasNext implementation
    description: |-
      Iterator implementations whose 'hasNext' method calls 'next' are most likely
                    incorrect.
    kind: problem
    problem.severity: warning
    precision: medium
    id: java/iterator-hasnext-calls-next
    tags: |-
      reliability
             correctness
  queryHelp: "# Next in hasNext implementation\nIterator implementations with a `hasNext`\
    \ method that calls the `next` method are most likely incorrect. This is because\
    \ `next` changes the iterator's position to the next element and returns that\
    \ element, which is unlikely to be desirable in the implementation of `hasNext`.\n\
    \n\n## Recommendation\nEnsure that any calls to `next` from within `hasNext` are\
    \ legitimate. The `hasNext` method should indicate whether there are further elements\
    \ remaining in the iteration without changing the iterator's state by calling\
    \ `next`.\n\n\n## Example\nIn the following example, which outputs the contents\
    \ of a string, `hasNext` calls `next`, which has the effect of changing the iterator's\
    \ position. Given that `main` also calls `next` when it outputs an item, some\
    \ items are skipped and only half the items are output.\n\n\n```java\npublic class\
    \ NextFromIterator implements Iterator<String> {\n\tprivate int position = -1;\n\
    \tprivate List<String> list = new ArrayList<String>() {{\n\t\tadd(\"alpha\");\
    \ add(\"bravo\"); add(\"charlie\"); add(\"delta\"); add(\"echo\"); add(\"foxtrot\"\
    );\n\t}};\n\t\n\tpublic boolean hasNext() {\n\t\treturn next() != null;  // BAD:\
    \ Call to 'next'\n\t}\n\t\n\tpublic String next() {\n\t\tposition++;\n\t\treturn\
    \ position < list.size() ? list.get(position) : null;\n\t}\n\n\tpublic void remove()\
    \ {\n\t\t// ...\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tNextFromIterator\
    \ x = new NextFromIterator();\n\t\twhile(x.hasNext()) {\n\t\t\tSystem.out.println(x.next());\n\
    \t\t}\n\t}\n}\n```\nInstead, the implementation of `hasNext` should use another\
    \ way of indicating whether there are further elements in the string without calling\
    \ `next`. For example, `hasNext` could check the underlying array directly to\
    \ see if there is an element at the next position.\n\n\n## References\n* Java\
    \ API Specification: [Iterator.hasNext()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html#hasNext()),\
    \ [Iterator.next()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html#next()).\n"
 -
  pack: codeql/java-queries#0
  relativeQueryPath: Violations of Best Practice/Undesirable Calls/PrintLnArray.ql
  relativeBqrsPath: codeql/java-queries/Violations of Best Practice/Undesirable Calls/PrintLnArray.bqrs
  metadata:
    name: Implicit conversion from array to string
    description: |-
      Directly printing an array, without first converting the array to a string,
                    produces unreadable results.
    kind: problem
    problem.severity: recommendation
    precision: very-high
    id: java/print-array
    tags: maintainability
  queryHelp: "# Implicit conversion from array to string\nPrinting an array is likely\
    \ to produce unintended results. That is, the result does not contain the contents\
    \ of the array. This is because the array is implicitly converted to a `String`\
    \ using `Object.toString`, which just returns the following value:\n\n` getClass().getName()\
    \ + '@' + Integer.toHexString(hashCode()) `\n\n\n## Recommendation\nWhen converting\
    \ an array to a readable string, use `Arrays.toString` for one-dimensional arrays,\
    \ or `Arrays.deepToString` for multi-dimensional arrays. These functions iterate\
    \ over the contents of the array and produce human-readable output.\n\n\n## Example\n\
    In the following example, the contents of the array `words` are printed out only\
    \ if `Arrays.toString` is called on the array first. Similarly, the contents of\
    \ the multi-dimensional array `wordMatrix` are printed out only if `Arrays.deepToString`\
    \ is called on the array first.\n\n\n```java\npublic static void main(String args[])\
    \ {\n\tString[] words = {\"Who\", \"is\", \"John\", \"Galt\"};\n\tString[][] wordMatrix\
    \ = {{\"There\", \"is\"}, {\"no\", \"spoon\"}};\n\t\n\t// BAD: This implicitly\
    \ uses 'Object.toString' to convert the contents\n\t// of 'words[]', and prints\
    \ out something similar to:\n\t// [Ljava.lang.String;@459189e1\n\tSystem.out.println(words);\n\
    \t\n\t// GOOD: 'Arrays.toString' calls 'toString' on\n\t// each of the array's\
    \ elements. The statement prints out:\n\t// [Who, is, John, Galt]\n\tSystem.out.println(Arrays.toString(words));\n\
    \t\n\t// ALMOST RIGHT: This calls 'toString' on each of the multi-dimensional\
    \ \n\t// array's elements. However, because the elements are arrays, the statement\n\
    \t// prints out something similar to:\n\t// [[Ljava.lang.String;@55f33675, [Ljava.lang.String;@527c6768]]\n\
    \tSystem.out.println(Arrays.toString(wordMatrix));\n\t\n\t// GOOD: This properly\
    \ prints out the contents of the multi-dimensional array:\n\t// [[There, is],\
    \ [no, spoon]]\n\tSystem.out.println(Arrays.deepToString(wordMatrix));\n}\n```\n\
    \n## References\n* Java API Specification: [Arrays.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#toString(java.lang.Object[])),\
    \ [Arrays.deepToString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepToString(java.lang.Object[])),\
    \ [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"
extensionPacks: []
packs:
  codeql/java-queries#0:
    name: codeql/java-queries
    version: 0.8.14
    localPath: C:\Users\Ashok Kalakoti\Downloads\codeql-bundle-win64\codeql\qlpacks\codeql\java-queries\0.8.14
    runDataExtensions:
     -
      pack: codeql/java-all#1
      relativePath: ext/android.app.model.yml
      index: 0
      firstRowId: 0
      rowCount: 77
     -
      pack: codeql/java-all#1
      relativePath: ext/android.app.model.yml
      index: 1
      firstRowId: 77
      rowCount: 103
     -
      pack: codeql/java-all#1
      relativePath: ext/android.content.model.yml
      index: 0
      firstRowId: 180
      rowCount: 31
     -
      pack: codeql/java-all#1
      relativePath: ext/android.content.model.yml
      index: 1
      firstRowId: 211
      rowCount: 24
     -
      pack: codeql/java-all#1
      relativePath: ext/android.content.model.yml
      index: 2
      firstRowId: 235
      rowCount: 154
     -
      pack: codeql/java-all#1
      relativePath: ext/android.database.model.yml
      index: 0
      firstRowId: 389
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/android.database.model.yml
      index: 1
      firstRowId: 396
      rowCount: 11
     -
      pack: codeql/java-all#1
      relativePath: ext/android.database.sqlite.model.yml
      index: 0
      firstRowId: 407
      rowCount: 52
     -
      pack: codeql/java-all#1
      relativePath: ext/android.database.sqlite.model.yml
      index: 1
      firstRowId: 459
      rowCount: 30
     -
      pack: codeql/java-all#1
      relativePath: ext/android.net.model.yml
      index: 0
      firstRowId: 489
      rowCount: 60
     -
      pack: codeql/java-all#1
      relativePath: ext/android.os.model.yml
      index: 0
      firstRowId: 549
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/android.os.model.yml
      index: 1
      firstRowId: 551
      rowCount: 122
     -
      pack: codeql/java-all#1
      relativePath: ext/android.os.model.yml
      index: 2
      firstRowId: 673
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/android.support.v4.app.model.yml
      index: 0
      firstRowId: 674
      rowCount: 11
     -
      pack: codeql/java-all#1
      relativePath: ext/android.util.model.yml
      index: 0
      firstRowId: 685
      rowCount: 16
     -
      pack: codeql/java-all#1
      relativePath: ext/android.util.model.yml
      index: 1
      firstRowId: 701
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/android.webkit.model.yml
      index: 0
      firstRowId: 707
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/android.webkit.model.yml
      index: 1
      firstRowId: 709
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/android.widget.model.yml
      index: 0
      firstRowId: 712
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/android.widget.model.yml
      index: 1
      firstRowId: 713
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/androidx.core.app.model.yml
      index: 0
      firstRowId: 714
      rowCount: 47
     -
      pack: codeql/java-all#1
      relativePath: ext/androidx.core.app.model.yml
      index: 1
      firstRowId: 761
      rowCount: 95
     -
      pack: codeql/java-all#1
      relativePath: ext/androidx.fragment.app.model.yml
      index: 0
      firstRowId: 856
      rowCount: 11
     -
      pack: codeql/java-all#1
      relativePath: ext/androidx.slice.builders.model.yml
      index: 0
      firstRowId: 867
      rowCount: 88
     -
      pack: codeql/java-all#1
      relativePath: ext/androidx.slice.model.yml
      index: 0
      firstRowId: 955
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/androidx.slice.model.yml
      index: 1
      firstRowId: 960
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/ch.ethz.ssh2.model.yml
      index: 0
      firstRowId: 962
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/cn.hutool.core.codec.model.yml
      index: 0
      firstRowId: 964
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/com.alibaba.druid.sql.model.yml
      index: 0
      firstRowId: 965
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/com.alibaba.druid.sql.repository.model.yml
      index: 0
      firstRowId: 966
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/com.alibaba.fastjson2.model.yml
      index: 0
      firstRowId: 967
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/com.amazonaws.auth.model.yml
      index: 0
      firstRowId: 968
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/com.auth0.jwt.algorithms.model.yml
      index: 0
      firstRowId: 970
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/com.azure.identity.model.yml
      index: 0
      firstRowId: 976
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.esotericsoftware.kryo.io.model.yml
      index: 0
      firstRowId: 979
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/com.esotericsoftware.kryo5.io.model.yml
      index: 0
      firstRowId: 980
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/com.fasterxml.jackson.core.model.yml
      index: 0
      firstRowId: 981
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/com.fasterxml.jackson.databind.model.yml
      index: 0
      firstRowId: 982
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/com.fasterxml.jackson.databind.model.yml
      index: 1
      firstRowId: 990
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.base.model.yml
      index: 0
      firstRowId: 992
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.base.model.yml
      index: 1
      firstRowId: 996
      rowCount: 87
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.cache.model.yml
      index: 0
      firstRowId: 1083
      rowCount: 17
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.collect.model.yml
      index: 0
      firstRowId: 1100
      rowCount: 553
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.flogger.model.yml
      index: 0
      firstRowId: 1653
      rowCount: 29
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.io.model.yml
      index: 0
      firstRowId: 1682
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.common.io.model.yml
      index: 1
      firstRowId: 1692
      rowCount: 73
     -
      pack: codeql/java-all#1
      relativePath: ext/com.google.gson.model.yml
      index: 0
      firstRowId: 1765
      rowCount: 52
     -
      pack: codeql/java-all#1
      relativePath: ext/com.hubspot.jinjava.model.yml
      index: 0
      firstRowId: 1817
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/com.jcraft.jsch.model.yml
      index: 0
      firstRowId: 1819
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/com.jcraft.jsch.model.yml
      index: 1
      firstRowId: 1824
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/com.microsoft.sqlserver.jdbc.model.yml
      index: 0
      firstRowId: 1825
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/com.mitchellbosecke.pebble.model.yml
      index: 0
      firstRowId: 1829
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/com.mongodb.model.yml
      index: 0
      firstRowId: 1831
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/com.opensymphony.xwork2.ognl.model.yml
      index: 0
      firstRowId: 1841
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.rabbitmq.client.impl.model.yml
      index: 0
      firstRowId: 1844
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.rabbitmq.client.impl.model.yml
      index: 1
      firstRowId: 1847
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.rabbitmq.client.model.yml
      index: 0
      firstRowId: 1850
      rowCount: 18
     -
      pack: codeql/java-all#1
      relativePath: ext/com.rabbitmq.client.model.yml
      index: 1
      firstRowId: 1868
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sshtools.j2ssh.authentication.model.yml
      index: 0
      firstRowId: 1872
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.crypto.provider.model.yml
      index: 0
      firstRowId: 1875
      rowCount: 19
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.jndi.ldap.model.yml
      index: 0
      firstRowId: 1894
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.net.httpserver.model.yml
      index: 0
      firstRowId: 1898
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.net.ssl.model.yml
      index: 0
      firstRowId: 1901
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.rowset.model.yml
      index: 0
      firstRowId: 1904
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.security.auth.module.model.yml
      index: 0
      firstRowId: 1907
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.security.ntlm.model.yml
      index: 0
      firstRowId: 1909
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/com.sun.security.sasl.digest.model.yml
      index: 0
      firstRowId: 1914
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/com.thoughtworks.xstream.model.yml
      index: 0
      firstRowId: 1917
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/com.trilead.ssh2.model.yml
      index: 0
      firstRowId: 1918
      rowCount: 13
     -
      pack: codeql/java-all#1
      relativePath: ext/com.unboundid.ldap.sdk.model.yml
      index: 0
      firstRowId: 1931
      rowCount: 17
     -
      pack: codeql/java-all#1
      relativePath: ext/com.zaxxer.hikari.model.yml
      index: 0
      firstRowId: 1948
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/dummy.model.yml
      index: 0
      firstRowId: 1950
      rowCount: 0
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/com.google.common.io.model.yml
      index: 0
      firstRowId: 1951
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/com.jcraft.jsch.model.yml
      index: 0
      firstRowId: 1957
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/com.jfinal.core.model.yml
      index: 0
      firstRowId: 1958
      rowCount: 23
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/dummy.model.yml
      index: 0
      firstRowId: 1981
      rowCount: 0
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/java.lang.model.yml
      index: 0
      firstRowId: 1982
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/java.lang.model.yml
      index: 1
      firstRowId: 1983
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/java.util.concurrent.model.yml
      index: 0
      firstRowId: 1985
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/javax.servlet.http.model.yml
      index: 0
      firstRowId: 1986
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/org.apache.logging.log4j.message.model.yml
      index: 0
      firstRowId: 1991
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/experimental/org.apache.logging.log4j.model.yml
      index: 0
      firstRowId: 1995
      rowCount: 357
     -
      pack: codeql/java-all#1
      relativePath: ext/flexjson.model.yml
      index: 0
      firstRowId: 2352
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/freemarker.cache.model.yml
      index: 0
      firstRowId: 2353
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/freemarker.template.model.yml
      index: 0
      firstRowId: 2354
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/com.sun.jmx.remote.internal.model.yml
      index: 0
      firstRowId: 2361
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.applet.model.yml
      index: 0
      firstRowId: 2362
      rowCount: 14
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.applet.model.yml
      index: 1
      firstRowId: 2376
      rowCount: 25
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.awt.model.yml
      index: 0
      firstRowId: 2401
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.awt.model.yml
      index: 1
      firstRowId: 2403
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.beans.beancontext.model.yml
      index: 0
      firstRowId: 2406
      rowCount: 42
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.beans.beancontext.model.yml
      index: 1
      firstRowId: 2448
      rowCount: 33
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.beans.model.yml
      index: 0
      firstRowId: 2481
      rowCount: 150
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.beans.model.yml
      index: 1
      firstRowId: 2631
      rowCount: 97
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.io.model.yml
      index: 0
      firstRowId: 2728
      rowCount: 209
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.io.model.yml
      index: 1
      firstRowId: 2937
      rowCount: 185
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.annotation.model.yml
      index: 0
      firstRowId: 3122
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.annotation.model.yml
      index: 1
      firstRowId: 3132
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.constant.model.yml
      index: 0
      firstRowId: 3133
      rowCount: 77
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.constant.model.yml
      index: 1
      firstRowId: 3210
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.instrument.model.yml
      index: 0
      firstRowId: 3217
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.instrument.model.yml
      index: 1
      firstRowId: 3222
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.invoke.model.yml
      index: 0
      firstRowId: 3225
      rowCount: 133
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.invoke.model.yml
      index: 1
      firstRowId: 3358
      rowCount: 122
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.management.model.yml
      index: 0
      firstRowId: 3480
      rowCount: 23
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.management.model.yml
      index: 1
      firstRowId: 3503
      rowCount: 38
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.model.yml
      index: 0
      firstRowId: 3541
      rowCount: 235
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.model.yml
      index: 1
      firstRowId: 3776
      rowCount: 714
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.module.model.yml
      index: 0
      firstRowId: 4490
      rowCount: 109
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.module.model.yml
      index: 1
      firstRowId: 4599
      rowCount: 11
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.ref.model.yml
      index: 0
      firstRowId: 4610
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.ref.model.yml
      index: 1
      firstRowId: 4625
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.reflect.model.yml
      index: 0
      firstRowId: 4632
      rowCount: 48
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.reflect.model.yml
      index: 1
      firstRowId: 4680
      rowCount: 87
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.runtime.model.yml
      index: 0
      firstRowId: 4767
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.lang.runtime.model.yml
      index: 1
      firstRowId: 4769
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.math.model.yml
      index: 0
      firstRowId: 4770
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.math.model.yml
      index: 1
      firstRowId: 4779
      rowCount: 88
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.net.http.model.yml
      index: 0
      firstRowId: 4867
      rowCount: 40
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.net.http.model.yml
      index: 1
      firstRowId: 4907
      rowCount: 53
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.net.model.yml
      index: 0
      firstRowId: 4960
      rowCount: 207
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.net.model.yml
      index: 1
      firstRowId: 5167
      rowCount: 259
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.channels.model.yml
      index: 0
      firstRowId: 5426
      rowCount: 49
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.channels.model.yml
      index: 1
      firstRowId: 5475
      rowCount: 121
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.channels.spi.model.yml
      index: 0
      firstRowId: 5596
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.charset.model.yml
      index: 0
      firstRowId: 5611
      rowCount: 30
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.charset.model.yml
      index: 1
      firstRowId: 5641
      rowCount: 42
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.charset.spi.model.yml
      index: 0
      firstRowId: 5683
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.file.attribute.model.yml
      index: 0
      firstRowId: 5685
      rowCount: 18
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.file.attribute.model.yml
      index: 1
      firstRowId: 5703
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.file.model.yml
      index: 0
      firstRowId: 5713
      rowCount: 70
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.file.model.yml
      index: 1
      firstRowId: 5783
      rowCount: 39
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.file.spi.model.yml
      index: 0
      firstRowId: 5822
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.file.spi.model.yml
      index: 1
      firstRowId: 5823
      rowCount: 28
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.model.yml
      index: 0
      firstRowId: 5851
      rowCount: 155
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.nio.model.yml
      index: 1
      firstRowId: 6006
      rowCount: 69
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.dgc.model.yml
      index: 0
      firstRowId: 6075
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.dgc.model.yml
      index: 1
      firstRowId: 6077
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.model.yml
      index: 0
      firstRowId: 6079
      rowCount: 41
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.model.yml
      index: 1
      firstRowId: 6120
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.registry.model.yml
      index: 0
      firstRowId: 6125
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.server.model.yml
      index: 0
      firstRowId: 6132
      rowCount: 28
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.rmi.server.model.yml
      index: 1
      firstRowId: 6160
      rowCount: 33
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.cert.model.yml
      index: 0
      firstRowId: 6193
      rowCount: 152
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.cert.model.yml
      index: 1
      firstRowId: 6345
      rowCount: 119
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.interfaces.model.yml
      index: 0
      firstRowId: 6464
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.model.yml
      index: 0
      firstRowId: 6468
      rowCount: 317
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.model.yml
      index: 1
      firstRowId: 6785
      rowCount: 127
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.spec.model.yml
      index: 0
      firstRowId: 6912
      rowCount: 67
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.security.spec.model.yml
      index: 1
      firstRowId: 6979
      rowCount: 69
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.sql.model.yml
      index: 0
      firstRowId: 7048
      rowCount: 301
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.sql.model.yml
      index: 1
      firstRowId: 7349
      rowCount: 154
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.text.model.yml
      index: 0
      firstRowId: 7503
      rowCount: 134
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.text.model.yml
      index: 1
      firstRowId: 7637
      rowCount: 182
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.text.spi.model.yml
      index: 0
      firstRowId: 7819
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.chrono.model.yml
      index: 0
      firstRowId: 7834
      rowCount: 52
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.chrono.model.yml
      index: 1
      firstRowId: 7886
      rowCount: 56
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.format.model.yml
      index: 0
      firstRowId: 7942
      rowCount: 75
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.format.model.yml
      index: 1
      firstRowId: 8017
      rowCount: 19
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.model.yml
      index: 0
      firstRowId: 8036
      rowCount: 286
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.model.yml
      index: 1
      firstRowId: 8322
      rowCount: 217
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.temporal.model.yml
      index: 0
      firstRowId: 8539
      rowCount: 30
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.temporal.model.yml
      index: 1
      firstRowId: 8569
      rowCount: 57
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.zone.model.yml
      index: 0
      firstRowId: 8626
      rowCount: 33
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.time.zone.model.yml
      index: 1
      firstRowId: 8659
      rowCount: 20
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.concurrent.atomic.model.yml
      index: 0
      firstRowId: 8679
      rowCount: 12
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.concurrent.atomic.model.yml
      index: 1
      firstRowId: 8691
      rowCount: 249
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.concurrent.locks.model.yml
      index: 0
      firstRowId: 8940
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.concurrent.locks.model.yml
      index: 1
      firstRowId: 8955
      rowCount: 103
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.concurrent.model.yml
      index: 0
      firstRowId: 9058
      rowCount: 138
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.concurrent.model.yml
      index: 1
      firstRowId: 9196
      rowCount: 226
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.function.model.yml
      index: 0
      firstRowId: 9422
      rowCount: 40
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.jar.model.yml
      index: 0
      firstRowId: 9462
      rowCount: 35
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.jar.model.yml
      index: 1
      firstRowId: 9497
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.logging.model.yml
      index: 0
      firstRowId: 9506
      rowCount: 70
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.logging.model.yml
      index: 1
      firstRowId: 9576
      rowCount: 73
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.model.yml
      index: 0
      firstRowId: 9649
      rowCount: 181
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.model.yml
      index: 1
      firstRowId: 9830
      rowCount: 568
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.prefs.model.yml
      index: 0
      firstRowId: 10398
      rowCount: 25
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.prefs.model.yml
      index: 1
      firstRowId: 10423
      rowCount: 17
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.random.model.yml
      index: 0
      firstRowId: 10440
      rowCount: 18
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.random.model.yml
      index: 1
      firstRowId: 10458
      rowCount: 60
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.regex.model.yml
      index: 0
      firstRowId: 10518
      rowCount: 19
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.regex.model.yml
      index: 1
      firstRowId: 10537
      rowCount: 21
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.spi.model.yml
      index: 0
      firstRowId: 10558
      rowCount: 19
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.stream.model.yml
      index: 0
      firstRowId: 10577
      rowCount: 100
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.stream.model.yml
      index: 1
      firstRowId: 10677
      rowCount: 101
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.zip.model.yml
      index: 0
      firstRowId: 10778
      rowCount: 76
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/java.util.zip.model.yml
      index: 1
      firstRowId: 10854
      rowCount: 69
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.accessibility.model.yml
      index: 0
      firstRowId: 10923
      rowCount: 31
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.accessibility.model.yml
      index: 1
      firstRowId: 10954
      rowCount: 34
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.annotation.processing.model.yml
      index: 0
      firstRowId: 10988
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.annotation.processing.model.yml
      index: 1
      firstRowId: 10997
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.crypto.model.yml
      index: 0
      firstRowId: 11003
      rowCount: 89
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.crypto.model.yml
      index: 1
      firstRowId: 11092
      rowCount: 20
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.crypto.spec.model.yml
      index: 0
      firstRowId: 11112
      rowCount: 35
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.crypto.spec.model.yml
      index: 1
      firstRowId: 11147
      rowCount: 29
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.metadata.model.yml
      index: 0
      firstRowId: 11176
      rowCount: 25
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.metadata.model.yml
      index: 1
      firstRowId: 11201
      rowCount: 30
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.model.yml
      index: 0
      firstRowId: 11231
      rowCount: 88
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.model.yml
      index: 1
      firstRowId: 11319
      rowCount: 153
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.plugins.bmp.model.yml
      index: 0
      firstRowId: 11472
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.plugins.bmp.model.yml
      index: 1
      firstRowId: 11473
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.plugins.jpeg.model.yml
      index: 0
      firstRowId: 11475
      rowCount: 13
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.plugins.jpeg.model.yml
      index: 1
      firstRowId: 11488
      rowCount: 12
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.plugins.tiff.model.yml
      index: 0
      firstRowId: 11500
      rowCount: 39
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.plugins.tiff.model.yml
      index: 1
      firstRowId: 11539
      rowCount: 45
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.spi.model.yml
      index: 0
      firstRowId: 11584
      rowCount: 78
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.spi.model.yml
      index: 1
      firstRowId: 11662
      rowCount: 41
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.stream.model.yml
      index: 0
      firstRowId: 11703
      rowCount: 16
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.imageio.stream.model.yml
      index: 1
      firstRowId: 11719
      rowCount: 36
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.element.model.yml
      index: 0
      firstRowId: 11755
      rowCount: 17
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.element.model.yml
      index: 1
      firstRowId: 11772
      rowCount: 11
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.model.yml
      index: 0
      firstRowId: 11783
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.type.model.yml
      index: 0
      firstRowId: 11790
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.type.model.yml
      index: 1
      firstRowId: 11799
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.util.model.yml
      index: 0
      firstRowId: 11800
      rowCount: 68
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.lang.model.util.model.yml
      index: 1
      firstRowId: 11868
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.loading.model.yml
      index: 0
      firstRowId: 11883
      rowCount: 27
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.loading.model.yml
      index: 1
      firstRowId: 11910
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.model.yml
      index: 0
      firstRowId: 11917
      rowCount: 305
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.model.yml
      index: 1
      firstRowId: 12222
      rowCount: 94
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.modelmbean.model.yml
      index: 0
      firstRowId: 12316
      rowCount: 96
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.modelmbean.model.yml
      index: 1
      firstRowId: 12412
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.monitor.model.yml
      index: 0
      firstRowId: 12419
      rowCount: 14
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.monitor.model.yml
      index: 1
      firstRowId: 12433
      rowCount: 44
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.openmbean.model.yml
      index: 0
      firstRowId: 12477
      rowCount: 120
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.openmbean.model.yml
      index: 1
      firstRowId: 12597
      rowCount: 20
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.relation.model.yml
      index: 0
      firstRowId: 12617
      rowCount: 122
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.relation.model.yml
      index: 1
      firstRowId: 12739
      rowCount: 39
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.remote.model.yml
      index: 0
      firstRowId: 12778
      rowCount: 51
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.remote.model.yml
      index: 1
      firstRowId: 12829
      rowCount: 11
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.remote.rmi.model.yml
      index: 0
      firstRowId: 12840
      rowCount: 57
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.remote.rmi.model.yml
      index: 1
      firstRowId: 12897
      rowCount: 17
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.timer.model.yml
      index: 0
      firstRowId: 12914
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.management.timer.model.yml
      index: 1
      firstRowId: 12920
      rowCount: 21
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.directory.model.yml
      index: 0
      firstRowId: 12941
      rowCount: 95
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.directory.model.yml
      index: 1
      firstRowId: 13036
      rowCount: 32
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.event.model.yml
      index: 0
      firstRowId: 13068
      rowCount: 12
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.event.model.yml
      index: 1
      firstRowId: 13080
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.ldap.model.yml
      index: 0
      firstRowId: 13083
      rowCount: 47
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.ldap.model.yml
      index: 1
      firstRowId: 13130
      rowCount: 34
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.ldap.spi.model.yml
      index: 0
      firstRowId: 13164
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.ldap.spi.model.yml
      index: 1
      firstRowId: 13168
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.model.yml
      index: 0
      firstRowId: 13169
      rowCount: 139
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.model.yml
      index: 1
      firstRowId: 13308
      rowCount: 28
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.spi.model.yml
      index: 0
      firstRowId: 13336
      rowCount: 26
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.naming.spi.model.yml
      index: 1
      firstRowId: 13362
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.net.model.yml
      index: 0
      firstRowId: 13366
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.net.model.yml
      index: 1
      firstRowId: 13371
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.net.ssl.model.yml
      index: 0
      firstRowId: 13378
      rowCount: 81
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.net.ssl.model.yml
      index: 1
      firstRowId: 13459
      rowCount: 142
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.portlet.model.yml
      index: 0
      firstRowId: 13601
      rowCount: 61
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.portlet.model.yml
      index: 1
      firstRowId: 13662
      rowCount: 118
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.attribute.model.yml
      index: 0
      firstRowId: 13780
      rowCount: 28
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.attribute.model.yml
      index: 1
      firstRowId: 13808
      rowCount: 32
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.attribute.standard.model.yml
      index: 0
      firstRowId: 13840
      rowCount: 39
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.attribute.standard.model.yml
      index: 1
      firstRowId: 13879
      rowCount: 43
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.event.model.yml
      index: 0
      firstRowId: 13922
      rowCount: 11
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.event.model.yml
      index: 1
      firstRowId: 13933
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.model.yml
      index: 0
      firstRowId: 13940
      rowCount: 22
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.print.model.yml
      index: 1
      firstRowId: 13962
      rowCount: 24
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.rmi.ssl.model.yml
      index: 0
      firstRowId: 13986
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.rmi.ssl.model.yml
      index: 1
      firstRowId: 13993
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.script.model.yml
      index: 0
      firstRowId: 13994
      rowCount: 42
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.script.model.yml
      index: 1
      firstRowId: 14036
      rowCount: 14
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.callback.model.yml
      index: 0
      firstRowId: 14050
      rowCount: 36
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.callback.model.yml
      index: 1
      firstRowId: 14086
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.kerberos.model.yml
      index: 0
      firstRowId: 14101
      rowCount: 38
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.kerberos.model.yml
      index: 1
      firstRowId: 14139
      rowCount: 17
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.login.model.yml
      index: 0
      firstRowId: 14156
      rowCount: 33
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.login.model.yml
      index: 1
      firstRowId: 14189
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.model.yml
      index: 0
      firstRowId: 14196
      rowCount: 17
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.model.yml
      index: 1
      firstRowId: 14213
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.x500.model.yml
      index: 0
      firstRowId: 14223
      rowCount: 13
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.auth.x500.model.yml
      index: 1
      firstRowId: 14236
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.cert.model.yml
      index: 0
      firstRowId: 14240
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.cert.model.yml
      index: 1
      firstRowId: 14245
      rowCount: 17
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.sasl.model.yml
      index: 0
      firstRowId: 14262
      rowCount: 28
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.security.sasl.model.yml
      index: 1
      firstRowId: 14290
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.smartcardio.model.yml
      index: 0
      firstRowId: 14294
      rowCount: 30
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.smartcardio.model.yml
      index: 1
      firstRowId: 14324
      rowCount: 38
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.midi.model.yml
      index: 0
      firstRowId: 14362
      rowCount: 29
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.midi.model.yml
      index: 1
      firstRowId: 14391
      rowCount: 57
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.midi.spi.model.yml
      index: 0
      firstRowId: 14448
      rowCount: 18
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.sampled.model.yml
      index: 0
      firstRowId: 14466
      rowCount: 66
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.sampled.model.yml
      index: 1
      firstRowId: 14532
      rowCount: 52
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sound.sampled.spi.model.yml
      index: 0
      firstRowId: 14584
      rowCount: 25
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.model.yml
      index: 0
      firstRowId: 14609
      rowCount: 12
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.model.yml
      index: 1
      firstRowId: 14621
      rowCount: 21
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.rowset.model.yml
      index: 0
      firstRowId: 14642
      rowCount: 27
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.rowset.model.yml
      index: 1
      firstRowId: 14669
      rowCount: 106
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.rowset.serial.model.yml
      index: 0
      firstRowId: 14775
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.rowset.serial.model.yml
      index: 1
      firstRowId: 14790
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.rowset.spi.model.yml
      index: 0
      firstRowId: 14794
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.sql.rowset.spi.model.yml
      index: 1
      firstRowId: 14803
      rowCount: 14
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.tools.model.yml
      index: 0
      firstRowId: 14817
      rowCount: 31
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.tools.model.yml
      index: 1
      firstRowId: 14848
      rowCount: 27
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.transaction.xa.model.yml
      index: 0
      firstRowId: 14875
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.transaction.xa.model.yml
      index: 1
      firstRowId: 14876
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.catalog.model.yml
      index: 0
      firstRowId: 14877
      rowCount: 11
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.catalog.model.yml
      index: 1
      firstRowId: 14888
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dom.model.yml
      index: 0
      firstRowId: 14897
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.dom.model.yml
      index: 0
      firstRowId: 14902
      rowCount: 20
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.keyinfo.model.yml
      index: 0
      firstRowId: 14922
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.keyinfo.model.yml
      index: 1
      firstRowId: 14928
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.model.yml
      index: 0
      firstRowId: 14943
      rowCount: 24
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.model.yml
      index: 1
      firstRowId: 14967
      rowCount: 27
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.spec.model.yml
      index: 0
      firstRowId: 14994
      rowCount: 21
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.dsig.spec.model.yml
      index: 1
      firstRowId: 15015
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.model.yml
      index: 0
      firstRowId: 15017
      rowCount: 50
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.crypto.model.yml
      index: 1
      firstRowId: 15067
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.datatype.model.yml
      index: 0
      firstRowId: 15070
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.datatype.model.yml
      index: 1
      firstRowId: 15074
      rowCount: 83
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.namespace.model.yml
      index: 0
      firstRowId: 15157
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.parsers.model.yml
      index: 0
      firstRowId: 15167
      rowCount: 18
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.parsers.model.yml
      index: 1
      firstRowId: 15185
      rowCount: 65
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.stream.model.yml
      index: 0
      firstRowId: 15250
      rowCount: 30
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.stream.model.yml
      index: 1
      firstRowId: 15280
      rowCount: 116
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.stream.util.model.yml
      index: 0
      firstRowId: 15396
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.dom.model.yml
      index: 0
      firstRowId: 15402
      rowCount: 17
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.model.yml
      index: 0
      firstRowId: 15419
      rowCount: 35
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.model.yml
      index: 1
      firstRowId: 15454
      rowCount: 29
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.sax.model.yml
      index: 0
      firstRowId: 15483
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.sax.model.yml
      index: 1
      firstRowId: 15491
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.stax.model.yml
      index: 0
      firstRowId: 15497
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.transform.stream.model.yml
      index: 0
      firstRowId: 15505
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.validation.model.yml
      index: 0
      firstRowId: 15520
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.validation.model.yml
      index: 1
      firstRowId: 15525
      rowCount: 45
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.xpath.model.yml
      index: 0
      firstRowId: 15570
      rowCount: 12
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/javax.xml.xpath.model.yml
      index: 1
      firstRowId: 15582
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/jenkins-json-lib.model.yml
      index: 0
      firstRowId: 15597
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/jenkins-json-lib.model.yml
      index: 1
      firstRowId: 15599
      rowCount: 338
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/jenkins-json-lib.model.yml
      index: 2
      firstRowId: 15937
      rowCount: 243
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/jenkins.model.yml
      index: 0
      firstRowId: 16180
      rowCount: 3251
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/jenkins.model.yml
      index: 1
      firstRowId: 19431
      rowCount: 5200
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/kotlinstdlib.model.yml
      index: 0
      firstRowId: 24631
      rowCount: 12
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/kotlinstdlib.model.yml
      index: 1
      firstRowId: 24643
      rowCount: 1833
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/kotlinstdlib.model.yml
      index: 2
      firstRowId: 26476
      rowCount: 4608
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.apache.commons.io.model.yml
      index: 0
      firstRowId: 31084
      rowCount: 106
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.apache.commons.io.model.yml
      index: 1
      firstRowId: 31190
      rowCount: 555
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.apache.commons.io.model.yml
      index: 2
      firstRowId: 31745
      rowCount: 750
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.apache.commons.lang.model.yml
      index: 0
      firstRowId: 32495
      rowCount: 765
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.apache.commons.lang.model.yml
      index: 1
      firstRowId: 33260
      rowCount: 914
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.w3c.dom.ls.model.yml
      index: 0
      firstRowId: 34174
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.w3c.dom.ls.model.yml
      index: 1
      firstRowId: 34178
      rowCount: 14
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.w3c.dom.model.yml
      index: 0
      firstRowId: 34192
      rowCount: 53
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.w3c.dom.model.yml
      index: 1
      firstRowId: 34245
      rowCount: 39
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.xml.sax.model.yml
      index: 0
      firstRowId: 34284
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/org.xml.sax.model.yml
      index: 1
      firstRowId: 34287
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/stapler.model.yml
      index: 0
      firstRowId: 34291
      rowCount: 362
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/stapler.model.yml
      index: 1
      firstRowId: 34653
      rowCount: 316
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/struts2.model.yml
      index: 0
      firstRowId: 34969
      rowCount: 4844
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/struts2.model.yml
      index: 1
      firstRowId: 39813
      rowCount: 2026
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/sun.awt.model.yml
      index: 0
      firstRowId: 41839
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/sun.java2d.model.yml
      index: 0
      firstRowId: 41844
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/sun.management.spi.model.yml
      index: 0
      firstRowId: 41845
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/sun.nio.ch.model.yml
      index: 0
      firstRowId: 41846
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/sun.nio.ch.model.yml
      index: 1
      firstRowId: 41848
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/sun.print.model.yml
      index: 0
      firstRowId: 41850
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/sun.security.krb5.model.yml
      index: 0
      firstRowId: 41851
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/sun.security.util.model.yml
      index: 0
      firstRowId: 41858
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/generated/sun.util.logging.internal.model.yml
      index: 0
      firstRowId: 41859
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/groovy.lang.model.yml
      index: 0
      firstRowId: 41862
      rowCount: 27
     -
      pack: codeql/java-all#1
      relativePath: ext/groovy.util.model.yml
      index: 0
      firstRowId: 41889
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.cli.model.yml
      index: 0
      firstRowId: 41894
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.console.model.yml
      index: 0
      firstRowId: 41896
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.lifecycle.model.yml
      index: 0
      firstRowId: 41897
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.model.model.yml
      index: 0
      firstRowId: 41898
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.model.model.yml
      index: 1
      firstRowId: 41905
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.model.model.yml
      index: 2
      firstRowId: 41907
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.model.yml
      index: 0
      firstRowId: 41909
      rowCount: 35
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.model.yml
      index: 1
      firstRowId: 41944
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.model.yml
      index: 2
      firstRowId: 41951
      rowCount: 26
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.os.model.yml
      index: 0
      firstRowId: 41977
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.remoting.model.yml
      index: 0
      firstRowId: 41978
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.scm.model.yml
      index: 0
      firstRowId: 41979
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.scm.model.yml
      index: 1
      firstRowId: 41984
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.util.io.model.yml
      index: 0
      firstRowId: 41988
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.util.jna.model.yml
      index: 0
      firstRowId: 41990
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.util.model.yml
      index: 0
      firstRowId: 41993
      rowCount: 19
     -
      pack: codeql/java-all#1
      relativePath: ext/hudson.util.model.yml
      index: 1
      firstRowId: 42012
      rowCount: 17
     -
      pack: codeql/java-all#1
      relativePath: ext/io.jsonwebtoken.model.yml
      index: 0
      firstRowId: 42029
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/io.jsonwebtoken.model.yml
      index: 1
      firstRowId: 42033
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.bootstrap.model.yml
      index: 0
      firstRowId: 42035
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.buffer.model.yml
      index: 0
      firstRowId: 42038
      rowCount: 207
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.channel.model.yml
      index: 0
      firstRowId: 42245
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.channel.model.yml
      index: 1
      firstRowId: 42254
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.base64.model.yml
      index: 0
      firstRowId: 42256
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http.cookie.model.yml
      index: 0
      firstRowId: 42258
      rowCount: 14
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http.model.yml
      index: 0
      firstRowId: 42272
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http.model.yml
      index: 1
      firstRowId: 42275
      rowCount: 70
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http.multipart.model.yml
      index: 0
      firstRowId: 42345
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http.multipart.model.yml
      index: 1
      firstRowId: 42346
      rowCount: 33
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http.websocketx.model.yml
      index: 0
      firstRowId: 42379
      rowCount: 20
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http2.model.yml
      index: 0
      firstRowId: 42399
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.http2.model.yml
      index: 1
      firstRowId: 42403
      rowCount: 36
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.model.yml
      index: 0
      firstRowId: 42439
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.codec.model.yml
      index: 1
      firstRowId: 42448
      rowCount: 85
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.ssl.model.yml
      index: 0
      firstRowId: 42533
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.handler.stream.model.yml
      index: 0
      firstRowId: 42537
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.resolver.model.yml
      index: 0
      firstRowId: 42538
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.util.internal.model.yml
      index: 0
      firstRowId: 42539
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.util.internal.model.yml
      index: 1
      firstRowId: 42541
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/io.netty.util.model.yml
      index: 0
      firstRowId: 42543
      rowCount: 22
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.activation.model.yml
      index: 0
      firstRowId: 42565
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.activation.model.yml
      index: 1
      firstRowId: 42567
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.faces.context.model.yml
      index: 0
      firstRowId: 42569
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.faces.context.model.yml
      index: 1
      firstRowId: 42576
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.json.model.yml
      index: 0
      firstRowId: 42578
      rowCount: 122
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.json.stream.model.yml
      index: 0
      firstRowId: 42700
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.persistence.criteria.model.yml
      index: 0
      firstRowId: 42701
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.persistence.model.yml
      index: 0
      firstRowId: 42702
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.servlet.http.model.yml
      index: 0
      firstRowId: 42704
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.servlet.model.yml
      index: 0
      firstRowId: 42705
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.ws.rs.client.model.yml
      index: 0
      firstRowId: 42707
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.ws.rs.container.model.yml
      index: 0
      firstRowId: 42708
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.ws.rs.core.model.yml
      index: 0
      firstRowId: 42717
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.ws.rs.core.model.yml
      index: 1
      firstRowId: 42719
      rowCount: 149
     -
      pack: codeql/java-all#1
      relativePath: ext/jakarta.xml.bind.attachment.model.yml
      index: 0
      firstRowId: 42868
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.awt.model.yml
      index: 0
      firstRowId: 42870
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.awt.model.yml
      index: 1
      firstRowId: 42873
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.awt.model.yml
      index: 2
      firstRowId: 42874
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.beans.model.yml
      index: 0
      firstRowId: 42875
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.beans.model.yml
      index: 1
      firstRowId: 42876
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/java.io.model.yml
      index: 0
      firstRowId: 42880
      rowCount: 51
     -
      pack: codeql/java-all#1
      relativePath: ext/java.io.model.yml
      index: 1
      firstRowId: 42931
      rowCount: 47
     -
      pack: codeql/java-all#1
      relativePath: ext/java.io.model.yml
      index: 2
      firstRowId: 42978
      rowCount: 20
     -
      pack: codeql/java-all#1
      relativePath: ext/java.io.model.yml
      index: 3
      firstRowId: 42998
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.invoke.model.yml
      index: 0
      firstRowId: 42999
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.model.yml
      index: 0
      firstRowId: 43000
      rowCount: 38
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.model.yml
      index: 1
      firstRowId: 43038
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.model.yml
      index: 2
      firstRowId: 43041
      rowCount: 101
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.model.yml
      index: 3
      firstRowId: 43142
      rowCount: 105
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.module.model.yml
      index: 0
      firstRowId: 43247
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.lang.reflect.model.yml
      index: 0
      firstRowId: 43248
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/java.math.model.yml
      index: 0
      firstRowId: 43252
      rowCount: 14
     -
      pack: codeql/java-all#1
      relativePath: ext/java.net.http.model.yml
      index: 0
      firstRowId: 43266
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.net.http.model.yml
      index: 1
      firstRowId: 43267
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.net.model.yml
      index: 0
      firstRowId: 43270
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.net.model.yml
      index: 1
      firstRowId: 43272
      rowCount: 25
     -
      pack: codeql/java-all#1
      relativePath: ext/java.net.model.yml
      index: 2
      firstRowId: 43297
      rowCount: 31
     -
      pack: codeql/java-all#1
      relativePath: ext/java.net.model.yml
      index: 3
      firstRowId: 43328
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.channels.model.yml
      index: 0
      firstRowId: 43337
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.channels.model.yml
      index: 1
      firstRowId: 43339
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.charset.model.yml
      index: 0
      firstRowId: 43343
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.file.model.yml
      index: 0
      firstRowId: 43344
      rowCount: 40
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.file.model.yml
      index: 1
      firstRowId: 43384
      rowCount: 33
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.file.model.yml
      index: 2
      firstRowId: 43417
      rowCount: 38
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.file.spi.model.yml
      index: 0
      firstRowId: 43455
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.model.yml
      index: 0
      firstRowId: 43457
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.nio.model.yml
      index: 1
      firstRowId: 43460
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.security.cert.model.yml
      index: 0
      firstRowId: 43463
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.security.cert.model.yml
      index: 1
      firstRowId: 43464
      rowCount: 36
     -
      pack: codeql/java-all#1
      relativePath: ext/java.security.model.yml
      index: 0
      firstRowId: 43500
      rowCount: 12
     -
      pack: codeql/java-all#1
      relativePath: ext/java.security.model.yml
      index: 1
      firstRowId: 43512
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/java.security.model.yml
      index: 2
      firstRowId: 43519
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.security.spec.model.yml
      index: 0
      firstRowId: 43522
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/java.sql.model.yml
      index: 0
      firstRowId: 43530
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/java.sql.model.yml
      index: 1
      firstRowId: 43545
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.sql.model.yml
      index: 2
      firstRowId: 43547
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/java.sql.model.yml
      index: 3
      firstRowId: 43562
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.text.model.yml
      index: 0
      firstRowId: 43563
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/java.time.chrono.model.yml
      index: 0
      firstRowId: 43571
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.time.format.model.yml
      index: 0
      firstRowId: 43572
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.time.model.yml
      index: 0
      firstRowId: 43574
      rowCount: 17
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.concurrent.atomic.model.yml
      index: 0
      firstRowId: 43591
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.concurrent.atomic.model.yml
      index: 1
      firstRowId: 43594
      rowCount: 11
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.concurrent.locks.model.yml
      index: 0
      firstRowId: 43605
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.concurrent.model.yml
      index: 0
      firstRowId: 43607
      rowCount: 24
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.concurrent.model.yml
      index: 1
      firstRowId: 43631
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.function.model.yml
      index: 0
      firstRowId: 43640
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.function.model.yml
      index: 1
      firstRowId: 43641
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.logging.model.yml
      index: 0
      firstRowId: 43642
      rowCount: 36
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.logging.model.yml
      index: 1
      firstRowId: 43678
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.logging.model.yml
      index: 2
      firstRowId: 43681
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.model.yml
      index: 0
      firstRowId: 43682
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.model.yml
      index: 1
      firstRowId: 43684
      rowCount: 406
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.model.yml
      index: 2
      firstRowId: 44090
      rowCount: 138
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.prefs.model.yml
      index: 0
      firstRowId: 44228
      rowCount: 16
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.regex.model.yml
      index: 0
      firstRowId: 44244
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.regex.model.yml
      index: 1
      firstRowId: 44253
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.regex.model.yml
      index: 2
      firstRowId: 44262
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.stream.model.yml
      index: 0
      firstRowId: 44268
      rowCount: 80
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.stream.model.yml
      index: 1
      firstRowId: 44348
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.zip.model.yml
      index: 0
      firstRowId: 44356
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/java.util.zip.model.yml
      index: 1
      firstRowId: 44360
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javafx.scene.web.model.yml
      index: 0
      firstRowId: 44361
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.activation.model.yml
      index: 0
      firstRowId: 44362
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.activation.model.yml
      index: 1
      firstRowId: 44364
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.crypto.model.yml
      index: 0
      firstRowId: 44371
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.crypto.model.yml
      index: 1
      firstRowId: 44375
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.crypto.spec.model.yml
      index: 0
      firstRowId: 44390
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.crypto.spec.model.yml
      index: 1
      firstRowId: 44394
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.crypto.spec.model.yml
      index: 2
      firstRowId: 44409
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.faces.context.model.yml
      index: 0
      firstRowId: 44411
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.faces.context.model.yml
      index: 1
      firstRowId: 44418
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.imageio.stream.model.yml
      index: 0
      firstRowId: 44420
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.imageio.stream.model.yml
      index: 1
      firstRowId: 44421
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.jms.model.yml
      index: 0
      firstRowId: 44422
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.jms.model.yml
      index: 1
      firstRowId: 44431
      rowCount: 57
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.json.model.yml
      index: 0
      firstRowId: 44488
      rowCount: 122
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.json.stream.model.yml
      index: 0
      firstRowId: 44610
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.management.model.yml
      index: 0
      firstRowId: 44611
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.management.remote.model.yml
      index: 0
      firstRowId: 44612
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.naming.directory.model.yml
      index: 0
      firstRowId: 44614
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.naming.model.yml
      index: 0
      firstRowId: 44615
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.naming.model.yml
      index: 1
      firstRowId: 44621
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.net.ssl.model.yml
      index: 0
      firstRowId: 44622
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.portlet.model.yml
      index: 0
      firstRowId: 44626
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.print.attribute.standard.model.yml
      index: 0
      firstRowId: 44627
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.script.model.yml
      index: 0
      firstRowId: 44629
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.security.auth.callback.model.yml
      index: 0
      firstRowId: 44630
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.security.auth.kerberos.model.yml
      index: 0
      firstRowId: 44631
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.servlet.http.model.yml
      index: 0
      firstRowId: 44637
      rowCount: 16
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.servlet.http.model.yml
      index: 1
      firstRowId: 44653
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.servlet.http.model.yml
      index: 2
      firstRowId: 44659
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.servlet.model.yml
      index: 0
      firstRowId: 44661
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.servlet.model.yml
      index: 1
      firstRowId: 44667
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.servlet.model.yml
      index: 2
      firstRowId: 44670
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.sql.model.yml
      index: 0
      firstRowId: 44671
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.validation.model.yml
      index: 0
      firstRowId: 44678
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.validation.model.yml
      index: 1
      firstRowId: 44679
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.ws.rs.client.model.yml
      index: 0
      firstRowId: 44680
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.ws.rs.container.model.yml
      index: 0
      firstRowId: 44681
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.ws.rs.core.model.yml
      index: 0
      firstRowId: 44690
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.ws.rs.core.model.yml
      index: 1
      firstRowId: 44693
      rowCount: 149
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.xml.bind.attachment.model.yml
      index: 0
      firstRowId: 44842
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.xml.transform.model.yml
      index: 0
      firstRowId: 44844
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.xml.transform.sax.model.yml
      index: 0
      firstRowId: 44845
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.xml.transform.stream.model.yml
      index: 0
      firstRowId: 44849
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.xml.transform.stream.model.yml
      index: 1
      firstRowId: 44851
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/javax.xml.xpath.model.yml
      index: 0
      firstRowId: 44852
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/jodd.json.model.yml
      index: 0
      firstRowId: 44855
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/kotlin.collections.model.yml
      index: 0
      firstRowId: 44865
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/kotlin.io.model.yml
      index: 0
      firstRowId: 44866
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/kotlin.io.model.yml
      index: 1
      firstRowId: 44870
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/kotlin.jvm.internal.model.yml
      index: 0
      firstRowId: 44880
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/kotlin.model.yml
      index: 0
      firstRowId: 44881
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/liquibase.database.jvm.model.yml
      index: 0
      firstRowId: 44885
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/liquibase.statement.core.model.yml
      index: 0
      firstRowId: 44886
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/net.schmizz.sshj.model.yml
      index: 0
      firstRowId: 44887
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/net.sf.saxon.s9api.model.yml
      index: 0
      firstRowId: 44891
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/ognl.enhance.model.yml
      index: 0
      firstRowId: 44896
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/ognl.model.yml
      index: 0
      firstRowId: 44898
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/okhttp3.model.yml
      index: 0
      firstRowId: 44902
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/okhttp3.model.yml
      index: 1
      firstRowId: 44906
      rowCount: 50
     -
      pack: codeql/java-all#1
      relativePath: ext/org.antlr.runtime.model.yml
      index: 0
      firstRowId: 44956
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.codec.model.yml
      index: 0
      firstRowId: 44957
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.bag.model.yml
      index: 0
      firstRowId: 44963
      rowCount: 18
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.bidimap.model.yml
      index: 0
      firstRowId: 44981
      rowCount: 32
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.collection.model.yml
      index: 0
      firstRowId: 45013
      rowCount: 40
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.iterators.model.yml
      index: 0
      firstRowId: 45053
      rowCount: 75
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.keyvalue.model.yml
      index: 0
      firstRowId: 45128
      rowCount: 52
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.list.model.yml
      index: 0
      firstRowId: 45180
      rowCount: 22
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.map.model.yml
      index: 0
      firstRowId: 45202
      rowCount: 128
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.model.yml
      index: 0
      firstRowId: 45330
      rowCount: 360
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.multimap.model.yml
      index: 0
      firstRowId: 45690
      rowCount: 12
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.multiset.model.yml
      index: 0
      firstRowId: 45702
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.properties.model.yml
      index: 0
      firstRowId: 45706
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.queue.model.yml
      index: 0
      firstRowId: 45714
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.set.model.yml
      index: 0
      firstRowId: 45720
      rowCount: 31
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.splitmap.model.yml
      index: 0
      firstRowId: 45751
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections.trie.model.yml
      index: 0
      firstRowId: 45755
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.bag.model.yml
      index: 0
      firstRowId: 45763
      rowCount: 18
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.bidimap.model.yml
      index: 0
      firstRowId: 45781
      rowCount: 32
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.collection.model.yml
      index: 0
      firstRowId: 45813
      rowCount: 40
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.iterators.model.yml
      index: 0
      firstRowId: 45853
      rowCount: 75
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.keyvalue.model.yml
      index: 0
      firstRowId: 45928
      rowCount: 52
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.list.model.yml
      index: 0
      firstRowId: 45980
      rowCount: 22
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.map.model.yml
      index: 0
      firstRowId: 46002
      rowCount: 128
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.model.yml
      index: 0
      firstRowId: 46130
      rowCount: 360
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.multimap.model.yml
      index: 0
      firstRowId: 46490
      rowCount: 12
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.multiset.model.yml
      index: 0
      firstRowId: 46502
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.properties.model.yml
      index: 0
      firstRowId: 46506
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.queue.model.yml
      index: 0
      firstRowId: 46514
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.set.model.yml
      index: 0
      firstRowId: 46520
      rowCount: 31
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.splitmap.model.yml
      index: 0
      firstRowId: 46551
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.collections4.trie.model.yml
      index: 0
      firstRowId: 46555
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.compress.archivers.tar.model.yml
      index: 0
      firstRowId: 46563
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.exec.environment.model.yml
      index: 0
      firstRowId: 46567
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.exec.launcher.model.yml
      index: 0
      firstRowId: 46568
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.exec.model.yml
      index: 0
      firstRowId: 46569
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.httpclient.util.model.yml
      index: 0
      firstRowId: 46577
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.io.model.yml
      index: 0
      firstRowId: 46578
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.io.model.yml
      index: 1
      firstRowId: 46585
      rowCount: 12
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.jelly.model.yml
      index: 0
      firstRowId: 46597
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.jexl2.model.yml
      index: 0
      firstRowId: 46603
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.jexl3.model.yml
      index: 0
      firstRowId: 46618
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang.model.yml
      index: 0
      firstRowId: 46633
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang3.builder.model.yml
      index: 0
      firstRowId: 46635
      rowCount: 18
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang3.model.yml
      index: 0
      firstRowId: 46653
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang3.model.yml
      index: 1
      firstRowId: 46659
      rowCount: 202
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang3.mutable.model.yml
      index: 0
      firstRowId: 46861
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang3.text.model.yml
      index: 0
      firstRowId: 46864
      rowCount: 155
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.lang3.tuple.model.yml
      index: 0
      firstRowId: 47019
      rowCount: 47
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.logging.model.yml
      index: 0
      firstRowId: 47066
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.net.ftp.model.yml
      index: 0
      firstRowId: 47072
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.net.model.yml
      index: 0
      firstRowId: 47076
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.net.model.yml
      index: 1
      firstRowId: 47085
      rowCount: 12
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.ognl.enhance.model.yml
      index: 0
      firstRowId: 47097
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.ognl.model.yml
      index: 0
      firstRowId: 47099
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.text.lookup.model.yml
      index: 0
      firstRowId: 47103
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.commons.text.model.yml
      index: 0
      firstRowId: 47105
      rowCount: 270
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.catalog.model.yml
      index: 0
      firstRowId: 47375
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.common.classloader.model.yml
      index: 0
      firstRowId: 47376
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.common.jaxb.model.yml
      index: 0
      firstRowId: 47379
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.common.logging.model.yml
      index: 0
      firstRowId: 47380
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.configuration.jsse.model.yml
      index: 0
      firstRowId: 47386
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.feature.transform.model.yml
      index: 0
      firstRowId: 47388
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.helpers.model.yml
      index: 0
      firstRowId: 47391
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.resource.model.yml
      index: 0
      firstRowId: 47401
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.staxutils.model.yml
      index: 0
      firstRowId: 47410
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.tools.corba.utils.model.yml
      index: 0
      firstRowId: 47411
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.cxf.tools.util.model.yml
      index: 0
      firstRowId: 47415
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.directory.ldap.client.api.model.yml
      index: 0
      firstRowId: 47425
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.fs.model.yml
      index: 0
      firstRowId: 47426
      rowCount: 11
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.fs.model.yml
      index: 1
      firstRowId: 47437
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.fs.s3a.model.yml
      index: 0
      firstRowId: 47439
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.hive.metastore.api.model.yml
      index: 0
      firstRowId: 47440
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.hive.metastore.model.yml
      index: 0
      firstRowId: 47441
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.hive.ql.exec.model.yml
      index: 0
      firstRowId: 47443
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.hive.ql.exec.model.yml
      index: 1
      firstRowId: 47444
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hadoop.hive.ql.metadata.model.yml
      index: 0
      firstRowId: 47445
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.client5.http.async.methods.model.yml
      index: 0
      firstRowId: 47446
      rowCount: 84
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.client5.http.classic.methods.model.yml
      index: 0
      firstRowId: 47530
      rowCount: 37
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.client5.http.fluent.model.yml
      index: 0
      firstRowId: 47567
      rowCount: 19
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.client5.http.protocol.model.yml
      index: 0
      firstRowId: 47586
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.benchmark.model.yml
      index: 0
      firstRowId: 47587
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.function.model.yml
      index: 0
      firstRowId: 47588
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.impl.bootstrap.model.yml
      index: 0
      firstRowId: 47589
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.io.entity.model.yml
      index: 0
      firstRowId: 47591
      rowCount: 14
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.io.model.yml
      index: 0
      firstRowId: 47605
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.io.support.model.yml
      index: 0
      firstRowId: 47607
      rowCount: 16
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.message.model.yml
      index: 0
      firstRowId: 47623
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.message.model.yml
      index: 1
      firstRowId: 47631
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.model.yml
      index: 0
      firstRowId: 47636
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.model.yml
      index: 1
      firstRowId: 47640
      rowCount: 26
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.nio.support.model.yml
      index: 0
      firstRowId: 47666
      rowCount: 24
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.http.support.model.yml
      index: 0
      firstRowId: 47690
      rowCount: 19
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.net.model.yml
      index: 0
      firstRowId: 47709
      rowCount: 18
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hc.core5.util.model.yml
      index: 0
      firstRowId: 47727
      rowCount: 24
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.hive.hcatalog.templeton.model.yml
      index: 0
      firstRowId: 47751
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.client.fluent.model.yml
      index: 0
      firstRowId: 47752
      rowCount: 16
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.client.methods.model.yml
      index: 0
      firstRowId: 47768
      rowCount: 19
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.client.model.yml
      index: 0
      firstRowId: 47787
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.client.utils.model.yml
      index: 0
      firstRowId: 47790
      rowCount: 20
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.entity.model.yml
      index: 0
      firstRowId: 47810
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.impl.client.model.yml
      index: 0
      firstRowId: 47816
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.message.model.yml
      index: 0
      firstRowId: 47817
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.message.model.yml
      index: 1
      firstRowId: 47823
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.model.yml
      index: 0
      firstRowId: 47824
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.model.yml
      index: 1
      firstRowId: 47826
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.model.yml
      index: 2
      firstRowId: 47828
      rowCount: 30
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.params.model.yml
      index: 0
      firstRowId: 47858
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.protocol.model.yml
      index: 0
      firstRowId: 47865
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.util.model.yml
      index: 0
      firstRowId: 47866
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.http.util.model.yml
      index: 1
      firstRowId: 47867
      rowCount: 31
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.ibatis.jdbc.model.yml
      index: 0
      firstRowId: 47898
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.ibatis.jdbc.model.yml
      index: 1
      firstRowId: 47904
      rowCount: 57
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.ibatis.mapping.model.yml
      index: 0
      firstRowId: 47961
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.log4j.model.yml
      index: 0
      firstRowId: 47962
      rowCount: 11
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.logging.log4j.model.yml
      index: 0
      firstRowId: 47973
      rowCount: 359
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.logging.log4j.model.yml
      index: 1
      firstRowId: 48332
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.shiro.codec.model.yml
      index: 0
      firstRowId: 48340
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.shiro.jndi.model.yml
      index: 0
      firstRowId: 48341
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.shiro.mgt.model.yml
      index: 0
      firstRowId: 48342
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.sshd.client.session.model.yml
      index: 0
      firstRowId: 48343
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.struts2.dispatcher.model.yml
      index: 0
      firstRowId: 48346
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.struts2.interceptor.model.yml
      index: 0
      firstRowId: 48347
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.tools.ant.model.yml
      index: 0
      firstRowId: 48349
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.tools.ant.taskdefs.model.yml
      index: 0
      firstRowId: 48354
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.tools.zip.model.yml
      index: 0
      firstRowId: 48361
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.velocity.app.model.yml
      index: 0
      firstRowId: 48362
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.velocity.runtime.model.yml
      index: 0
      firstRowId: 48366
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.apache.velocity.runtime.resource.util.model.yml
      index: 0
      firstRowId: 48369
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.codehaus.cargo.container.installer.model.yml
      index: 0
      firstRowId: 48370
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.codehaus.groovy.control.model.yml
      index: 0
      firstRowId: 48373
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.dom4j.model.yml
      index: 0
      firstRowId: 48374
      rowCount: 15
     -
      pack: codeql/java-all#1
      relativePath: ext/org.dom4j.tree.model.yml
      index: 0
      firstRowId: 48389
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.dom4j.util.model.yml
      index: 0
      firstRowId: 48391
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.eclipse.jetty.client.model.yml
      index: 0
      firstRowId: 48394
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.fusesource.leveldbjni.model.yml
      index: 0
      firstRowId: 48396
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.geogebra.web.full.main.model.yml
      index: 0
      firstRowId: 48397
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.gradle.api.file.model.yml
      index: 0
      firstRowId: 48398
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.hibernate.model.yml
      index: 0
      firstRowId: 48401
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.hibernate.query.model.yml
      index: 0
      firstRowId: 48405
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.influxdb.model.yml
      index: 0
      firstRowId: 48408
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.jboss.logging.model.yml
      index: 0
      firstRowId: 48409
      rowCount: 324
     -
      pack: codeql/java-all#1
      relativePath: ext/org.jdbi.v3.core.model.yml
      index: 0
      firstRowId: 48733
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.jooq.model.yml
      index: 0
      firstRowId: 48739
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.json.model.yml
      index: 0
      firstRowId: 48740
      rowCount: 236
     -
      pack: codeql/java-all#1
      relativePath: ext/org.keycloak.models.map.storage.model.yml
      index: 0
      firstRowId: 48976
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.kohsuke.stapler.bind.model.yml
      index: 0
      firstRowId: 48977
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.kohsuke.stapler.framework.adjunct.model.yml
      index: 0
      firstRowId: 48978
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.kohsuke.stapler.framework.io.model.yml
      index: 0
      firstRowId: 48979
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.kohsuke.stapler.json.model.yml
      index: 0
      firstRowId: 48980
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.kohsuke.stapler.model.yml
      index: 0
      firstRowId: 48982
      rowCount: 19
     -
      pack: codeql/java-all#1
      relativePath: ext/org.kohsuke.stapler.model.yml
      index: 1
      firstRowId: 49001
      rowCount: 21
     -
      pack: codeql/java-all#1
      relativePath: ext/org.mvel2.compiler.model.yml
      index: 0
      firstRowId: 49022
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.mvel2.jsr223.model.yml
      index: 0
      firstRowId: 49026
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.mvel2.model.yml
      index: 0
      firstRowId: 49029
      rowCount: 7
     -
      pack: codeql/java-all#1
      relativePath: ext/org.mvel2.templates.model.yml
      index: 0
      firstRowId: 49036
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.openjdk.jmh.runner.options.model.yml
      index: 0
      firstRowId: 49038
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.owasp.esapi.model.yml
      index: 0
      firstRowId: 49039
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.pac4j.jwt.config.encryption.model.yml
      index: 0
      firstRowId: 49040
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.pac4j.jwt.config.signature.model.yml
      index: 0
      firstRowId: 49044
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.scijava.log.model.yml
      index: 0
      firstRowId: 49048
      rowCount: 13
     -
      pack: codeql/java-all#1
      relativePath: ext/org.slf4j.model.yml
      index: 0
      firstRowId: 49061
      rowCount: 50
     -
      pack: codeql/java-all#1
      relativePath: ext/org.slf4j.spi.model.yml
      index: 0
      firstRowId: 49111
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/org.slf4j.spi.model.yml
      index: 1
      firstRowId: 49116
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.beans.model.yml
      index: 0
      firstRowId: 49122
      rowCount: 30
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.boot.jdbc.model.yml
      index: 0
      firstRowId: 49152
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.cache.model.yml
      index: 0
      firstRowId: 49153
      rowCount: 13
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.context.model.yml
      index: 0
      firstRowId: 49166
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.core.io.model.yml
      index: 0
      firstRowId: 49169
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.data.repository.model.yml
      index: 0
      firstRowId: 49172
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.http.model.yml
      index: 0
      firstRowId: 49173
      rowCount: 14
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.http.model.yml
      index: 1
      firstRowId: 49187
      rowCount: 77
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.jdbc.core.model.yml
      index: 0
      firstRowId: 49264
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.jdbc.core.namedparam.model.yml
      index: 0
      firstRowId: 49274
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.jdbc.datasource.model.yml
      index: 0
      firstRowId: 49283
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.jdbc.object.model.yml
      index: 0
      firstRowId: 49287
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.jndi.model.yml
      index: 0
      firstRowId: 49296
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.ldap.core.model.yml
      index: 0
      firstRowId: 49297
      rowCount: 33
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.ldap.model.yml
      index: 0
      firstRowId: 49330
      rowCount: 14
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.security.core.userdetails.model.yml
      index: 0
      firstRowId: 49344
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.security.web.savedrequest.model.yml
      index: 0
      firstRowId: 49346
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.ui.model.yml
      index: 0
      firstRowId: 49352
      rowCount: 32
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.util.model.yml
      index: 0
      firstRowId: 49384
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.util.model.yml
      index: 1
      firstRowId: 49387
      rowCount: 142
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.validation.model.yml
      index: 0
      firstRowId: 49529
      rowCount: 13
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.client.model.yml
      index: 0
      firstRowId: 49542
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.client.model.yml
      index: 1
      firstRowId: 49545
      rowCount: 13
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.context.request.model.yml
      index: 0
      firstRowId: 49558
      rowCount: 8
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.multipart.model.yml
      index: 0
      firstRowId: 49566
      rowCount: 12
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.multipart.model.yml
      index: 1
      firstRowId: 49578
      rowCount: 13
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.portlet.model.yml
      index: 0
      firstRowId: 49591
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.reactive.function.client.model.yml
      index: 0
      firstRowId: 49593
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.servlet.model.yml
      index: 0
      firstRowId: 49595
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.util.model.yml
      index: 0
      firstRowId: 49597
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/org.springframework.web.util.model.yml
      index: 1
      firstRowId: 49606
      rowCount: 157
     -
      pack: codeql/java-all#1
      relativePath: ext/org.thymeleaf.model.yml
      index: 0
      firstRowId: 49763
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.thymeleaf.model.yml
      index: 1
      firstRowId: 49765
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/org.xml.sax.model.yml
      index: 0
      firstRowId: 49767
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/org.xmlpull.v1.model.yml
      index: 0
      firstRowId: 49768
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/org.yaml.snakeyaml.model.yml
      index: 0
      firstRowId: 49771
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/play.libs.ws.model.yml
      index: 0
      firstRowId: 49772
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/play.mvc.model.yml
      index: 0
      firstRowId: 49774
      rowCount: 13
     -
      pack: codeql/java-all#1
      relativePath: ext/play.mvc.model.yml
      index: 1
      firstRowId: 49787
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/play.mvc.model.yml
      index: 2
      firstRowId: 49788
      rowCount: 24
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.core.form.model.yml
      index: 0
      firstRowId: 49812
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.core.handling.model.yml
      index: 0
      firstRowId: 49815
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.core.handling.model.yml
      index: 1
      firstRowId: 49821
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.core.http.model.yml
      index: 0
      firstRowId: 49825
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.core.http.model.yml
      index: 1
      firstRowId: 49835
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.exec.model.yml
      index: 0
      firstRowId: 49845
      rowCount: 48
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.form.model.yml
      index: 0
      firstRowId: 49893
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.func.model.yml
      index: 0
      firstRowId: 49896
      rowCount: 35
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.handling.model.yml
      index: 0
      firstRowId: 49931
      rowCount: 6
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.handling.model.yml
      index: 1
      firstRowId: 49937
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.http.model.yml
      index: 0
      firstRowId: 49941
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.http.model.yml
      index: 1
      firstRowId: 49951
      rowCount: 10
     -
      pack: codeql/java-all#1
      relativePath: ext/ratpack.util.model.yml
      index: 0
      firstRowId: 49961
      rowCount: 35
     -
      pack: codeql/java-all#1
      relativePath: ext/retrofit2.model.yml
      index: 0
      firstRowId: 49996
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/retrofit2.model.yml
      index: 1
      firstRowId: 49997
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/struts2.model.yml
      index: 0
      firstRowId: 49998
      rowCount: 64
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.jvmstat.perfdata.monitor.protocol.local.model.yml
      index: 0
      firstRowId: 50062
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.jvmstat.perfdata.monitor.protocol.rmi.model.yml
      index: 0
      firstRowId: 50065
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.misc.model.yml
      index: 0
      firstRowId: 50066
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.net.ftp.model.yml
      index: 0
      firstRowId: 50069
      rowCount: 5
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.net.www.protocol.http.model.yml
      index: 0
      firstRowId: 50074
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.acl.model.yml
      index: 0
      firstRowId: 50077
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.jgss.krb5.model.yml
      index: 0
      firstRowId: 50078
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.krb5.model.yml
      index: 0
      firstRowId: 50080
      rowCount: 9
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.pkcs.model.yml
      index: 0
      firstRowId: 50089
      rowCount: 4
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.pkcs11.model.yml
      index: 0
      firstRowId: 50093
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.provider.model.yml
      index: 0
      firstRowId: 50096
      rowCount: 2
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.ssl.model.yml
      index: 0
      firstRowId: 50098
      rowCount: 3
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.security.x509.model.yml
      index: 0
      firstRowId: 50101
      rowCount: 1
     -
      pack: codeql/java-all#1
      relativePath: ext/sun.tools.jconsole.model.yml
      index: 0
      firstRowId: 50102
      rowCount: 28
     -
      pack: codeql/java-queries#0
      relativePath: Telemetry/ExtractorInformation.yml
      index: 0
      firstRowId: 50130
      rowCount: 0
     -
      pack: codeql/threat-models#2
      relativePath: ext/threat-model-grouping.model.yml
      index: 0
      firstRowId: 50131
      rowCount: 10
  codeql/threat-models#2:
    name: codeql/threat-models
    version: 0.0.13
    localPath: C:\Users\Ashok Kalakoti\Downloads\codeql-bundle-win64\codeql\qlpacks\codeql\java-queries\0.8.14\.codeql\libraries\codeql\threat-models\0.0.13
    runDataExtensions: []
  codeql/java-all#1:
    name: codeql/java-all
    version: 0.9.1
    localPath: C:\Users\Ashok Kalakoti\Downloads\codeql-bundle-win64\codeql\qlpacks\codeql\java-queries\0.8.14\.codeql\libraries\codeql\java-all\0.9.1
    runDataExtensions: []
